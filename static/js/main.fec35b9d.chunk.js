(this["webpackJsonpsol2ligo-course"]=this["webpackJsonpsol2ligo-course"]||[]).push([[2],{283:function(e,n,t){},284:function(e,n,t){"use strict";t.r(n),n.default="Both Ethereum and Tezos contracts consist of Code and State parts but they are organized differently. Whereas Solidity contracts resemble classes Ligo contracts are set of functions. 'main' is the key entrypoint that introduces public functions and contract storage. \n\n\n\u2018Main\u2019 entrypoint has exactly two arguments - parameters and state - and return two parameters - a list of operations and an updated state. If the type of the main entrypoint is of Variant type its subtypes are interpreted as public functions otherwise main function is determined as the default entrypoint. \n\n\nDon't worry if it seems too complicated to grasp: each construction is explained in future chapters. The goal of this one is to show the high-level difference that has an impact on how the code is organized.\n"},285:function(e,n,t){"use strict";t.r(n),n.default="contract Thing {\n  uint private quality;\n  address public owner;\n\n  function changeOwner(address newOwner) public {\n      owner = newOwner;\n  }\n  function makeBetter() public {\n      quality++;   \n  }\n  function makeWorse() public{\n      quality--;   \n  }\n}"},286:function(e,n,t){"use strict";t.r(n),n.default="type changeOwner_args is record\n  newOwner : address;\nend;\n\ntype makeBetter_args is unit;\ntype makeWorse_args is unit;\ntype state is record\n  quality : nat;\n  owner : address;\nend;\n\ntype router_enum is\n | ChangeOwner of changeOwner_args\n | MakeBetter of makeBetter_args\n | MakeWorse of makeWorse_args;\n\nfunction changeOwner (const self : state; const newOwner : address) : (state) is\n  block {\n    self.owner := newOwner;\n  } with (self);\n\nfunction makeBetter (const self : state) : (state) is\n  block {\n    self.quality := (self.quality + 1n);\n  } with (self);\n\nfunction makeWorse (const self : state) : (state) is\n  block {\n    self.quality := (self.quality - 1n);\n  } with (self);\n\nfunction main (const action : router_enum; const self : state) : (list(operation) * state) is\n  (case action of\n  | ChangeOwner(match_action) -> ((nil: list(operation)), changeOwner(self, match_action.newOwner))\n  | MakeBetter(match_action) -> ((nil: list(operation)), makeBetter(self))\n  | MakeWorse(match_action) -> ((nil: list(operation)), makeWorse(self))\n  end);\n"},287:function(e,n,t){"use strict";t.r(n),n.default="\nIt is reasonable to start with an explanation of the function's syntax. They are the major building block of the contract and during the whole course, the examples will be provided inside the contract functions. Due to such an approach, the code can be copied, compiled, and deployed to the network on the fly.\n\nFunctions in Ligo are defined using the `function` keyword followed by their name, parameters, return type definitions and body.\n    \n```jsx\nfunction func_name (var arg0 : arg0_type[; var arg1 : arg1_type[ ... ]]) : return is \n  block {...} with return_value\n```\n    \nIf more than one expression should be executed, the body is a block construction.\n    \n```jsx\nfunction increment (var n : int) : int is \n  block { \n    n := n + 1n;\n    n := n + 3n;\n  } with n\n```\n    \nIf the logic can be represented by a single expression than block can be omitted. \n    \n```jsx\nfunction increment (var n : int) : int is n + 4n\n```\n    \nThere are no modifiers and analogs for Solidity view/pure functions.\n    \nIn Ligo at least one argument and any return value must be present. In the example on the right, if the function doesn't require any arguments, in Ligo it consumes one argument of `unit` type (similar to `void` in C/C++; nothing). The same applies to functions without return value (that are absolutely pointless in Tezos): the return value and its type is replaced by `unit`.\n"},288:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n\n\tfunction funcWithoutArguments() public {\n\t    uint i = 0;\n        i++;\n\t}\n\n\tfunction funcWithArguments(address user) public {\n\t    require(msg.sender == user);\n\t}\n\n\tfunction funcWithReturn() public returns (bool){\n\t    return false;\n\t}\n}"},289:function(e,n,t){"use strict";t.r(n),n.default="function funcWithoutArguments (const res__unit : unit) : (unit) is\n  block {\n    const i : nat = 0n;\n    i := i + 1n;\n  } with (unit);\n\nfunction funcWithArguments (const user : address) : (unit) is\n  block {\n    assert((Tezos.sender = user));\n  } with (unit);\n\nfunction funcWithReturn (const res__unit : unit) : (bool) is\n  block {\n    skip\n  } with (False);"},290:function(e,n,t){"use strict";t.r(n),n.default="In Ligo variables and constants are declared with keyword `var` and `cost`  as following:\n```jsx\nvar var_name : var_type := value;\nconst const_name : const_type = value;\n```\n\nUnlike Solidity, Ligo allows to declare constants both in function block and in the global scope, pass constants as function arguments. \n\nOn the other hand, Ligo doesn't have default values so the value should be explicitly set during declaration. Such a construction will raise an error:\n\n```jsx\nvar name : nat;\n```\n    \n**Note:** despite the `bool b` is reassigned in the code, transpiler converts it into a constant variable. Ligo compiler won't throw an error in this case: `const/var` separation is designed for the developer experience.\n"},291:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n\tuint256 constant u = 1;  \n\tfunction test() public pure {\n\t   bool b = false;\n\t\t b = true;\n     string memory s;\n  }\n}"},292:function(e,n,t){"use strict";t.r(n),n.default='\ntype state is unit;\n\nconst u : nat = 1n\n\nfunction test (const res__unit : unit) : (unit) is\n  block {\n    const b : bool = False;\n    b := True;\n    const s : string = "";\n  } with (unit);'},293:function(e,n,t){"use strict";t.r(n),n.default="The type of boolean value is denoted by `bool` with 4 defined operators in both languages. The syntax is different but quite clear.\n\n**Note:** the **equality** is checked by single `=` the same mark that is used for the constant declaration.\n"},294:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n\tfunction test() public {\n\t    bool boolean0 = false;\n\t    bool boolean1 = true;\n        bool boolean = boolean0 && boolean1; \n        boolean = boolean0 || boolean1; \n        boolean = boolean0 == boolean1; \n        boolean = boolean0 != boolean1; \n     }\n}\n"},295:function(e,n,t){"use strict";t.r(n),n.default="type state is unit;\n\nfunction test (const res__unit : unit) : (unit) is\n  block {\n    const boolean0 : bool = False;\n    const boolean1 : bool = True;\n    const boolean : bool = (boolean0 and boolean1);\n    boolean := (boolean0 or boolean1);\n    boolean := (boolean0 = boolean1);\n    boolean := (boolean0 =/= boolean1);\n  } with (unit);"},296:function(e,n,t){"use strict";t.r(n),n.default="Solidity has signed and unsigned integers of various sizes: denoted by  `uint8` to `uint256` in steps of 8 and `int8` to `int256`. Ligo has only 2 keywords for integers: `int` for signed and `nat` for unsigned integers.\n\nLigo supports bit operators and shifts on natural numbers only but allows the comparison and arithmetic operations for all numerical types. Bit operators are declared in `Bitwise` namespace. Other operators are quite similar to Solidity syntax. \n\nLigo also has a specific numerical type for XTZ units called `tez` that uses the same math as other numbers in the language. Literals are ended with suffix `tez` for an integer number of XTZ and with `mutez` for millionth units of the XTZ. For example:\n\n```jsx\nconst c : tez = 5mutez + 0.000_010tez\n```\n\nThe signed number can be converted to unsigned and vice versa with `abs` and `int` operator correspondingly.\n\nInteger literals are simple numbers and unsigned are followed with `n` suffix:\n\n```jsx\nconst a : int = 5\nconst b : nat = 5n\n```\n\nIn Solidity time is represented by unsigned integers, but Tezos VM introduces own type for time called `timestamp`. Only addition, subtraction, and comparison are defined for this type.\n"},297:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\nfunction testInt() public {\n    // declaration\n    int i0 = 5;\n    int i1 = 4;\n  \n  // comparisons\n    bool b = i0 > i1;\n    b = i0 >= i1;\n    b = i0 < i1;\n    b = i0 <= i1;\n    b = i0 == i1;\n    b = i0 != i1;\n    \n    // bit operators\n    int i = i0 & i1;\n    i = i0 | i1;\n    i = i0 ^ i1;\n    i =  ~i1;\n      \n    // shift operators\n    i = i0 << 1;\n    i = i0 >> 1;\n    \n    // arithmetic operators\n    i = i0 + i1;\n    i = i0 - i1;\n    i = -i1;\n    i = i0 / i1;\n    i = i0 * i1;\n    i = i0 % i1;\n  }\n\nfunction testUint() public {\n    // declaration\n    uint i0 = 5;\n    uint i1 = 4;\n  \n  // comparisons\n    bool b = i0 > i1;\n    b = i0 >= i1;\n    b = i0 < i1;\n    b = i0 <= i1;\n    b = i0 == i1;\n    b = i0 != i1;\n    \n    // bit operators\n    uint i = i0 & i1;\n    i = i0 | i1;\n    i = i0 ^ i1;\n    i =  ~i1;\n      \n    // shift operators\n    i = i0 << 1;\n    i = i0 >> 1;\n    \n    // arithmetic operators\n    i = i0 + i1;\n    i = i0 - i1;\n    i = i0 / i1;\n    i = i0 * i1;\n    i = i0 % i1;\n  }\n\n  function testTime() public {\n    uint time = now;\n  }\n}"},298:function(e,n,t){"use strict";t.r(n),n.default='type state is unit;\n\nfunction testInt (const res__unit : unit) : (unit) is\n  block {\n    const i0 : int = 5;\n    const i1 : int = 4;\n    const b : bool = (i0 > i1);\n    b := (i0 >= i1);\n    b := (i0 < i1);\n    b := (i0 <= i1);\n    b := (i0 = i1);\n    b := (i0 =/= i1);\n    const i : int = int(Bitwise.and(abs(i0), abs(i1)));\n    i := int(Bitwise.or(abs(i0), abs(i1)));\n    i := int(Bitwise.xor(abs(i0), abs(i1)));\n    i := not (i1);\n    i := int(Bitwise.shift_left(abs(i0), abs(1)));\n    i := int(Bitwise.shift_right(abs(i0), abs(1)));\n    i := (i0 + i1);\n    i := (i0 - i1);\n    i := -(i1);\n    i := (i0 / i1);\n    i := (i0 * i1);\n    i := int(i0 mod i1);\n  } with (unit);\n\nfunction testUint (const res__unit : unit) : (unit) is\n  block {\n    const i0 : nat = 5n;\n    const i1 : nat = 4n;\n    const b : bool = (i0 > i1);\n    b := (i0 >= i1);\n    b := (i0 < i1);\n    b := (i0 <= i1);\n    b := (i0 = i1);\n    b := (i0 =/= i1);\n    const i : nat = Bitwise.and(i0, i1);\n    i := Bitwise.or(i0, i1);\n    i := Bitwise.xor(i0, i1);\n    i := abs(not (i1));\n    i := Bitwise.shift_left(i0, 1n);\n    i := Bitwise.shift_right(i0, 1n);\n    i := (i0 + i1);\n    i := abs(i0 - i1);\n    i := (i0 / i1);\n    i := (i0 * i1);\n    i := (i0 mod i1);\n  } with (unit);\n\nfunction testTime (const res__unit : unit) : (unit) is\n  block {\n    const time : nat = abs(now - ("1970-01-01T00:00:00Z" : timestamp));\n  } with (unit);\n'},299:function(e,n,t){"use strict";t.r(n),n.default='Tezos and Ethereum addresses have a different format that is why the address literals cannot be transpiled properly. The code below won\'t be compiled because of the line:\n\n```jsx\na := (0xd27aCC8Eec0E6285c81972B5eEcd8dA241a4bCb5 : address);\n```\n\nThere are no special syntax to declare the address literal so the literals are represented by strings casted to address type. The following literal is correct:\n\n```jsx\na := ("tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" : address);\n```\n\nThe `address(0)` is usually used as burn address in Ethereum. To preserve the principle, it is advised to use some specially designed address from which nobody has the key. I.e the `"tz1ZZZZZZZZZZZZZZZZZZZZZZZZZZZZNkiRg"`.\n\nBoth languages support comparison operations for the type.'},300:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n\tfunction test(address a0, address a1) public {\n        bool b = a0 == a1;\n        b = a0 != a1;\n        b = a0 > a1;\n        b = a0 >= a1;\n        b = a0 < a1;\n        b = a0 <= a1;\n        address a = msg.sender;\n        a = address(0);\n        a = 0xd27aCC8Eec0E6285c81972B5eEcd8dA241a4bCb5;\n    }\n}"},301:function(e,n,t){"use strict";t.r(n),n.default='type state is unit;\n\nconst burn_address : address = ("tz1ZZZZZZZZZZZZZZZZZZZZZZZZZZZZNkiRg" : address);\nfunction test (const a0 : address; const a1 : address) : (unit) is\n  block {\n    const b : bool = (a0 = a1);\n    b := (a0 =/= a1);\n    b := (a0 > a1);\n    b := (a0 >= a1);\n    b := (a0 < a1);\n    b := (a0 <= a1);\n    const a : address = Tezos.sender;\n    a := burn_address;\n    a := (0xd27aCC8Eec0E6285c81972B5eEcd8dA241a4bCb5 : address);\n  } with (unit);'},302:function(e,n,t){"use strict";t.r(n),n.default='There are fixed- and dynamically-size byte arrays, strings in Solidity. Ligo has string type denoted by `string` and the only byte array type - `bytes`.\n\nThe Solidity bytes support comparison, bit and shift operations as well as index access. Meanwhile, Ligo bytes are less flexible and support comparison, slices, concatenation, packing, and unpacking.\n\nThe operations have the following syntax:\n\n```jsx\n(* concat: Bytes.concat(bytes0 , bytes1) *)\nconst b0 : bytes = Bytes.concat(("42" : bytes), ("21" : bytes));\n\n(* slice: Bytes.sub(start_index,length, bytes0) *)\nconst b1 : bytes = Bytes.sub(1n, 1n, b0);\n\n(* comparison: bytes0 = bytes1 *)\nconst b : bool = b0 = b1;\n\n(* pack: Bytes.pack(any_value) *)\nconst packed : bytes = Bytes.pack(b);\n\n(* unpack: Bytes.unpack(bytes0) *)\nconst unpacked : option(bool) = Bytes.unpack(packed);\n\n(* get length: bytes0.length *)\nconst len : nat = b1.length;\n```\n\nStrings resemble the Solidity strings with defined concatenation and slicing operators.  \n\nIn the example below the code won\'t be compiled because access by the index isn\'t supported in Ligo. Nevertheless, a Ligo developer could overcome it by such a line:\n\n```jsx\nconst b : bytes = Bytes.sub(0n, 1n, b0);\n```\n'},303:function(e,n,t){"use strict";t.r(n),n.default='contract Test {\n      \n  function testFixedSized() public {\n    bytes1 b0;\n    bytes1 b1 = 0x42;\n    bytes3 b2 = 0x222222;\n    bytes3 b3 = hex"32";\n\n    byte b = b0[0];\n    uint len = b3.length;\n    bool check = b0 == b1;\n    check = b0 > b1;\n    check = b0 >= b1;\n    check = b0 < b1;\n    check = b0 <= b1;\n  }\n\n  function testDynamicSized() public {\n    bytes memory b0 = new bytes (0);\n    bytes memory b1 = new bytes (20);\n\n    byte b = b1[2];\n  }\n\n  function testString() public {\n    string memory s0 = "Love Tezos";\n    string memory s1 = s0;\n  }\n}'},304:function(e,n,t){"use strict";t.r(n),n.default='type state is unit;\n\nfunction testFixedSized (const res__unit : unit) : (unit) is\n  block {\n    const b0 : bytes = ("00": bytes);\n    const b1 : bytes = 0x42;\n    const b2 : bytes = 0x222222;\n    const b3 : bytes = 0x50;\n    const b : bytes = (case b0[0n] of | None -> UNKNOWN_TYPE_DEFAULT_VALUE_byte | Some(x) -> x end);\n    const len : nat = b3.length;\n    const check : bool = (b0 = b1);\n    check := (b0 > b1);\n    check := (b0 >= b1);\n    check := (b0 < b1);\n    check := (b0 <= b1);\n  } with (unit);\n\nfunction testDynamicSized (const res__unit : unit) : (unit) is\n  block {\n    const b0 : bytes = ("00": bytes) (* args: 0 *);\n    const b1 : bytes = ("00": bytes) (* args: 20 *);\n    const b : bytes = (case b1[2n] of | None -> UNKNOWN_TYPE_DEFAULT_VALUE_byte | Some(x) -> x end);\n  } with (unit);\n\nfunction testString (const res__unit : unit) : (unit) is\n  block {\n    const s0 : string = "Love Tezos";\n    const s1 : string = s0;\n  } with (unit);'},305:function(e,n,t){"use strict";t.r(n),n.default="Enums are one way to create a user-defined type in Solidity. They are explicitly convertible to and from all integer types. Ligo doesn't have enumerations but introduces variant types instead.\n\nA variant type is a user-defined type representing data that may take on multiple different forms, where each form is marked by an explicit tag. The simplest example that works in the same way as an enumerator: \n\n```jsx\ntype day is \n| Sunday \n| Monday\n| Tuesday\n| Wednesday\n| Thursday\n| Friday \n| Saturday\n\nconst exent_time : day = Wednesday\nconst weekend : day = Saturday\n```\n\nAnother related Ligo-spesific type is an option. \n\nAn option type is the built-in type that represents an encapsulation of an optional value. Example usage:\n\n```jsx\nconst nothing : option(nat) = (None: option (nat));\nconst value : option(nat) = Some(10n);\n```\n\nBut indeed, it can be something more complex:\n\n```jsx\ntype action\n| Write of string\n| Read of address\n| Idle\n\nconst act : action = Read(Tezos.sender)\n\ncase act of\n| Write(a) -> { skip (*...do something *)}\n| Read(a) -> { skip (*...do something *)}\n| Idle -> { skip (*...do something *)}\nend \n```\n\nThe last construction is called pattern matching. The syntax for options is the same but only two subtypes are available - Some and None. \n\nDespite such a feature, there is the only disadvantage of using the variant type instead of Solidity enum: it cannot be compared or converted to numbers. That is why in some cases, it is worth using the constants. \n\nIf you prefer to use variant type as a true Ligo developer but you still need the comparison, pattern matching is the key. Consider the example below:\n\n```jsx\ntype status is ON | OF\n\nconst device0_status : status = ON;\nconst device1_status : status = ON;\n    \nconst is_status_equal : bool = case device0_status of\n  | ON -> case device1_status of\n    | ON -> True\n    | OF -> False\n    end\n  | OF -> case device1_status of\n    | ON -> False\n    | OF -> True\n    end\n  end\n```\n\n**Task**\n\nModify the example:\n\n1. Replace enum with varian type `Direction` with 4 options without arguments.\n2. Replace `correctDirection` intialization and both  `self.direction` and `correctDirection` assignment \n3. Implement direction comparison based on pattern matching\n"},306:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n  enum Direction { Left, Right, Straight, Back }\n  Direction public direction = Direction.Back;\n\n\tfunction test() public {\n    Direction correctDirection;\n    direction = correctDirection;\n    correctDirection = Direction.Straight;\n    bool check = correctDirection == direction;\n    check = uint(correctDirection) == uint(direction);\n  }\n}"},307:function(e,n,t){"use strict";t.r(n),n.default="type state is record\n  direction : nat;\nend;\n\nconst direction_Left : nat = 0n;\nconst direction_Right : nat = 1n;\nconst direction_Straight : nat = 2n;\nconst direction_Back : nat = 3n;\n(* enum Direction converted into list of nats *)\n\nfunction test (const self : state) : (state) is\n  block {\n    const correctDirection : nat = 0n;\n    self.direction := correctDirection;\n    correctDirection := direction_Straight;\n    const check : bool = (correctDirection = self.direction);\n    check := (abs(correctDirection) = abs(self.direction));\n  } with (self);"},308:function(e,n,t){"use strict";t.r(n),n.default="Value, or elementary, types are the type variables of which are always passed by value. In Solidity, they include: \n\n- booleans\n- integers\n- addresses\n- fixed-sized byte arrays\n- contract types\n- enumerations\n- some types of literals.\n\n**Note:** all Michelson primitives are loaded to the stack directly.  There is no such a term as variables under the hood. So the separation to value and reference type isn't applicable for Ligo. \n\nLigo booleans resemble the Solidity type. \n\nThe `int` is used instead of `intX` and `nat` type is used instead of `uintX`.\n\nThe addresses are quite interesting. Ethereum addresses have a different format compared to Tezos. In Solidity they are represented by bytes20 array meanwhile in Ligo there are no native address literals but base58check string can be converted to address type with `(addr_str: address)` expression. Sol2Ligo doesn't transpile it properly and Ligo compiler will throw an error in order the developer can notice the wrong address format. \n\nBytes in Ligo are represent as a hex number but not strings. \n\nThere is no enumeration type. In most cases variant type can replace it. The only downside is that it can not be converted to integers(that is the reason why transpiler doesn't convert Solidity enums to variant type).\n\nLigo also provide the type for XTZ token units. For instance:\n```jsx\nconst amount : tez = 10mutez; \n```\n\n**Note:** the true Ligo developer would replace:\n\n```jsx\nconst langEnum_LIGO : nat = 0n;\nconst langEnum_SOL : nat = 1n;\n...\nconst langEnum : nat = langEnum_SOL;\n```\n\nwith:\n\n```jsx\ntype langEnum is\n| LIGO\n| SOL\n...\nconst langEnum : LangEnum = SOL;\n```"},309:function(e,n,t){"use strict";t.r(n),n.default='contract Test {\n  enum LangEnum { LIGO, SOL }  \n\tfunction test() public {\n        // boolean\n    bool boolean = false;  \n  \n    // integers\n    int32  intVar0 = -603;\n    int256  intVar1 = -60313; \n    uint32  uintVar0 = 60313; \n    uint128  uintVar1 = 613; \n    \n    // address\n    address addressVar = 0x0000000000000000000000000000000000000000;\n\n    // bytes & strings\n    string  memory str = "TezosIsTheBest";\n    bytes memory b0  = "0121";\n    bytes1 b1 = "a";  \n    \n    // enumerations\n    LangEnum langEnum = LangEnum.SOL;\n  }\n}'},310:function(e,n,t){"use strict";t.r(n),n.default='type state is unit;\n\nconst langEnum_LIGO : nat = 0n;\nconst langEnum_SOL : nat = 1n;\n(* enum LangEnum converted into list of nats *)\n\nfunction test (const res__unit : unit) : (unit) is\n  block {\n    const boolean : bool = False;\n    const intVar0 : int = -(603);\n    const intVar1 : int = -(60313);\n    const uintVar0 : nat = 60313n;\n    const uintVar1 : nat = 613n;\n    const addressVar : address = (0x0000000000000000000000000000000000000000 : address);\n    const str : string = "TezosIsTheBest";\n    const b0 : bytes = 0x48495049;\n    const b1 : bytes = 0x97;\n    const langEnum : nat = langEnum_SOL;\n  } with (unit);'},311:function(e,n,t){"use strict";t.r(n),n.default='Ligo records serve as Solidity structures. A record is made of a set of fields, which are made of a field name and a field type. Given a value of a record type, the value bound to a field can be accessed by giving its field name to a special operator (`.`).\n\nThere is a special generated "default" Person - `test_Person_default`  used for assignment the `defaultPerson`.  It is needed as unlike Solidity,  Ligo doesn\'t have build-in default values for types but all variables must be assigned during the declaration.'},312:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n  struct Person {\n      address payable account;\n      uint age;\n      uint skill;\n      uint bet;\n      mapping (address => uint) referralRewards;\n  }\n\n  function test() public {\n    Person memory person = Person(msg.sender, 30, 100, 0);\n    Person memory defaultPerson;\n  }\n}"},313:function(e,n,t){"use strict";t.r(n),n.default="type test_Person is record\n  account : address;\n  age : nat;\n  skill : nat;\n  bet : nat;\n  referralRewards : map(address, nat);\nend;\n\ntype state is unit;\n\nconst test_Person_default : test_Person = record [ account = burn_address;\n  age = 0n;\n  skill = 0n;\n  bet = 0n;\n  referralRewards = (map end : map(address, nat)) ];\n\nfunction test (const res__unit : unit) : (unit) is\n  block {\n    const person : test_Person = record [ account = Tezos.sender;\n      age = 30;\n      skill = 100;\n      bet = 0 ];\n    const defaultPerson : test_Person = test_Person_default;\n  } with (unit);"},314:function(e,n,t){"use strict";t.r(n),n.default="Both Ligo and Solidity have mapping types but they act quite differently. \n\nFirst, there are two types of mappings in Tezos: \n\n- `map` : used for small number of entries and is fully deserialized before contract execution\n- `big_map` : designed for large number of entries and the needed values are loaded by request.\n\nThey are declared as: \n\n```jsx\n(* syntax: var name: map : map(key_type, value_type) = map[ \n  key0 -> value[; key1 -> value1[; ...]]  \n] *)\nconst ledger : map(address, nat) = map [];\nconst big_ledger : big_map(address, nat) = map [Tezos.sender -> 100n;];\n```\n\nSecond, Ligo doesn't have default values for absent members. The value retrieved from the map is of `option` type.  `None` is returned If the key doesn't exist, and `Some(value)` otherwise:\n\n```jsx\nconst my_balance : option (nat) = ledger [Tezos.sender] \n```\n\nThird, it is possible to iterate over the `map`.  But the iterated operation has no return value: its only useful for causing side-effects or checking some requirements. \n\n```jsx\nfunction check_balance (const user : address; const balance : nat) : unit is\n      if balance > 1n then Unit else (failwith (\"Balance too low\") : unit)\nMap.iter (check_balance, ledger);\n```\n\nCommonalities can be explored in the example.\n"},315:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n    mapping(int => int) public m;\n\n  function test() public {\n        m[4] = 8;\n        m[15] = m[16];\n        delete m[23];\n      }\n}"},316:function(e,n,t){"use strict";t.r(n),n.default="type state is record\n  m : map(int, int);\nend;\n\nfunction test (const self : state) : (state) is\n  block {\n    self.m[4] := 8;\n    self.m[15] := (case self.m[16] of | None -> 0 | Some(x) -> x end);\n    remove 23 from map self.m;\n  } with (self);"},317:function(e,n,t){"use strict";t.r(n),n.default="There are fixed and dynamic-sized arrays in Solidity. Their elements can be accessed by index and the type member `length` is defined. The dynamic arrays also have `push` and `pop` operators.  \n\nLigo doesn't have the exact type that implements all the operations that can be done on the Solidity array but it introduces 3 other collection types: tuples, lists, sets.\n\n[Comparison](https://www.notion.so/cc2793612ebd4ad3b30845b5019f6a06)\n\nEach type deserves more attention and will be discussed in depth further. \n\nAnother approach to simulate the Solidity arrays functionality is to use maps with numeric keys.  But it isn't the advised path of the respected Ligo ninja."},318:function(e,n,t){"use strict";t.r(n),n.default="\ncontract Test {\n    uint[] a1;\n    \n  function testFixedSized() public {\n        uint[4] memory a0 = [uint(1), 2, 3, 4];\n\n        uint len = a0.length;\n        uint element = a0[1];\n      }\n      \n  function testDynamicSized() public {\n        a1 = new uint[](5);\n        \n        uint len = a1.length;\n        uint element = a1[1];\n        \n        a1.push(1);\n        // a1.pop();\n      }\n}"},319:function(e,n,t){"use strict";t.r(n),n.default="type state is record\n  a1 : map(nat, nat);\nend;\n\nfunction testFixedSized (const res__unit : unit) : (unit) is\n  block {\n    const a0 : map(nat, nat) = map\n      0n -> abs(1);\n      1n -> 2n;\n      2n -> 3n;\n      3n -> 4n;\n    end;\n    const len : nat = size(a0);\n    const element : nat = (case a0[1n] of | None -> 0n | Some(x) -> x end);\n  } with (unit);\n\nfunction testDynamicSized (const self : state) : (state) is\n  block {\n    self.a1 := map end (* args: 5 *);\n    const len : nat = size(self.a1);\n    const element : nat = (case self.a1[1n] of | None -> 0n | Some(x) -> x end);\n    const tmp_0 : map(nat, nat) = self.a1;\n    tmp_0[size(tmp_0)] := 1n;\n  } with (self);"},320:function(e,n,t){"use strict";t.r(n),n.default='Tuples are fixed-size arrays that can contain a number of elements of different types in the given order and that are accessible by index.\n\nThe tuples definition and accessing by index is presented in the example below:\n\n```jsx\n(* syntax: const tuple_name : type0 [* type1 [...]] = (value0[, value1[,...]] *)\nconst pasport_code : string * nat = ("XP", "31432154928");\n(* syntax: tuple_name.index *)\nconst serial_number : string = pasport_code.0;\n```\n\n**Task**\n\nUpdate the example from previous task using tuples:\n\n1. Replace `a1` type inside the `state` type with tuple of 4 `nat`  elements\n2. Update `a1` declaration\n3. Set `len` to `4n`, as the tuples doesn\'t have the size method.\n4. Get the first element of the tuple and store it to  `element` variable.'},321:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n  uint[] a1;\n    \n\tfunction testFixedSized() public {\n    uint[4] memory a0 = [uint(1), 2, 3, 4];\n\n    uint len = a0.length;\n    uint element = a0[1];\n  }\n}"},322:function(e,n,t){"use strict";t.r(n),n.default="type state is record\n  a1 : map(nat, nat);\nend;\n\nfunction testFixedSized (const res__unit : unit) : (unit) is\n  block {\n    const a0 : map(nat, nat) = map\n      0n -> abs(1);\n      1n -> 2n;\n      2n -> 3n;\n      3n -> 4n;\n    end;\n    const len : nat = size(a0);\n    const element : nat = (case a0[1n] of | None -> 0n | Some(x) -> x end);\n  } with (unit);"},323:function(e,n,t){"use strict";t.r(n),n.default='The list is a dynamic-sized lineal collection of values of the same type.  Elements cannot be deleted or accessed by index. Linear means that, in order to reach an element in a list, we must visit all the elements before, and thus there are only operations to iterate through the lists.\n\nConsider the definition of the list and adding the elements to it:\n\n```jsx\n(* syntax: const list_name : list(element_type) = list[ element0[; element1[;...]] ] *)\n(* empty lists *)\nvar l : list(int) = list[];\nl := (nil : list(nat));\n\n(* list with initial elements *)\nl := list[1; 2; 3;];\n\n(*syntax: list_name := element # list_name; *)\n(* adding to list *)\nl := 4 # l;\n```\n\nThere are 3 types of iterations: `iter`, `fold`, `map`.\n\nThe iterated operation is an iteration over the list with a unit return value. It is useful to enforce certain invariants on the element of a list or fail. Usage:\n\n```jsx\nfunction iterate (const i : int) : unit is\n    if i > 3 then Unit else (failwith ("Too big") : unit)\nvar l : list(int) = list[1; 2; 3;];\nList.iter (iterate, l);\n```\n\nMap operation changes all the elements of a given list by applying to them a function. Can be used for deleting an element from the collection. Example:\n\n```jsx\nvar l : list(int) = list[1; 2; 3;];    \nvar index : nat = 0n;\nvar counter : nat = 0n;\nfunction delete_by_index (const element : nat): nat is \n  block {\n    counter := counter + 1n;\n  } with if counter = index then 0n else element;  \nl := List.map (delete_by_index, l);\n```\n\nA folded operation is an iteration over the list with an accumulated return value. The folded function takes two arguments: an accumulator and the structure element at hand, with which it then produces a new accumulator. The last accumulator is returned from the function. Can be considered as an expensive way to get the element at a given index. \n\n```jsx\nvar l : list(int) = list[1; 2; 3;];    \nvar index : nat = 0n;\nvar counter : nat = 0n;\nfunction get_by_index (const found : nat; const element : nat): nat is \n  block {\n    counter := counter + 1n;\n  } with if counter = index then element else found;  \nconst element : nat = List.fold (get_by_index, l, 0n);\n```\n\n**Task**\n\nUpdate the example from previous task using lists:\n\n1. Replace `a1` type inside the `state` type with list of `nat`  type\n2. Update `a1` declaration\n3. Find the element at the index by  `List.fold` operation\n4. Add element `1n` in the end of the list\n5. Remove the element at the index by `List.map` operation.'},324:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n  uint[] a1;\n    \n\tfunction testDynamicSized() public {\n    a1 = new uint[](5);\n    \n    uint len = a1.length;\n    uint element = a1[1];\n    \n    a1.push(1);\n    delete a1[0];\n    // a1.pop();\n  }\n}"},325:function(e,n,t){"use strict";t.r(n),n.default="type state is record\na1 : map(nat, nat);\nend;\n\nfunction testDynamicSized (const self : state) : (state) is\nblock {\n  self.a1 := map end (* args: 5 *);\n  const len : nat = size(self.a1);\n  const element : nat = (case self.a1[1n] of | None -> 0n | Some(x) -> x end);\n  const tmp_0 : map(nat, nat) = self.a1;\n  tmp_0[size(tmp_0)] := 1n;\n  remove 0n from map self.a1;\n} with (self);"},326:function(e,n,t){"use strict";t.r(n),n.default="Set is the unordered dynamic-sized array of unique values of the same type. Just like in lists elements cannot be accessed by index but the defined operations include iterations, adding and removing elements, checking if the element is present.\n\nConsider set basic syntax that resembles operations on lists:\n\n```jsx\n(* syntax: const set_name : set(element_type) = set[ element0[; element1[;...]] ] *)\n(* empty sets *)\nvar s : set(int) = set[];\ns := (set[] : set(nat));\n\n(* set with initial elements *)\ns := set[1; 2; 3;];\n\n(* syntax: set_name := Set.add(element, set_name) *)\n(* adding to set *)\ns := Set.add(4, s);\n\n(* syntax: set_name := Set.remove(element, set_name) *)\n(* removing from set *)\ns := Set.remove(1, s);\n\n(* syntax: Set.size(set_name) *)\n(* get set size *)\nconst len : nat = Set.size(s);\n\n(* syntax: set_name contains element *)\n(* check element presents *)\nconst exists : bool = s contains 5;\n```\n\nIteration operations are the same as for lists but denoted by `Set.iter`, `Set.fold`, `Set.map`.\n\n**Task**\n\nUpdate the example below using sets:\n\n1. Replace `a1` type inside the `state` type with set of `nat`  type\n2. Update `a1` declaration\n3. Update the loop for checking if the element exists in collection using `contains` \n4. Add element at the index by  `Set.add` operation\n5. Remove the first added element `1n` by `Set.remove` operation; note: as set isn't ordered collection, the elements are deleted by value but not index."},327:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n  uint[] a1;\n    \n  function testDynamicSized() public {\n    a1 = new uint[](5);\n    \n    uint len = a1.length;\n\n    bool isInArray;\n    \n    for (uint i=0; i < a1.length; i++) {\n        isInArray = a1[i] == 5 ? true : isInArray;\n    }\n    \n    a1.push(1);\n    delete a1[0];\n  }\n}"},328:function(e,n,t){"use strict";t.r(n),n.default="type state is record\n  a1 : map(nat, nat);\nend;\n\nfunction testDynamicSized (const self : state) : (state) is\n  block {\n    self.a1 := map end (* args: 5 *);\n    const len : nat = size(self.a1);\n    const isInArray : bool = False;\n    const i : nat = 0n;\n    while (i < size(self.a1)) block {\n      isInArray := (case ((case self.a1[i] of | None -> 0n | Some(x) -> x end) = 5n) of | True -> True | False -> isInArray end);\n      i := i + 1n;\n    };\n    const tmp_0 : map(nat, nat) = self.a1;\n    tmp_0[size(tmp_0)] := 1n;\n    remove 0n from map self.a1;\n  } with (self);"},329:function(e,n,t){"use strict";t.r(n),n.default="There are 3 complex types in Solidity:\n\n- arrays;\n- structs;\n- mappings.\n\nMeanwhile Ligo is more diverse:\n\n- Records: struct-like objects, the fields can be accessed and modified by name; fields can be any types, except `big_map`;\n- Tuples: fixed-size array that can contain elements of different types; elements can be  accessed by index;\n- Lists: a dynamic-sized array of the same type, elements cannot be deleted or accessed by index; there are operations to iterate through the lists;\n- Sets: dynamic-sized array with unique values of the same type, elements cannot be accessed by index; there are operations to iterate, add, remove, check if the element is present;\n- Maps and big maps: dictionaries, big maps are cheaper to use and their values are accessed by keys only meanwhile maps consume more gas but there is an operation to iterate through its pairs.\n- Options: None/Some wrapper;\n- Units: absence of type, similar to `void` in C/C++;\n- Variants: the type, that wraps some other types, similar to unions.\n\nLigo doesn't support the type that implements all the operations that can be done on Solidity array so migration from one language to another can be quite tricky. sol2ligo transpiles arrays to maps but it may be an inappropriate approach for the particular solution.  \n\nThe other mentioned types are declared as following and were discussed in previous chapters:\n\n```jsx\n// tuple\nconst t : (nat * int) = (10n * 1);\n// list\nconst l : list(nat) = list [21n; 42n; 21n];\n// set\nconst s : set(nat) = set [1n; 2n; 3n];\n// map\n```"},330:function(e,n,t){"use strict";t.r(n),n.default='contract Test {\n  mapping(address => uint) public addressToUintMap;\n  uint[] public uArray;\n  struct SimpleSruct {\n      string s;\n      bytes b;\n  }\n    \n  function test() public view {\n      int32[3] memory iArray = [-11335678, 2343, 321323];\n      SimpleSruct memory s = SimpleSruct("Ligo", "42");\n  }\n}'},331:function(e,n,t){"use strict";t.r(n),n.default='type test_SimpleSruct is record\n  s : string;\n  b : bytes;\nend;\n\ntype state is record\n  addressToUintMap : map(address, nat);\n  uArray : map(nat, nat);\nend;\n\nconst test_SimpleSruct_default : test_SimpleSruct = record [ s = "";\n  b = ("00": bytes) ];\n\nfunction test (const res__unit : unit) : (unit) is\n  block {\n    const iArray : map(nat, int) = map\n      0n -> -(11335678);\n      1n -> 2343;\n      2n -> 321323;\n    end;\n    const s : test_SimpleSruct = record [ s = "Ligo";\n      b = "42" ];\n  } with (unit);\n  '},332:function(e,n,t){"use strict";t.r(n),n.default='Despite simplicity, Ligo has some features that are not present in Solidity but that makes the developer\'s life better. One of them is type aliases denoted by `type` keyword.\n\nFor instance:\n\n```jsx\ntype language is string\ntype chain is string\nconst blockchain_info : (language * chain) = ("Archetype", "Tezos")\n```\n\n**Task**\n\nLet\'s consider the dummy contract.  `userBags` is the mapping of all users belongings in their bags. There are exactly three slots for things and the staff should be placed in the exact order: key, pen, eraser. The `putBagsThings` prepare bags for the transaction sender. \n\nIn the Solidity, as you see the code is quite straightforward but the compiled version seems is quite overloaded. \n\nRefactor the code:\n\n1. Declare alias for `key_type` and `stationery_type`.\n2. Replace the `map(nat, string)` with tuple of type `(key_type * stationery_type * stationery_type`) \n3. Update key, pen, eraser types\n4. Change the step of setting new map value'},333:function(e,n,t){"use strict";t.r(n),n.default='contract Test {\n  // user address => [keys, pen, eraser]\n  mapping(address => string[3]) public userBags;\n\n  function putBagsThings() public {\n    string memory key = "home key";\n    string memory pen = "red pen";\n    string memory eraser = "small eraser";\n\n    userBags[msg.sender] = [key, pen, eraser];\n  }\n}'},334:function(e,n,t){"use strict";t.r(n),n.default='type state is record\n  userBags : map(address, map(nat, string));\nend;\n\nfunction putBagsThings (const self : state) : (state) is\n  block {\n    const key : string = "home key";\n    const pen : string = "red pen";\n    const eraser : string = "small eraser";\n    self.userBags[Tezos.sender] := map\n      0n -> key;\n      1n -> pen;\n      2n -> eraser;\n    end;\n  } with (self);'},335:function(e,n,t){"use strict";t.r(n),n.default="In Ligo conditions must have both `if` and `else` branches and have the following syntax:\n\n```jsx\n(* syntax: if condition then actions0 else actions1 *)\n(* condition with one instruction in branch*)\nif a = b then a := 10n else b := 1n;\n\n(* condition with few actions *)\nif a = b then block {\n  a := 10n;\n  b := 0n; \n} else b := 1n;\n\n(* condition with missing block *)\nif a = b then a := 10n else skip;\n```"},336:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n\tfunction test() public {\n    int a = 3;\n    int b = 9;\n    if (a == b) a = 10; \n    else b = 1;\n    \n    if (a == b) {\n        a = 10;\n        b = 0;\n    } else b = 1;\n    \n    if (a == b) a = 10; \n  }\n}"},337:function(e,n,t){"use strict";t.r(n),n.default="type state is unit;\n\nfunction test (const res__unit : unit) : (unit) is\n  block {\n    const a : int = 3;\n    const b : int = 9;\n    if (a = b) then block {\n      a := 10;\n    } else block {\n      b := 1;\n    };\n    if (a = b) then block {\n      a := 10;\n      b := 0;\n    } else block {\n      b := 1;\n    };\n    if (a = b) then block {\n      a := 10;\n    } else block {\n      skip\n    };\n  } with (unit);"},338:function(e,n,t){"use strict";t.r(n),n.default='Solidity has a convenient type casting but in Ligo it can be a bit tricky. The most common conversions are:\n```jsx\n(* nat <- int *)\nconst u : nat = abs(1);\n(* int <- nat *)\nconst i : int = int(1n);\n(* address <- string *)\nconst a : address = ("tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" : address);\n(* tez <- nat *)\nconst tz : tez = u * 1mutez;\n(* nat <- tez *)\nconst n : nat = tz / 1mutez;\n(* tez <- int *)\nconst t : tez = abs(i) * 1mutez;\n(* int <- tez *)\nconst i : int = int(t / 1mutez);\n(* nat <- timestamp *)\nconst n : nat = abs(now - ("1970-01-01T00:00:00Z" : timestamp));\n(* timestamp <- nat *)\nconst t : timestamp = ("1970-01-01T00:00:00Z" : timestamp) + int(u);\n(* timestamp <- int *)\nconst t : timestamp = ("1970-01-01T00:00:00Z" : timestamp) + i;\n(* int <- timestamp *)\nconst i : int = now - ("1970-01-01T00:00:00Z" : timestamp);\n(* bytes <- nat *)\nconst b : bytes = Bytes.pack(u);\n(* nat -> bytes *)\nconst u : nat = Bytes.unpack(b);\n(* bytes <- int *)\nconst b : bytes = Bytes.pack(i);\n(* int -> bytes *)\nconst i : int = Bytes.unpack(b);\n(* bytes <-  tez *)\nconst b : bytes = Bytes.pack(tz);\n(*  tez -> bytes *)\nconst tz : tez = Bytes.unpack(b);\n(* bytes <- timestamp *)\nconst b : bytes = Bytes.pack(t);\n(*  timestamp -> bytes *)\nconst t : timestamp = Bytes.unpack(b);\n(* bytes <- address | string *)\nconst b : bytes = Bytes.pack(a);\n(* address -> bytes *)\nconst a : address = Bytes.unpack(b);\n(* bytes <- string *)\nconst b : bytes = Bytes.pack("just a string");\n(* string-> bytes *)\nconst s : string = Bytes.unpack(b);\n```\n'},339:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n  function test() public payable {\n      uint u = 1;\n      uint i = 1;\n      uint uu = uint(i);\n      uint ii = uint(u);\n      uint n0 = msg.value; \n      uint t0 = now;\n    }\n}"},340:function(e,n,t){"use strict";t.r(n),n.default='type state is unit;\n\nfunction test (const res__unit : unit) : (unit) is\n  block {\n    const u : nat = 1n;\n    const i : nat = 1n;\n    const uu : nat = abs(i);\n    const ii : nat = abs(u);\n    const n0 : nat = (amount / 1mutez);\n    const t0 : nat = abs(now - ("1970-01-01T00:00:00Z" : timestamp));\n  } with (unit);'},341:function(e,n,t){"use strict";t.r(n),n.default="There are two keywords for iterations in Ligo:  `for` and `while`. Unlike Solidity, Ligo doesn't support `continue` or `break` operations. Usage:\n\n```jsx\n(* syntax:\nwhile condition block {\n    action0;\n    ...\n    actionN;\n}; *)\nwhile y =/= 0n block {\n    z := x mod y;\n    y := y - 1n;\n}\n(* syntax:\nfor iterator := init to last block {\n    action0;\n    ...\n    actionN;\n} )*\nfor i := 1 to 10 block {\n    acc := acc + i\n}\n```\n\n**Note:** in the example below, the code won't be compiled as the blocks with `continue` and `break` comments are empty. Add `skip` instruction to fix it."},342:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n\n\tfunction test() public {\n  uint sum;\n  uint j;\n    for (uint j; j < 10; j++) {\n        sum +=j;\n    }\n    \n    sum=0;\n    j=0;\n    while(j < 10) {\n        sum +=j;\n        j++;\n    }\n    \n    // sum=0;\n    // j=0;\n    // do {\n    //     sum +=j;\n    //     j++;\n    // } while (j < 10);\n    \n    sum=0;\n    j=0;\n    while(j < 10) {\n        if (j == 5) continue;\n        sum +=j;\n        if (sum % 5 == 1) break;\n        j++;\n    }\n  }\n}"},343:function(e,n,t){"use strict";t.r(n),n.default="type state is unit;\n\nfunction test (const res__unit : unit) : (unit) is\n  block {\n    const sum : nat = 0n;\n    const j : nat = 0n;\n    const j : nat = 0n;\n    while (j < 10n) block {\n      sum := (sum + j);\n      j := j + 1n;\n    };\n    sum := 0n;\n    j := 0n;\n    while (j < 10n) block {\n      sum := (sum + j);\n      j := j + 1n;\n    };\n    sum := 0n;\n    j := 0n;\n    while (j < 10n) block {\n      if (j = 5n) then block {\n        (* `continue` statement is not supported in LIGO *);\n      } else block {\n        skip\n      };\n      sum := (sum + j);\n      if ((sum mod 5n) = 1n) then block {\n        (* `break` statement is not supported in LIGO *);\n      } else block {\n        skip\n      };\n      j := j + 1n;\n    };\n  } with (unit);"},344:function(e,n,t){"use strict";t.r(n),n.default="Some of special Solidity variables have analogues in Ligo. \n\nThere is no analogous to `msg.data`.\n\nAs the current time is of the `timestamp` type, the subtraction of the beginning of the Unix epoch is used to convert it to `nat`. This step usually should be omitted as most of operations with time can be done with `timestamp` and is present only for Solidity compatibility."},345:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n  function test() public payable {\n      address sender = msg.sender;\n      address source = tx.origin;\n      uint value = msg.value;\n      bytes memory data = msg.data;\n      uint time = now;\n      uint blockTimestamp = block.timestamp;\n  }\n}"},346:function(e,n,t){"use strict";t.r(n),n.default='type state is unit;\n\nfunction test (const res__unit : unit) : (unit) is\n  block {\n    const res__sender : address = Tezos.sender;\n    const res__source : address = Tezos.source;\n    const value : nat = (amount / 1mutez);\n    const data : bytes = ("00": bytes);\n    const time : nat = abs(now - ("1970-01-01T00:00:00Z" : timestamp));\n    const blockTimestamp : nat = abs(now - ("1970-01-01T00:00:00Z" : timestamp));\n  } with (unit);'},347:function(e,n,t){"use strict";t.r(n),n.default='For convenience, the Ligo has macros for importing the code from local files. It can not be reproduced by transpiler but the syntaxis the following:\n\n```jsx\nimport "./ERC20.sol";\n```\n\n```jsx\n#import "./ERC20.ligo"\n// or\n#import "./ERC20.tz"\n```\n\nBoth Michelson and Ligo files are supported.'},348:function(e,n,t){"use strict";t.r(n),n.default="undefined"},349:function(e,n,t){"use strict";t.r(n),n.default="undefined"},350:function(e,n,t){"use strict";t.r(n),n.default="The Solidity smart contracts have functions visibility such as `external`, `public`, `internal` and `private`. Ligo contracts are organized in a completely different way.  All the functions are internal and the public methods are defined using the first argument of the `main` function. \n\nMain function takes exactly two arguments - user `action` and on-chain `state` - and return two values - a list of external operations and an updated `state`. When the contract is originated, the initial value of the storage is provided. When a main function is later called, only the parameter is provided, but the type of a main function contains both.\n\nIf the `action` is of Variant type its subtypes are interpreted as public functions interface otherwise main function is determined as the `default` entrypoint with the arguments of the same type as `action`. \n\nExample of the contracts with the only default public function/default entrypoint:\n\n```jsx\ntype parameter is string\n\ntype storage is record [\n  counter : nat;\n  name    : string\n]\n\ntype return is list (operation) * storage\n\nfunction main (const s : string; const store : storage) : return is\n  ((nil : list (operation)), store with record [name = s])\n```\n\nExample of the contracts with the few public methods/few entrypoints:\n\n```jsx\ntype parameter is\n| Action_A of nat\n| Action_B of string\n\ntype storage is record [\n  counter : nat;\n  name    : string\n]\n\ntype return is list (operation) * storage\n\nfunction func_A (const n : nat; const store : storage) : return is\n  ((nil : list (operation)), store with record [counter = n])\n\nfunction func_B (const s : string; const store : storage) : return is\n  ((nil : list (operation)), store with record [name = s])\n\nfunction main (const action : parameter; const store : storage): return is\n  case action of\n  | Action_A (n) -> func_A (n, store)\n  | Action_B (s) -> func_B (s, store)\n  end\n```\n\n**Note:** the name of the entrypoint is the name of variant subtype and not the function itself.\n\nThe operations list is the queue of operations that should be executed after this. They can involve other contract calls, external XTZ transfers or be directed to the same contract.\n\nRead-only functions have a different representation in Ligo and  `pure` / `view` functions are more complicated in Tezos scope. The key difference lays is the requirement to consume the receiver contract address as an argument. So the result of the return value is always sent to another contract as a separate operation. Consider the contract with default view etrypoint that returns its storage to the `contr`:\n\n```jsx\ntype storage is nat\ntype return is list (operation) * storage\n\nfunction main (const contr : contract(storage); var s : storage) : return is\n  (list [transaction(s, 0tz, contr)], s)\n```\n\nHow the contract `contr` processes the received value is out of this chapter's scope.\n"},351:function(e,n,t){"use strict";t.r(n),n.default="contract Test {\n  uint private data;\n\n  function f(uint a) private pure returns(uint b) { return a + 1; }\n  function setData(uint a) public { data = a; }\n  function getData() public view returns(uint) { return data; }\n  function compute(uint a, uint b) internal pure returns (uint) { return a + b; }\n}"},352:function(e,n,t){"use strict";t.r(n),n.default="type setData_args is record\n  a : nat;\nend;\n\ntype getData_args is record\n  callbackAddress : address;\nend;\n\ntype state is record\n  data : nat;\nend;\n\ntype router_enum is\n  | SetData of setData_args\n | GetData of getData_args;\n\nfunction f (const a : nat) : (nat) is\n  block {\n    const b : nat = 0n;\n  } with ((a + 1n));\n\nfunction setData (const self : state; const a : nat) : (state) is\n  block {\n    self.data := a;\n  } with (self);\n\nfunction getData (const self : state) : (nat) is\n  block {\n    skip\n  } with (self.data);\n\nfunction compute (const a : nat; const b : nat) : (nat) is\n  block {\n    skip\n  } with ((a + b));\n\nfunction main (const action : router_enum; const self : state) : (list(operation) * state) is\n  (case action of\n  | SetData(match_action) -> ((nil: list(operation)), setData(self, match_action.a))\n  | GetData(match_action) -> block {\n    const tmp : (nat) = getData(self);\n    var opList : list(operation) := list transaction((tmp), 0mutez, (get_contract(match_action.callbackAddress) : contract(nat))) end;\n  } with ((opList, self))\n  end);"},607:function(e,n,t){"use strict";t.r(n);var s=t(23),i=t(36),a=t.n(i),o=t(271),r=t.n(o),c=(t(283),t(117)),l=t(177);function d(){return(d=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s])}return e}).apply(this,arguments)}function u(e,n){if(null==e)return{};var t,s,i=function(e,n){if(null==e)return{};var t,s,i={},a=Object.keys(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var f=i.createElement("path",{d:"M14 13.5h2.5l1-4H14v-2c0-1.03 0-2 2-2h1.5V2.14c-.326-.043-1.557-.14-2.857-.14C11.928 2 10 3.657 10 6.7v2.8H7v4h3V22h4v-8.5z"});function m(e,n){var t=e.title,s=e.titleId,a=u(e,["title","titleId"]);return i.createElement("svg",d({fill:"currentColor",viewBox:"0 0 24 24",ref:n,"aria-labelledby":s},a),t?i.createElement("title",{id:s},t):null,f)}var b=i.forwardRef(m);t.p;function p(){return(p=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s])}return e}).apply(this,arguments)}function h(e,n){if(null==e)return{};var t,s,i=function(e,n){if(null==e)return{};var t,s,i={},a=Object.keys(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var y=i.createElement("path",{d:"M22.162 5.656a8.384 8.384 0 01-2.402.658A4.196 4.196 0 0021.6 4c-.82.488-1.719.83-2.656 1.015a4.182 4.182 0 00-7.126 3.814 11.874 11.874 0 01-8.62-4.37 4.168 4.168 0 00-.566 2.103c0 1.45.738 2.731 1.86 3.481a4.168 4.168 0 01-1.894-.523v.052a4.185 4.185 0 003.355 4.101 4.21 4.21 0 01-1.89.072A4.185 4.185 0 007.97 16.65a8.394 8.394 0 01-6.191 1.732 11.83 11.83 0 006.41 1.88c7.693 0 11.9-6.373 11.9-11.9 0-.18-.005-.362-.013-.54a8.496 8.496 0 002.087-2.165z"});function g(e,n){var t=e.title,s=e.titleId,a=h(e,["title","titleId"]);return i.createElement("svg",p({fill:"currentColor",viewBox:"0 0 24 24",ref:n,"aria-labelledby":s},a),t?i.createElement("title",{id:s},t):null,y)}var x=i.forwardRef(g);t.p;function j(){return(j=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s])}return e}).apply(this,arguments)}function w(e,n){if(null==e)return{};var t,s,i=function(e,n){if(null==e)return{};var t,s,i={},a=Object.keys(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var v=i.createElement("path",{d:"M21.543 6.498C22 8.28 22 12 22 12s0 3.72-.457 5.502c-.254.985-.997 1.76-1.938 2.022C17.896 20 12 20 12 20s-5.893 0-7.605-.476c-.945-.266-1.687-1.04-1.938-2.022C2 15.72 2 12 2 12s0-3.72.457-5.502c.254-.985.997-1.76 1.938-2.022C6.107 4 12 4 12 4s5.896 0 7.605.476c.945.266 1.687 1.04 1.938 2.022zM10 15.5l6-3.5-6-3.5v7z"});function k(e,n){var t=e.title,s=e.titleId,a=w(e,["title","titleId"]);return i.createElement("svg",j({fill:"currentColor",viewBox:"0 0 24 24",ref:n,"aria-labelledby":s},a),t?i.createElement("title",{id:s},t):null,v)}var O=i.forwardRef(k),_=(t.p,t(141)),T=function(e){return Object(s.jsx)("span",{className:Object(_.a)("self-start w-full p-4 text-xl font-semibold leading-6 text-gray-800",e.className),children:"\ud83d\uddc4 sol2ligo handbook"})},S=function(e){return Object(s.jsx)("a",Object(l.a)(Object(l.a)({className:"pb-1 mx-4 mt-2 transition duration-300 border-b-2 border-transparent hocus:text-gray-300 hocus:border-gray-300"},e),{},{children:e.children}))},N=function(e){return Object(s.jsx)("a",Object(l.a)(Object(l.a)({className:"inline-block mx-4 text-gray-100 transition duration-300 cursor-pointer hover:text-gray-500"},e),{},{children:e.children}))},z=function(){return Object(s.jsx)("div",{className:"max-w-screen-xl py-10 mx-auto lg:py-10",children:Object(s.jsxs)("div",{className:"flex flex-col items-center justify-center px-8",children:[Object(s.jsx)("div",{className:"flex items-center justify-center md:justify-start",children:Object(s.jsx)(T,{})}),Object(s.jsxs)("div",{className:"flex flex-col flex-wrap items-center justify-center font-medium sm:flex-row",children:[Object(s.jsx)(S,{children:"Home"}),Object(s.jsx)(S,{children:"About"}),Object(s.jsx)(S,{children:"Contact Us"}),Object(s.jsx)(S,{children:"Blog"}),Object(s.jsx)(S,{children:"Reviews"})]}),Object(s.jsxs)("div",{className:"",children:[Object(s.jsx)(N,{href:"https://facebook.com",children:Object(s.jsx)(b,{className:"w-5 h-5"})}),Object(s.jsx)(N,{href:"https://twitter.com",children:Object(s.jsx)(x,{className:"w-5 h-5"})}),Object(s.jsx)(N,{href:"https://youtube.com",children:Object(s.jsx)(O,{className:"w-5 h-5"})})]}),Object(s.jsx)("div",{className:"mt-2 text-sm font-medium tracking-wide text-center text-gray-600",children:"\xa9 Copyright 2020, Madfish.Solutions. All Rights Reserved."})]})})},L=t(22),B=[{slug:"contract-structure",title:"Contract structure",description:t(284).default,solidity:t(285).default,ligo:t(286).default},{slug:"functions-function-modifiers",title:"Functions & Function Modifiers",description:t(287).default,solidity:t(288).default,ligo:t(289).default},{slug:"variables-and-constants",title:"Variables and Constants",description:t(290).default,solidity:t(291).default,ligo:t(292).default},{slug:"booleans",title:"Booleans",description:t(293).default,solidity:t(294).default,ligo:t(295).default},{slug:"numbers",title:"Numbers",description:t(296).default,solidity:t(297).default,ligo:t(298).default},{slug:"addresses",title:"Addresses",description:t(299).default,solidity:t(300).default,ligo:t(301).default},{slug:"bytes-and-strings",title:"Bytes and Strings ",description:t(302).default,solidity:t(303).default,ligo:t(304).default},{slug:"enumerations-practice-0",title:"Enumerations + Practice 0",description:t(305).default,solidity:t(306).default,ligo:t(307).default},{slug:"elementary-types-summary",title:"Elementary Types Summary",description:t(308).default,solidity:t(309).default,ligo:t(310).default},{slug:"structures",title:"Structures",description:t(311).default,solidity:t(312).default,ligo:t(313).default},{slug:"mappings",title:"Mappings",description:t(314).default,solidity:t(315).default,ligo:t(316).default},{slug:"array-like-types",title:"Array-like types",description:t(317).default,solidity:t(318).default,ligo:t(319).default},{slug:"tuples-practice-1",title:"Tuples + Practice 1",description:t(320).default,solidity:t(321).default,ligo:t(322).default},{slug:"lists-practice-2",title:"Lists + Practice 2",description:t(323).default,solidity:t(324).default,ligo:t(325).default},{slug:"sets-practice-3",title:"Sets + Practice  3",description:t(326).default,solidity:t(327).default,ligo:t(328).default},{slug:"complex-types-summary",title:"Complex Types Summary",description:t(329).default,solidity:t(330).default,ligo:t(331).default},{slug:"type-aliases-practice-4",title:"Type Aliases + Practice 4",description:t(332).default,solidity:t(333).default,ligo:t(334).default},{slug:"conditions",title:"Conditions",description:t(335).default,solidity:t(336).default,ligo:t(337).default},{slug:"typecasting",title:"Typecasting",description:t(338).default,solidity:t(339).default,ligo:t(340).default},{slug:"loops",title:"Loops",description:t(341).default,solidity:t(342).default,ligo:t(343).default},{slug:"special-variables",title:"Special variables",description:t(344).default,solidity:t(345).default,ligo:t(346).default},{slug:"imports",title:"Imports",description:t(347).default,solidity:t(348).default,ligo:t(349).default},{slug:"functions-visibility-and-modifiers",title:"Functions visibility and modifiers ",description:t(350).default,solidity:t(351).default,ligo:t(352).default}],E=function(e){var n=e.link,t=void 0===n?"#":n,i=e.numeration,a=void 0===i?"1":i,o=e.title,r=e.isActive;return Object(s.jsxs)(c.b,{to:t,className:"group flex flex-row no-wrap w-full truncate max-w-xs py-1 px-4 hover:bg-gray-200",children:[Object(s.jsxs)("div",{className:Object(_.a)("text-lg text-gray-500 group-hover:text-indigo-400 leading-6 w-8 flex-shrink-0",{"text-indigo-400":r}),children:[a,"."]}),Object(s.jsx)("div",{className:Object(_.a)("text-sm text-gray-700 group-hover:text-indigo-600 font-medium leading-6 truncate",{"text-indigo-600 font-bold":r}),children:o})]})},Z=function(e){var n=e.isOpen,t=(e.toggle,e.selectedSection);return Object(s.jsxs)(s.Fragment,{children:[Object(s.jsx)("div",{className:Object(_.a)("fixed z-20 inset-0 bg-yellow transition-opacity lg:hidden",n?"block":"hidden")}),Object(s.jsx)("div",{className:Object(_.a)("fixed z-30 inset-y-0 left-0 w-64 transition duration-300 transform bg-gray-100 overflow-y-auto lg:translate-x-0 lg:static lg:inset-0",n?"translate-x-0 ease-out":"-translate-x-full ease-in"),children:Object(s.jsxs)("div",{className:"flex flex-col items-center justify-center",children:[Object(s.jsx)(T,{className:"w-full border-gray-200"}),Object(s.jsxs)("div",{className:"flex flex-col items-center max-w-full py-4",children:[Object(s.jsx)("div",{className:"self-start flex-shrink-0 pl-4 my-2 text-lg font-bold leading-6 text-gray-700",children:"Contents"}),B.map((function(e,n){return Object(s.jsx)(E,{title:e.title,numeration:"".concat(n+1),isActive:n===t,link:"/section/".concat(n)},e.title)}))]})]})})]})},I=function(e){var n=e.children,t=e.selectedSection,a=void 0===t?0:t,o=e.home,r=void 0!==o&&o,l=Object(i.useState)(!1),d=Object(L.a)(l,2),u=d[0],f=d[1];return Object(s.jsxs)("div",{className:"flex h-screen bg-white-200",children:[!r&&Object(s.jsx)(Z,{selectedSection:a,isOpen:u,toggle:function(){return f(!u)}}),Object(s.jsxs)("div",{className:"flex flex-col flex-1 overflow-hidden",children:[Object(s.jsx)("header",{className:"flex justify-center px-6 py-4 bg-gray-100 border-b-4 border-gray-200",children:Object(s.jsxs)("div",{className:Object(_.a)("flex items-center w-full",r?"max-w-screen-xl px-4 justify-between":"justify-end"),children:[r&&Object(s.jsx)("div",{children:Object(s.jsx)(T,{})}),Object(s.jsxs)("div",{className:"flex text-md justify-self-end",children:[Object(s.jsx)(c.b,{to:"/section/0",className:"mx-5 font-medium text-gray-500 hover:text-gray-900",children:"Get Started"}),Object(s.jsx)("a",{href:"https://github.com/madfish-solutions/sol2ligo",target:"_blank",rel:"noopener noreferrer",className:"mx-5 font-medium text-gray-500 hover:text-gray-900",children:"Github"}),Object(s.jsx)("a",{href:"https://madfish-solutions.github.io/sol2ligo/",target:"_blank",rel:"noopener noreferrer",className:"mx-5 font-medium text-indigo-600 hover:text-gray-900",children:"Try sol2ligo"})]})]})}),Object(s.jsx)("main",{className:"flex flex-1 overflow-hidden bg-gray-200",children:n})]})]})};function A(){return Object(s.jsx)(I,{home:!0,children:Object(s.jsxs)("div",{className:"flex flex-col items-center w-full overflow-y-auto bg-white",children:[Object(s.jsxs)("div",{className:"flex flex-col flex-1 max-w-screen-xl",children:[Object(s.jsxs)("div",{className:"flex items-center justify-center my-10 bg-white lg:flex-row sm:flex-col",children:[Object(s.jsxs)("div",{className:"flex-1 px-4 lg:px-8 sm:text-center lg:text-left",children:[Object(s.jsxs)("h1",{className:"text-4xl font-extrabold tracking-tight text-gray-900 sm:text-5xl md:text-6xl",children:[Object(s.jsx)("span",{className:"block xl:inline",children:"Easy way to learn "}),Object(s.jsx)("span",{className:"block text-indigo-600 xl:inline",children:"Tezos development"})]}),Object(s.jsxs)("p",{className:"mt-3 text-base text-gray-500 sm:mt-5 sm:text-lg sm:max-w-xl sm:mx-auto md:mt-5 md:text-xl lg:mx-0",children:[Object(s.jsx)("b",{children:"Sol2Ligo handbook"})," is the online interactive tool oriented towards Solidity developers willing to migrate their smart-contract development knowledge to Tezos ecosystem"]}),Object(s.jsxs)("div",{className:"mt-5 sm:mt-8 sm:flex sm:justify-center lg:justify-start",children:[Object(s.jsx)("div",{className:"rounded-md shadow",children:Object(s.jsx)("a",{href:"/section/0",className:"flex items-center justify-center w-full px-8 py-3 text-base font-medium text-white bg-indigo-600 border border-transparent rounded-md hover:bg-indigo-700 md:py-4 md:text-lg md:px-10",children:"Get started"})}),Object(s.jsx)("div",{className:"mt-3 sm:mt-0 sm:ml-3",children:Object(s.jsx)("a",{href:"https://madfish-solutions.github.io/sol2ligo/",className:"flex items-center justify-center w-full px-8 py-3 text-base font-medium text-indigo-700 bg-indigo-100 border border-transparent rounded-md hover:bg-indigo-200 md:py-4 md:text-lg md:px-10",children:"Try sol2ligo"})})]})]}),Object(s.jsx)("img",{src:"/person.svg",alt:"Person",className:"flex-1 hidden max-h-75 lg:block"})]}),Object(s.jsx)("div",{className:"py-12 bg-white",children:Object(s.jsxs)("div",{className:"px-4 mx-auto max-w-7xl sm:px-6 lg:px-8",children:[Object(s.jsxs)("div",{className:"lg:text-center",children:[Object(s.jsx)("h2",{className:"text-base font-semibold tracking-wide text-indigo-600 uppercase",children:"sol2ligo handbook"}),Object(s.jsx)("p",{className:"mt-2 text-3xl font-extrabold leading-8 tracking-tight text-gray-900 sm:text-4xl",children:"Interactive way to learn LIGO from scratch"}),Object(s.jsx)("p",{className:"max-w-2xl mt-4 text-xl text-gray-500 lg:mx-auto",children:"Dive into the basics of LIGO language used for building smart-contracts on Tezos while comparing code with Solidity"})]}),Object(s.jsx)("div",{className:"mt-16",children:Object(s.jsxs)("dl",{className:"space-y-10 md:space-y-0 md:grid md:grid-cols-3 md:gap-x-8 md:gap-y-10",children:[Object(s.jsxs)("div",{className:"flex",children:[Object(s.jsx)("div",{className:"flex-shrink-0",children:Object(s.jsx)("div",{className:"flex items-center justify-center w-12 h-12 text-white bg-indigo-500 rounded-md",children:Object(s.jsx)("svg",{className:"w-6 h-6",xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor","aria-hidden":"true",children:Object(s.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"})})})}),Object(s.jsxs)("div",{className:"ml-4",children:[Object(s.jsx)("dt",{className:"text-lg font-medium leading-6 text-gray-900",children:"Integrated transpiler"}),Object(s.jsx)("dd",{className:"mt-2 text-base text-gray-500",children:"Handbook features integrated transpiler allowing everybody to experiment with Solidity and LIGO constructions"})]})]}),Object(s.jsxs)("div",{className:"flex",children:[Object(s.jsx)("div",{className:"flex-shrink-0",children:Object(s.jsx)("div",{className:"flex items-center justify-center w-12 h-12 text-white bg-indigo-500 rounded-md",children:Object(s.jsx)("svg",{className:"w-6 h-6",xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor","aria-hidden":"true",children:Object(s.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M3 6l3 1m0 0l-3 9a5.002 5.002 0 006.001 0M6 7l3 9M6 7l6-2m6 2l3-1m-3 1l-3 9a5.002 5.002 0 006.001 0M18 7l3 9m-3-9l-6-2m0-2v2m0 16V5m0 16H9m3 0h3"})})})}),Object(s.jsxs)("div",{className:"ml-4",children:[Object(s.jsx)("dt",{className:"text-lg font-medium leading-6 text-gray-900",children:"Step-by-step guide"}),Object(s.jsx)("dd",{className:"mt-2 text-base text-gray-500",children:"We tried to describe the major differences between EVM and Tezos-based contracts with examples on each topic"})]})]}),Object(s.jsxs)("div",{className:"flex",children:[Object(s.jsx)("div",{className:"flex-shrink-0",children:Object(s.jsx)("div",{className:"flex items-center justify-center w-12 h-12 text-white bg-indigo-500 rounded-md",children:Object(s.jsx)("svg",{className:"w-6 h-6",xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor","aria-hidden":"true",children:Object(s.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M13 10V3L4 14h7v7l9-11h-7z"})})})}),Object(s.jsxs)("div",{className:"ml-4",children:[Object(s.jsx)("dt",{className:"text-lg font-medium leading-6 text-gray-900",children:"Try your own code"}),Object(s.jsx)("dd",{className:"mt-2 text-base text-gray-500",children:"You can try pasting your own pieces of code into the editor to see result"})]})]})]})})]})})]}),Object(s.jsx)(z,{})]})})}var C,D=t(273),F=t.n(D),M=t(274),P=t.n(M),R=function(e){var n=e.title,t=e.description,i=e.sectionIndex;return Object(s.jsxs)("article",{className:"flex-1 w-full max-w-full px-6 py-4 overflow-y-auto prose break-normal bg-white lg:prose-md",children:[Object(s.jsxs)("h1",{children:[i+1,". ",n]}),Object(s.jsx)(F.a,{skipHtml:!0,source:t,plugins:[[P.a,{singleTilde:!1}]]})]})},U=function(e){var n=e.current,t=e.total;return Object(s.jsxs)("div",{className:"flex justify-center w-full h-12 bg-gray-100",children:[Object(s.jsx)(c.b,{to:"/section/".concat(n?n-1:0),className:"w-full h-full px-4 py-1 font-medium leading-10 text-center text-indigo-600 truncate hover:bg-gray-200",children:"Previous"}),Object(s.jsx)(c.b,{to:"/section/".concat(n<t-1?n+1:n),className:"w-full h-full px-4 py-1 font-medium leading-10 text-center text-indigo-600 truncate border-l-2 border-gray-200 hover:bg-gray-200",children:"Next"})]})},W=t(14),q=t.n(W),V=t(187),G=t(249),H=t(275),X=function(e){return Object(s.jsxs)(H.a,Object(l.a)(Object(l.a)({viewBox:"0 0 340 110"},e),{},{children:[Object(s.jsx)("rect",{x:"0",y:"0",width:"67",height:"11",rx:"3"}),Object(s.jsx)("rect",{x:"76",y:"0",width:"140",height:"11",rx:"3"}),Object(s.jsx)("rect",{x:"127",y:"48",width:"53",height:"11",rx:"3"}),Object(s.jsx)("rect",{x:"187",y:"48",width:"72",height:"11",rx:"3"}),Object(s.jsx)("rect",{x:"18",y:"48",width:"100",height:"11",rx:"3"}),Object(s.jsx)("rect",{x:"0",y:"92",width:"37",height:"11",rx:"3"}),Object(s.jsx)("rect",{x:"18",y:"23",width:"140",height:"11",rx:"3"}),Object(s.jsx)("rect",{x:"166",y:"23",width:"173",height:"11",rx:"3"}),Object(s.jsx)("rect",{x:"0",y:"92",width:"37",height:"11",rx:"3"}),Object(s.jsx)("rect",{x:"18",y:"71",width:"140",height:"11",rx:"3"}),Object(s.jsx)("rect",{x:"166",y:"71",width:"173",height:"11",rx:"3"})]}))},J=t(6),Y=["/solc/soljson-v0.4.26+commit.4563c3fc.js","/solc/soljson-v0.5.11+commit.c082d0b4.js","/solc/sol_wrapper.js","/sol2ligo.js"],K=new Map,Q=document.getElementsByTagName("body")[0],$=function(e){return new Promise((function(n,t){setTimeout((function(){if(K.has(e))return n(K.get(e));var s=document.createElement("script");s.addEventListener("load",(function(){K.set(e,s),n(s)})),s.addEventListener("error",(function(){return t()})),s.type="text/javascript",s.src=e,Q.appendChild(s)}),0)}))},ee=function(){var e=Object(V.a)(q.a.mark((function e(){var n,t,s;return q.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:n=Object(J.a)(Y),e.prev=1,n.s();case 3:if((t=n.n()).done){e.next=9;break}return s=t.value,e.next=7,$(s);case 7:e.next=3;break;case 9:e.next=14;break;case 11:e.prev=11,e.t0=e.catch(1),n.e(e.t0);case 14:return e.prev=14,n.f(),e.finish(14);case 17:case"end":return e.stop()}}),e,null,[[1,11,14,17]])})));return function(){return e.apply(this,arguments)}}();!function(e){e.transpiling="Transpiling...",e.success="Successfully transpiled Solidity to Ligo",e.error="Error occured during transpilation"}(C||(C={}));var ne=function(){return Object(s.jsx)("div",{className:"h-full",children:Object(s.jsx)(X,{foregroundOpacity:.1,backgroundOpacity:.5,className:"px-16 py-12",width:100,style:{width:"100%"}})})},te=function(e){var n=e.ligo,t=e.solidity,a=Object(i.useState)(t),o=Object(L.a)(a,2),r=o[0],c=o[1],l=Object(i.useState)(n),d=Object(L.a)(l,2),u=d[0],f=d[1],m=function(){var e=Object(i.useState)(void 0),n=Object(L.a)(e,2),t=n[0],s=n[1],a=Object(i.useState)(!1),o=Object(L.a)(a,2),r=o[0],c=o[1];return Object(i.useLayoutEffect)((function(){setTimeout(Object(V.a)(q.a.mark((function e(){return q.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.prev=0,e.next=3,ee();case 3:c(!0),e.next=9;break;case 6:e.prev=6,e.t0=e.catch(0),s("Couldn't load transpiler JS files");case 9:case"end":return e.stop()}}),e,null,[[0,6]])}))),100)}),[]),[r,t]}(),b=Object(L.a)(m,2),p=b[0],h=b[1],y=Object(i.useState)(C.success),g=Object(L.a)(y,2),x=g[0],j=g[1];return Object(i.useEffect)((function(){c(t),f(n),j(C.success)}),[n,t]),p?Object(s.jsxs)(s.Fragment,{children:[Object(s.jsx)(G.a,{language:"sol",theme:"vs-dark",value:r,options:{fontSize:14,minimap:{enabled:!1}},onChange:function(){var e=Object(V.a)(q.a.mark((function e(n){var t;return q.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(c(n),j(C.transpiling),!window||!window.compile){e.next=14;break}return e.prev=3,e.next=6,window.compile(n);case 6:t=e.sent,f(t.result),j(C.success),e.next=14;break;case 11:e.prev=11,e.t0=e.catch(3),j(C.error);case 14:case"end":return e.stop()}}),e,null,[[3,11]])})));return function(n){return e.apply(this,arguments)}}(),editorDidMount:function(e,n){return console.log(n)}}),Object(s.jsxs)("div",{className:Object(_.a)("h-10 w-full px-6 font-bold text-white text-center text-sm",{"bg-green-500":x===C.success,"bg-indigo-500":x===C.transpiling,"bg-red-500":x===C.error}),children:["\u2193 ",x]}),Object(s.jsx)(G.a,{language:"pascaligo",theme:"vs-dark",value:u,options:{ariaLabel:"Solidity",fontSize:14,minimap:{enabled:!1}},onChange:function(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];return console.log(n)},editorDidMount:function(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];return console.log(n)}})]}):Object(s.jsxs)(s.Fragment,{children:[Object(s.jsx)(ne,{}),Object(s.jsx)("div",{className:Object(_.a)("h-10 w-full px-6 font-bold text-white text-center text-sm",h?"bg-red-500":"bg-indigo-500"),children:h||Object(s.jsxs)(s.Fragment,{children:["Loading ",Object(s.jsx)("span",{style:{color:"#ffd800"},children:"sol2ligo"})," ","transpiler..."]})}),Object(s.jsx)(ne,{})]})},se=function(e){var n=e.selectedSection,t=B[n];return Object(s.jsxs)(I,{selectedSection:n,children:[Object(s.jsxs)("div",{className:"flex flex-col w-1/2 h-full",children:[Object(s.jsx)(R,{sectionIndex:n,title:t.title,description:t.description}),Object(s.jsx)(U,{current:n,total:B.length})]}),Object(s.jsx)("div",{className:"flex flex-col w-1/2 h-full bg-gray-900 border-l-2 code-pane",children:Object(s.jsx)(te,{ligo:t.ligo,solidity:t.solidity})})]})},ie=c.e.createMap([["/",function(){return Object(s.jsx)(A,{})}],["/section/:id?",function(e){var n=e.id;return"0"===n||n?Object(s.jsx)(se,{selectedSection:Number(n)}):Object(s.jsx)(c.d,{to:"/section/0"})}],["*",function(){return Object(s.jsx)(c.d,{to:"/"})}]]),ae=function(){var e=Object(c.f)(),n=e.trigger,t=e.pathname;return i.useLayoutEffect((function(){n===c.a.Push&&window.scrollTo(0,0)}),[n,t]),i.useMemo((function(){return c.e.resolve(ie,t,null)}),[t])};var oe=function(){return Object(s.jsx)(c.c,{children:Object(s.jsx)(ae,{})})},re=function(e){e&&e instanceof Function&&t.e(73).then(t.bind(null,692)).then((function(n){var t=n.getCLS,s=n.getFID,i=n.getFCP,a=n.getLCP,o=n.getTTFB;t(e),s(e),i(e),a(e),o(e)}))};r.a.render(Object(s.jsx)(a.a.StrictMode,{children:Object(s.jsx)(oe,{})}),document.getElementById("root")),re()}},[[607,3,4]]]);
//# sourceMappingURL=main.fec35b9d.chunk.js.map