/*/common/fy.js*/// Generated by IcedCoffeeScript 108.0.13
(function() {
  var deep_clone, prettyjson, timer, util, v, we_are_in_the_browser, _i, _len, _log10, _log2, _ref,
    __slice = [].slice;

  we_are_in_the_browser = typeof window !== "undefined" && window !== null;

  global = window;

  window.p = console.log.bind(console);

  window.puts = console.log.bind(console);

  window.pe = console.error.bind(console);

  window.perr = console.error.bind(console);

  window.print = function(t) {
    return process.stdout.write((t != null ? t.toString() : void 0) || JSON.stringify(t));
  };

  window.println = console.log;

  timer = null;

  window.tic = function() {
    return timer = new Date;
  };

  window.toc = function() {
    return (new Date - timer) / 1000;
  };

  window.ptoc = function() {
    return console.log(toc().toFixed(3) + ' s');
  };

  global.pp = function(t) {
    return console.log(prettyjson.render(t));
  };

  if (!we_are_in_the_browser) {
    util = require('util');
    global.insp = function(a, depth) {
      if (depth == null) {
        depth = 2;
      }
      return p(util.inspect(a, {
        colors: true,
        depth: depth
      }));
    };
  }

  String.prototype.reverse = function() {
    return this.split('').reverse().join('');
  };

  String.prototype.capitalize = function() {
    return this.substr(0, 1).toUpperCase() + this.substr(1);
  };

  String.prototype.ljust = function(length, char) {
    var append;
    if (char == null) {
      char = ' ';
    }
    append = new Array(Math.max(0, length - this.length) + 1).join(char);
    append = append.substr(0, length - this.length);
    return this + append;
  };

  String.prototype.rjust = function(length, char) {
    var append;
    if (char == null) {
      char = ' ';
    }
    append = new Array(Math.max(0, length - this.length) + 1).join(char);
    append = append.substr(0, length - this.length);
    return append + this;
  };

  String.prototype.center = function(length, char) {
    var append, post, pre, req_length;
    if (char == null) {
      char = ' ';
    }
    req_length = Math.floor((length - this.length + 1) / 2);
    append = new Array(Math.max(0, req_length * 2)).join(char);
    append = append.substr(0, req_length);
    pre = append;
    post = append;
    if ((2 * req_length + this.length) > length) {
      post = post.substr(0, req_length - 1);
    }
    return pre + this + post;
  };

  String.prototype.repeat = function(count) {
    var res;
    res = new Array(count + 1);
    return res.join(this);
  };

  Number.prototype.ljust = function(length, char) {
    if (char == null) {
      char = ' ';
    }
    return this.toString().ljust(length, char);
  };

  Number.prototype.rjust = function(length, char) {
    if (char == null) {
      char = ' ';
    }
    return this.toString().rjust(length, char);
  };

  Number.prototype.center = function(length) {
    return this.toString().center(length);
  };

  Number.prototype.repeat = function(count) {
    return this.toString().repeat(count);
  };

  window.call_later = function(cb) {
    return process.nextTick(cb);
  };

  Array.prototype.has = function(t) {
    return -1 !== this.indexOf(t);
  };

  Array.prototype.upush = function(t) {
    if (-1 === this.indexOf(t)) {
      this.push(t);
    }
  };

  if (Array.isArray == null) {
    Array.isArray = function(obj) {
      return obj instanceof Array;
    };
  }

  Array.prototype.clone = Array.prototype.slice;

  Array.prototype.clear = function() {
    return this.length = 0;
  };

  Array.prototype.idx = Array.prototype.indexOf;

  Array.prototype.remove_idx = function(idx) {
    if (idx < 0 || idx >= this.length) {
      return this;
    }
    this.splice(idx, 1);
    return this;
  };

  Array.prototype.fast_remove = function(t) {
    var idx;
    idx = this.indexOf(t);
    if (idx === -1) {
      return;
    }
    this[idx] = this[this.length - 1];
    this.pop();
    return this;
  };

  Array.prototype.fast_remove_idx = function(idx) {
    if (idx < 0 || idx >= this.length) {
      return this;
    }
    this[idx] = this[this.length - 1];
    this.pop();
    return this;
  };

  Array.prototype.remove = function(t) {
    this.remove_idx(this.idx(t));
    return this;
  };

  Array.prototype.last = Array.prototype.end = function() {
    return this[this.length - 1];
  };

  Array.prototype.insert_after = function(idx, t) {
    this.splice(idx + 1, 0, t);
    return t;
  };

  Array.prototype.append = function(list) {
    var v, _i, _len;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      v = list[_i];
      this.push(v);
    }
    return this;
  };

  Array.prototype.uappend = function(list) {
    var v, _i, _len;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      v = list[_i];
      this.upush(v);
    }
    return this;
  };

  window.h_count = window.count_h = window.hash_count = window.count_hash = function(t) {
    var k, ret;
    ret = 0;
    for (k in t) {
      ret++;
    }
    return ret;
  };

  window.is_object = function(t) {
    return t === Object(t);
  };

  window.obj_set = function(dst, src) {
    var k, v;
    for (k in src) {
      v = src[k];
      dst[k] = v;
    }
    return dst;
  };

  window.obj_clear = function(t) {
    var k, v;
    for (k in t) {
      v = t[k];
      delete t[k];
    }
    return t;
  };

  Array.prototype.set = function(t) {
    var k, v, _i, _len;
    this.length = t.length;
    for (k = _i = 0, _len = t.length; _i < _len; k = ++_i) {
      v = t[k];
      this[k] = v;
    }
    return this;
  };

  window.arr_set = function(dst, src) {
    var k, v, _i, _len;
    dst.length = src.length;
    for (k = _i = 0, _len = src.length; _i < _len; k = ++_i) {
      v = src[k];
      dst[k] = v;
    }
    return dst;
  };

  window.array_merge = window.arr_merge = function() {
    var a, r, _i, _len;
    r = [];
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      a = arguments[_i];
      r = r.concat(a);
    }
    return r;
  };

  window.obj_merge = function() {
    var a, k, ret, v, _i, _len;
    ret = {};
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      a = arguments[_i];
      for (k in a) {
        v = a[k];
        ret[k] = v;
      }
    }
    return ret;
  };

  RegExp.escape = function(text) {
    return text.replace(/[-\/[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  };

  Function.prototype.sbind = function() {
    var athis, main_rest, ret, __this;
    athis = arguments[0], main_rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    __this = this;
    ret = function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return __this.apply(athis, main_rest.concat(rest));
    };
    ret.call = function() {
      var rest, _new_athis;
      _new_athis = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return __this.apply(_new_athis, main_rest.concat(rest));
    };
    ret.apply = function(_new_athis, rest) {
      return __this.apply(_new_athis, main_rest.concat(rest));
    };
    return ret;
  };

  window.clone = function(t) {
    var k, ret, v;
    if (t !== Object(t)) {
      return t;
    }
    if (Array.isArray(t)) {
      return t.slice();
    }
    ret = {};
    for (k in t) {
      v = t[k];
      ret[k] = v;
    }
    return ret;
  };

  window.deep_clone = deep_clone = function(t) {
    var k, res, v, _i, _len;
    if (t !== Object(t)) {
      return t;
    }
    if (Array.isArray(t)) {
      res = [];
      for (_i = 0, _len = t.length; _i < _len; _i++) {
        v = t[_i];
        res.push(deep_clone(v));
      }
      return res;
    }
    res = {};
    for (k in t) {
      v = t[k];
      res[k] = deep_clone(v);
    }
    return res;
  };

  _log2 = Math.log(2);

  _log10 = Math.log(10);

  if (Math.log2 == null) {
    Math.log2 = function(t) {
      return Math.log(t) / _log2;
    };
  }

  if (Math.log10 == null) {
    Math.log10 = function(t) {
      return Math.log(t) / _log10;
    };
  }

  _ref = 'abs min max sqrt log round ceil floor log2 log10'.split(' ');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    v = _ref[_i];
    global[v] = Math[v];
  }

}).call(this);
/*/common/codegen.js*/// Generated by IcedCoffeeScript 108.0.13
(function() {
  global = window;

  global.make_tab = function(target, spacer) {
    return target.replace(/\n/g, "\n" + spacer);
  };

  global.join_list = function(list, spacer) {
    if (spacer == null) {
      spacer = '';
    }
    return make_tab(list.join("\n"), spacer);
  };

}).call(this);
/*/lib/config.js*/(function() {
  var i, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _n, _o, _ref, _ref1, _ref2, _ref3;

  


  /*
  TODO rename
    storage           -> storage_type_str
    contract_storage  -> storage_var_name
   */

  this.storage = "state";

  this.contract_storage = "self";

  this.receiver_name = "receiver";

  this.callback_address = "callbackAddress";

  this.default_address = "tz1ZZZZZZZZZZZZZZZZZZZZZZZZZZZZNkiRg";

  this.burn_address = "tz1ZZZZZZZZZZZZZZZZZZZZZZZZZZZZNkiRg";

  this.empty_state = "reserved__empty_state";

  this.op_list = "opList";

  this.fix_underscore = "fx";

  this.reserved = "res";

  this.router_enum = "router_enum";

  this.int_type_list = ["int"];

  for (i = _i = 8; _i <= 256; i = _i += 8) {
    this.int_type_list.push("int" + i);
  }

  this.uint_type_list = ["uint"];

  for (i = _j = 8; _j <= 256; i = _j += 8) {
    this.uint_type_list.push("uint" + i);
  }

  this.any_int_type_list = [];

  this.any_int_type_list.append(this.int_type_list);

  this.any_int_type_list.append(this.uint_type_list);

  this.bytes_type_list = ["bytes"];

  for (i = _k = 1; _k <= 32; i = ++_k) {
    this.bytes_type_list.push("bytes" + i);
  }

  this.int_type_map = {};

  _ref = this.int_type_list;
  for (_l = 0, _len = _ref.length; _l < _len; _l++) {
    v = _ref[_l];
    this.int_type_map[v] = true;
  }

  this.uint_type_map = {};

  _ref1 = this.uint_type_list;
  for (_m = 0, _len1 = _ref1.length; _m < _len1; _m++) {
    v = _ref1[_m];
    this.uint_type_map[v] = true;
  }

  this.any_int_type_map = {};

  _ref2 = this.any_int_type_list;
  for (_n = 0, _len2 = _ref2.length; _n < _len2; _n++) {
    v = _ref2[_n];
    this.any_int_type_map[v] = true;
  }

  this.bytes_type_map = {};

  _ref3 = this.bytes_type_list;
  for (_o = 0, _len3 = _ref3.length; _o < _len3; _o++) {
    v = _ref3[_o];
    this.bytes_type_map[v] = true;
  }

}).call(window.require_register("./config"));
/*/common/type.js*/// Generated by IcedCoffeeScript 108.0.13
(function() {
  var Type;

  Type = (function() {
    Type.prototype.main = '';

    Type.prototype.nest_list = [];

    Type.prototype.field_map = {};

    function Type(str) {
      var ret, tail, _ref;
      if (!str) {
        this.nest_list = [];
        this.field_map = {};
      } else {
        _ref = this._parse_tail(str), ret = _ref.ret, tail = _ref.tail;
        if (tail) {
          throw new Error("invalid format. Unparsed tail '" + tail + "'");
        }
        this.main = ret.main;
        this.nest_list = ret.nest_list;
        this.field_map = ret.field_map;
      }
    }

    Type.prototype.clone = function() {
      var k, ret, v, _i, _len, _ref, _ref1;
      ret = new Type;
      ret.main = this.main;
      _ref = this.nest_list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        ret.nest_list.push(v.clone());
      }
      _ref1 = this.field_map;
      for (k in _ref1) {
        v = _ref1[k];
        ret.field_map[k] = v.clone();
      }
      return ret;
    };

    Type.prototype.cmp = function(t) {
      var k, tv, v, _i, _len, _ref, _ref1, _ref2;
      if (this.main !== t.main) {
        return false;
      }
      if (this.nest_list.length !== t.nest_list.length) {
        return false;
      }
      _ref = this.nest_list;
      for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
        v = _ref[k];
        if (!t.nest_list[k].cmp(v)) {
          return false;
        }
      }
      _ref1 = this.field_map;
      for (k in _ref1) {
        v = _ref1[k];
        if (!(tv = t.field_map[k])) {
          return false;
        }
        if (!tv.cmp(v)) {
          return false;
        }
      }
      _ref2 = t.field_map;
      for (k in _ref2) {
        v = _ref2[k];
        if (!(tv = this.field_map[k])) {
          return false;
        }
      }
      return true;
    };

    Type.prototype.toString = function() {
      var jl, k, ret, v, _i, _len, _ref, _ref1;
      ret = this.main;
      if (this.nest_list.length) {
        jl = [];
        _ref = this.nest_list;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          jl.push(v.toString());
        }
        ret += "<" + (jl.join(', ')) + ">";
      }
      jl = [];
      _ref1 = this.field_map;
      for (k in _ref1) {
        v = _ref1[k];
        jl.push("" + k + ": " + (v.toString()));
      }
      if (jl.length) {
        ret += "{" + (jl.join(', ')) + "}";
      }
      return ret;
    };

    Type.prototype._parse_tail = function(tail) {
      var full_ret, key, main, reg_ret, ret, _ref, _ref1, _ref2, _ref3, _skip;
      while (tail[0] === " ") {
        tail = tail.substr(1);
      }
      full_ret = new Type;
      if (!(reg_ret = /^([^{}<>,]+)(.*)$/.exec(tail))) {
        throw new Error("invalid format. Type identifier expected '" + tail + "'");
      }
      _skip = reg_ret[0], main = reg_ret[1], tail = reg_ret[2];
      full_ret.main = main;
      if (tail[0] === "<") {
        tail = tail.substr(1);
        while (tail[0] !== '>') {
          if (tail === "") {
            throw new Error("invalid format. Unexpected end of <> group '" + tail + "'");
          }
          _ref = this._parse_tail(tail), ret = _ref.ret, tail = _ref.tail;
          full_ret.nest_list.push(ret);
          _ref1 = /^(?:\s*(?:,\s*)?)(.*)$/.exec(tail), _skip = _ref1[0], tail = _ref1[1];
        }
        tail = tail.substr(1);
      }
      if (tail[0] === "{") {
        tail = tail.substr(1);
        while (tail[0] !== '}') {
          if (tail === "") {
            throw new Error("invalid format. Unexpected end of {} group '" + tail + "'");
          }
          if (!(reg_ret = /^([^:]+):(.*)$/.exec(tail))) {
            throw new Error("invalid format '" + tail + "' missing : in {} group '" + tail + "'");
          }
          _skip = reg_ret[0], key = reg_ret[1], tail = reg_ret[2];
          _ref2 = this._parse_tail(tail), ret = _ref2.ret, tail = _ref2.tail;
          full_ret.field_map[key] = ret;
          _ref3 = /^(?:\s*(?:,\s*)?)(.*)$/.exec(tail), _skip = _ref3[0], tail = _ref3[1];
        }
        tail = tail.substr(1);
      }
      return {
        ret: full_ret,
        tail: tail
      };
    };

    return Type;

  })();

  window.Type = Type;

}).call(this);
/*/lib/type_safe.js*/(function() {
  var Type, null_str;

  Type = window.Type;

  Type.prototype.clone = function() {
    var k, ret, v, _i, _len, _ref, _ref1;
    ret = new Type;
    ret.main = this.main;
    _ref = this.nest_list;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      if (v == null) {
        ret.nest_list.push(v);
      } else {
        ret.nest_list.push(v.clone());
      }
    }
    _ref1 = this.field_map;
    for (k in _ref1) {
      v = _ref1[k];
      if (v == null) {
        ret.field_map[k] = v;
      } else {
        ret.field_map[k] = v.clone();
      }
    }
    return ret;
  };

  null_str = "\x1E";

  Type.prototype.toString = function() {
    var jl, k, ret, v, _i, _len, _ref, _ref1;
    ret = this.main;
    if (this.nest_list.length) {
      jl = [];
      _ref = this.nest_list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        if (v == null) {
          jl.push(null_str);
        } else {
          jl.push(v.toString());
        }
      }
      ret += "<" + (jl.join(', ')) + ">";
    }
    jl = [];
    _ref1 = this.field_map;
    for (k in _ref1) {
      v = _ref1[k];
      if (v == null) {
        jl.push("" + k + ": " + null_str);
      } else {
        jl.push("" + k + ": " + (v.toString()));
      }
    }
    if (jl.length) {
      ret += "{" + (jl.join(', ')) + "}";
    }
    return ret;
  };

  Type.prototype.cmp = function(t) {
    var k, tv, v, _i, _len, _ref, _ref1, _ref2;
    if (this.main !== (t != null ? t.main : void 0)) {
      return false;
    }
    if (this.nest_list.length !== t.nest_list.length) {
      return false;
    }
    _ref = this.nest_list;
    for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
      v = _ref[k];
      tv = t.nest_list[k];
      if (tv === v) {
        continue;
      }
      if (!(tv != null ? tv.cmp(v) : void 0)) {
        return false;
      }
    }
    _ref1 = this.field_map;
    for (k in _ref1) {
      v = _ref1[k];
      if (t.field_map[k] === v) {
        continue;
      }
      if (!t.field_map.hasOwnProperty(k)) {
        return false;
      }
      tv = t.field_map[k];
      if (!(tv != null ? tv.cmp(v) : void 0)) {
        return false;
      }
    }
    _ref2 = t.field_map;
    for (k in _ref2) {
      v = _ref2[k];
      if (!this.field_map.hasOwnProperty(k)) {
        return false;
      }
      tv = this.field_map[k];
    }
    return true;
  };

}).call(window.require_register("./type_safe"));
/*/common/ast4gen.js*/// Generated by IcedCoffeeScript 108.0.12
(function() {
  var  module, str_list, table, type_actualize, type_validate, v, void_type, wrap, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
  
  module = this;

  void_type = new Type("void");

  this.type_actualize = type_actualize = function(t, root) {
    var walk;
    t = t.clone();
    walk = function(_t) {
      var idx, k, reg_ret, v, _i, _len, _ref, _ref1, _skip;
      if (reg_ret = /^_(\d+)$/.exec(_t.main)) {
        _skip = reg_ret[0], idx = reg_ret[1];
        if (!root.nest_list[idx]) {

          /* !pragma coverage-skip-block */
          throw new Error("can't resolve " + _t + " because root type '" + root + "' cas no nest_list[" + idx + "]");
        }
        return root.nest_list[idx].clone();
      }
      _ref = _t.nest_list;
      for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
        v = _ref[k];
        _t.nest_list[k] = walk(v);
      }
      _ref1 = _t.field_hash;
      for (k in _ref1) {
        v = _ref1[k];

        /* !pragma coverage-skip-block */
        _t.field_hash[k] = walk(v);
      }
      return _t;
    };
    return walk(t);
  };

  type_validate = function(t, ctx) {
    var k, v, _i, _len, _ref, _ref1;
    if (!t) {
      throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". type is missing");
    }
    switch (t.main) {
      case "void":
      case "int":
      case "float":
      case "string":
      case "bool":
        if (t.nest_list.length !== 0) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " can't have nest_list");
        }
        if (0 !== h_count(t.field_hash)) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " can't have field_hash");
        }
        break;
      case "array":
      case "hash_int":
        if (t.nest_list.length !== 1) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " must have nest_list 1");
        }
        if (0 !== h_count(t.field_hash)) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " can't have field_hash");
        }
        break;
      case "hash":
        if (t.nest_list.length !== 1) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " must have nest_list 1");
        }
        if (0 !== h_count(t.field_hash)) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " can't have field_hash");
        }
        break;
      case "struct":
        if (t.nest_list.length !== 0) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " must have nest_list 0");
        }
        break;
      case "function":
        if (t.nest_list.length === 0) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " must have at least nest_list 1 (ret type)");
        }
        if (0 !== h_count(t.field_hash)) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " can't have field_hash");
        }
        "";
        break;
      default:
        if (!ctx.check_type(t.main)) {
          throw new Error("unknown type '" + t + "'");
        }
    }
    _ref = t.nest_list;
    for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
      v = _ref[k];
      type_validate(v, ctx);
    }
    _ref1 = t.field_hash;
    for (k in _ref1) {
      v = _ref1[k];
      type_validate(v, ctx);
    }
  };

  wrap = function(_prepared_field2type) {
    var ret;
    ret = new module.Class_decl;
    ret._prepared_field2type = _prepared_field2type;
    return ret;
  };

  this.default_var_hash_gen = function() {
    var ret;
    return ret = {
      "true": new Type("bool"),
      "false": new Type("bool")
    };
  };

  this.default_type_hash_gen = function() {
    var ret;
    return ret = {
      "array": wrap({
        remove_idx: new Type("function<void, int>"),
        length_get: new Type("function<int>"),
        length_set: new Type("function<void, int>"),
        pop: new Type("function<_0>"),
        push: new Type("function<void,_0>"),
        slice: new Type("function<array<_0>,int,int>"),
        remove: new Type("function<void,_0>"),
        idx: new Type("function<int,_0>"),
        has: new Type("function<bool,_0>"),
        append: new Type("function<void,array<_0>>"),
        clone: new Type("function<array<_0>>"),
        sort_i: new Type("function<void,function<int,_0,_0>>"),
        sort_f: new Type("function<void,function<float,_0,_0>>"),
        sort_by_i: new Type("function<void,function<int,_0>>"),
        sort_by_f: new Type("function<void,function<float,_0>>"),
        sort_by_s: new Type("function<void,function<string,_0>>")
      }),
      "hash_int": wrap({
        add: new Type("function<void,int,_0>"),
        remove_idx: new Type("function<void,int>"),
        idx: new Type("function<_0,int>")
      })
    };
  };

  this.Validation_context = (function() {
    Validation_context.prototype.parent = null;

    Validation_context.prototype.executable = false;

    Validation_context.prototype.breakable = false;

    Validation_context.prototype.returnable = false;

    Validation_context.prototype.type_hash = {};

    Validation_context.prototype.var_hash = {};

    Validation_context.prototype.line = 0;

    Validation_context.prototype.pos = 0;

    function Validation_context() {
      this.type_hash = module.default_type_hash_gen();
      this.var_hash = module.default_var_hash_gen();
    }

    Validation_context.prototype.seek_non_executable_parent = function() {
      if (this.executable) {
        return this.parent.seek_non_executable_parent();
      } else {
        return this;
      }
    };

    Validation_context.prototype.mk_nest = function(pass_breakable) {
      var ret;
      ret = new module.Validation_context;
      ret.parent = this;
      ret.returnable = this.returnable;
      ret.executable = this.executable;
      if (pass_breakable) {
        ret.breakable = this.breakable;
      }
      return ret;
    };

    Validation_context.prototype.check_type = function(id) {
      var found;
      if (found = this.type_hash[id]) {
        return found;
      }
      if (this.parent) {
        return this.parent.check_type(id);
      }
      return null;
    };

    Validation_context.prototype.check_id = function(id) {
      var found;
      if (found = this.var_hash[id]) {
        return found;
      }
      if (this.parent) {
        return this.parent.check_id(id);
      }
      return null;
    };

    Validation_context.prototype.check_id_decl = function(id) {
      return this.var_hash[id];
    };

    return Validation_context;

  })();

  this.Const = (function() {
    function Const() {}

    Const.prototype.val = "";

    Const.prototype.type = null;

    Const.prototype.line = 0;

    Const.prototype.pos = 0;

    Const.prototype.validate = function(ctx) {
      var val, _ref;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      type_validate(this.type, ctx);
      switch (this.type.main) {
        case "bool":
          if ((_ref = this.val) !== "true" && _ref !== "false") {
            throw new Error("Const validation error line=" + this.line + " pos=" + this.pos + ". '" + this.val + "' can't be bool");
          }
          break;
        case "int":
          if (parseInt(this.val).toString() !== this.val) {
            throw new Error("Const validation error line=" + this.line + " pos=" + this.pos + ". '" + this.val + "' can't be int");
          }
          break;
        case "float":
          val = this.val;
          val = val.replace(/\.0+$/, "");
          val = val.replace(/e(\d)/i, "e+$1");
          if (parseFloat(val).toString() !== val) {
            throw new Error("Const validation error line=" + this.line + " pos=" + this.pos + ". '" + this.val + "' can't be float");
          }
          break;
        case "string":
          "nothing";
          break;
        default:
          throw new Error("can't implement constant type '" + this.type + "'");
      }
    };

    Const.prototype.clone = function() {
      var ret;
      ret = new module.Const;
      ret.val = this.val;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Const;

  })();

  this.Array_init = (function() {
    Array_init.prototype.list = [];

    Array_init.prototype.type = null;

    Array_init.prototype.line = 0;

    Array_init.prototype.pos = 0;

    function Array_init() {
      this.list = [];
    }

    Array_init.prototype.validate = function(ctx) {
      var cmp_type, k, v, _i, _len, _ref;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      type_validate(this.type, ctx);
      if (this.type.main !== "array") {
        throw new Error("Array_init validation error line=" + this.line + " pos=" + this.pos + ". type must be array but '" + this.type + "' found");
      }
      cmp_type = this.type.nest_list[0];
      _ref = this.list;
      for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
        v = _ref[k];
        v.validate(ctx);
        if (!v.type.cmp(cmp_type)) {
          throw new Error("Array_init validation error line=" + this.line + " pos=" + this.pos + ". key '" + k + "' must be type '" + cmp_type + "' but '" + v.type + "' found");
        }
      }
    };

    Array_init.prototype.clone = function() {
      var ret, v, _i, _len, _ref;
      ret = new module.Array_init;
      _ref = this.list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        ret.list.push(v.clone());
      }
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Array_init;

  })();

  this.Hash_init = (function() {
    Hash_init.prototype.hash = {};

    Hash_init.prototype.type = null;

    Hash_init.prototype.line = 0;

    Hash_init.prototype.pos = 0;

    function Hash_init() {
      this.hash = {};
    }

    Hash_init.prototype.validate = function(ctx) {
      var cmp_type, k, v, _ref, _ref1;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      type_validate(this.type, ctx);
      if (this.type.main !== "hash") {
        throw new Error("Hash_init validation error line=" + this.line + " pos=" + this.pos + ". type must be hash but '" + this.type + "' found");
      }
      _ref = this.hash;
      for (k in _ref) {
        v = _ref[k];
        v.validate(ctx);
      }
      cmp_type = this.type.nest_list[0];
      _ref1 = this.hash;
      for (k in _ref1) {
        v = _ref1[k];
        if (!v.type.cmp(cmp_type)) {
          throw new Error("Hash_init validation error line=" + this.line + " pos=" + this.pos + ". key '" + k + "' must be type '" + cmp_type + "' but '" + v.type + "' found");
        }
      }
    };

    Hash_init.prototype.clone = function() {
      var k, ret, v, _ref;
      ret = new module.Hash_init;
      _ref = this.hash;
      for (k in _ref) {
        v = _ref[k];
        ret.hash[k] = v.clone();
      }
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Hash_init;

  })();

  this.Struct_init = (function() {
    Struct_init.prototype.hash = {};

    Struct_init.prototype.type = null;

    Struct_init.prototype.line = 0;

    Struct_init.prototype.pos = 0;

    function Struct_init() {
      this.hash = {};
    }

    Struct_init.prototype.validate = function(ctx) {
      var cmp_type, k, v, _ref;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      type_validate(this.type, ctx);
      if (this.type.main !== "struct") {
        throw new Error("Struct_init validation error line=" + this.line + " pos=" + this.pos + ". type must be struct but '" + this.type + "' found");
      }
      _ref = this.hash;
      for (k in _ref) {
        v = _ref[k];
        v.validate(ctx);
        if (!v.type.cmp(cmp_type = this.type.field_hash[k])) {
          throw new Error("Struct_init validation error line=" + this.line + " pos=" + this.pos + ". key '" + k + "' must be type '" + cmp_type + "' but '" + v.type + "' found");
        }
      }
    };

    Struct_init.prototype.clone = function() {
      var k, ret, v, _ref;
      ret = new module.Struct_init;
      _ref = this.hash;
      for (k in _ref) {
        v = _ref[k];
        ret.hash[k] = v.clone();
      }
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Struct_init;

  })();

  this.Var = (function() {
    function Var() {}

    Var.prototype.name = "";

    Var.prototype.type = null;

    Var.prototype.line = 0;

    Var.prototype.pos = 0;

    Var.prototype.validate = function(ctx) {
      var type, var_decl;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!/^[_a-z][_a-z0-9]*$/i.test(this.name)) {
        throw new Error("Var validation error line=" + this.line + " pos=" + this.pos + ". invalid identifier '" + this.name + "'");
      }
      type_validate(this.type, ctx);
      var_decl = ctx.check_id(this.name);
      if (!var_decl) {
        throw new Error("Var validation error line=" + this.line + " pos=" + this.pos + ". Id '" + this.name + "' not defined");
      }
      type = var_decl.type;
      if (!this.type.cmp(type)) {
        throw new Error("Var validation error line=" + this.line + " pos=" + this.pos + ". Var type !+ Var_decl type '" + this.type + "' != " + type);
      }
    };

    Var.prototype.clone = function() {
      var ret;
      ret = new module.Var;
      ret.name = this.name;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Var;

  })();

  this.allowed_bin_op_hash = {
    ADD: true,
    SUB: true,
    MUL: true,
    DIV: true,
    DIV_INT: true,
    MOD: true,
    POW: true,
    BIT_AND: true,
    BIT_OR: true,
    BIT_XOR: true,
    BOOL_AND: true,
    BOOL_OR: true,
    BOOL_XOR: true,
    SHR: true,
    SHL: true,
    LSR: true,
    ASSIGN: true,
    ASS_ADD: true,
    ASS_SUB: true,
    ASS_MUL: true,
    ASS_DIV: true,
    ASS_DIV_INT: true,
    ASS_MOD: true,
    ASS_POW: true,
    ASS_SHR: true,
    ASS_SHL: true,
    ASS_LSR: true,
    ASS_BIT_AND: true,
    ASS_BIT_OR: true,
    ASS_BIT_XOR: true,
    ASS_BOOL_AND: true,
    ASS_BOOL_OR: true,
    ASS_BOOL_XOR: true,
    EQ: true,
    NE: true,
    GT: true,
    LT: true,
    GTE: true,
    LTE: true,
    INDEX_ACCESS: true
  };

  this.assign_bin_op_hash = {
    ASSIGN: true,
    ASS_ADD: true,
    ASS_SUB: true,
    ASS_MUL: true,
    ASS_DIV: true,
    ASS_MOD: true,
    ASS_POW: true,
    ASS_SHR: true,
    ASS_SHL: true,
    ASS_LSR: true,
    ASS_BIT_AND: true,
    ASS_BIT_OR: true,
    ASS_BIT_XOR: true,
    ASS_BOOL_AND: true,
    ASS_BOOL_OR: true,
    ASS_BOOL_XOR: true
  };

  this.bin_op_ret_type_hash_list = {
    DIV: [["int", "int", "float"], ["int", "float", "float"], ["float", "int", "float"], ["float", "float", "float"]],
    DIV_INT: [["int", "int", "int"], ["int", "float", "int"], ["float", "int", "int"], ["float", "float", "int"]]
  };

  _ref = "ADD SUB MUL POW".split(/\s+/g);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    v = _ref[_i];
    this.bin_op_ret_type_hash_list[v] = [["int", "int", "int"], ["int", "float", "float"], ["float", "int", "float"], ["float", "float", "float"]];
  }

  _ref1 = "MOD BIT_AND BIT_OR BIT_XOR SHR SHL LSR".split(/\s+/g);
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    v = _ref1[_j];
    this.bin_op_ret_type_hash_list[v] = [["int", "int", "int"]];
  }

  _ref2 = "BOOL_AND BOOL_OR BOOL_XOR".split(/\s+/g);
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    v = _ref2[_k];
    this.bin_op_ret_type_hash_list[v] = [["bool", "bool", "bool"]];
  }

  this.bin_op_ret_type_hash_list.ADD.push(["string", "string", "string"]);

  this.bin_op_ret_type_hash_list.MUL.push(["string", "int", "string"]);

  _ref3 = "ASSIGN".split(/\s+/g);
  for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
    v = _ref3[_l];
    this.bin_op_ret_type_hash_list[v] = [["int", "int", "int"], ["bool", "bool", "bool"], ["float", "float", "float"], ["string", "string", "string"]];
  }

  _ref4 = "EQ NE GT LT GTE LTE".split(/\s+/g);
  for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
    v = _ref4[_m];
    this.bin_op_ret_type_hash_list[v] = [["int", "int", "bool"], ["float", "float", "bool"], ["string", "string", "bool"]];
  }

  str_list = "ADD\nSUB\nMUL\nDIV\nDIV_INT\nMOD\nPOW\n\nSHR\nSHL\nLSR\n\nBIT_AND \nBIT_OR  \nBIT_XOR \n\nBOOL_AND\nBOOL_OR \nBOOL_XOR";

  _ref5 = str_list.split(/\s+/g);
  for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
    v = _ref5[_n];
    table = this.bin_op_ret_type_hash_list[v];
    table = table.filter(function(row) {
      return row[0] === row[2];
    });
    table = table.map(function(t) {
      return t.clone();
    });
    this.bin_op_ret_type_hash_list["ASS_" + v] = table;
  }

  this.Bin_op = (function() {
    function Bin_op() {}

    Bin_op.prototype.a = null;

    Bin_op.prototype.b = null;

    Bin_op.prototype.op = null;

    Bin_op.prototype.type = null;

    Bin_op.prototype.line = 0;

    Bin_op.prototype.pos = 0;

    Bin_op.prototype.validate = function(ctx) {
      var found, list, _len6, _o, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.a) {
        throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". a missing");
      }
      this.a.validate(ctx);
      if (!this.b) {
        throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". b missing");
      }
      this.b.validate(ctx);
      type_validate(this.type, ctx);
      if (!module.allowed_bin_op_hash[this.op]) {
        throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". Invalid op '" + this.op + "'");
      }
      found = false;
      if (list = module.bin_op_ret_type_hash_list[this.op]) {
        for (_o = 0, _len6 = list.length; _o < _len6; _o++) {
          v = list[_o];
          if (v[0] !== this.a.type.toString()) {
            continue;
          }
          if (v[1] !== this.b.type.toString()) {
            continue;
          }
          found = true;
          if (v[2] !== this.type.toString()) {
            throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " with types " + this.a.type + " " + this.b.type + " should produce type " + v[2] + " but " + this.type + " found");
          }
          break;
        }
      }
      if (!found) {
        if (this.op === "ASSIGN") {
          if (this.a.type.cmp(this.b.type)) {
            if (this.a.type.cmp(this.type)) {
              found = true;
            } else {
              throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". " + this.op + " a=b=[" + this.a.type + "] must have return type '" + this.a.type + "'");
            }
          }
        } else if ((_ref6 = this.op) === "EQ" || _ref6 === "NE") {
          if (this.a.type.cmp(this.b.type)) {
            if (this.type.main === "bool") {
              found = true;
            } else {
              throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". " + this.op + " a=b=[" + this.a.type + "] must have return type bool");
            }
          }
        } else if (this.op === "INDEX_ACCESS") {
          switch (this.a.type.main) {
            case "string":
              if (this.b.type.main === "int") {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be int");
              }
              if (this.type.main === "string") {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be string");
              }
              break;
            case "array":
              if (this.b.type.main === "int") {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be int");
              }
              if (this.type.cmp(this.a.type.nest_list[0])) {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be " + this.a.type.nest_list[0] + " but " + this.type + " found");
              }
              break;
            case "hash":
              if (this.b.type.main === "string") {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be string");
              }
              if (this.type.cmp(this.a.type.nest_list[0])) {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be " + this.a.type.nest_list[0] + " but " + this.type + " found");
              }
              break;
            case "hash_int":
              if (this.b.type.main === "int") {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be int");
              }
              if (this.type.cmp(this.a.type.nest_list[0])) {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be " + this.a.type.nest_list[0] + " but " + this.type + " found");
              }
              break;
            default:
              throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". Can't apply bin_op=" + this.op + " to " + this.a.type + " " + this.b.type);
          }
        }
      }
      if (!found) {
        throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". Can't apply bin_op=" + this.op + " to " + this.a.type + " " + this.b.type);
      }
    };

    Bin_op.prototype.clone = function() {
      var ret;
      ret = new module.Bin_op;
      ret.a = this.a.clone();
      ret.b = this.b.clone();
      ret.op = this.op;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Bin_op;

  })();

  this.allowed_un_op_hash = {
    INC_RET: true,
    RET_INC: true,
    DEC_RET: true,
    RET_DEC: true,
    BOOL_NOT: true,
    BIT_NOT: true,
    MINUS: true,
    PLUS: true,
    IS_NOT_NULL: true
  };

  this.un_op_ret_type_hash_list = {
    INC_RET: [["int", "int"]],
    RET_INC: [["int", "int"]],
    DEC_RET: [["int", "int"]],
    RET_DEC: [["int", "int"]],
    BOOL_NOT: [["bool", "bool"]],
    BIT_NOT: [["int", "int"]],
    MINUS: [["int", "int"], ["float", "float"]],
    PLUS: [["string", "float"]]
  };

  this.Un_op = (function() {
    function Un_op() {}

    Un_op.prototype.a = null;

    Un_op.prototype.op = null;

    Un_op.prototype.type = null;

    Un_op.prototype.line = 0;

    Un_op.prototype.pos = 0;

    Un_op.prototype.validate = function(ctx) {
      var found, list, _len6, _o;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.a) {
        throw new Error("Un_op validation error line=" + this.line + " pos=" + this.pos + ". a missing");
      }
      this.a.validate(ctx);
      type_validate(this.type, ctx);
      if (!module.allowed_un_op_hash[this.op]) {
        throw new Error("Un_op validation error line=" + this.line + " pos=" + this.pos + ". Invalid op '" + this.op + "'");
      }
      list = module.un_op_ret_type_hash_list[this.op];
      found = false;
      if (list) {
        for (_o = 0, _len6 = list.length; _o < _len6; _o++) {
          v = list[_o];
          if (v[0] !== this.a.type.toString()) {
            continue;
          }
          found = true;
          if (v[1] !== this.type.toString()) {
            throw new Error("Un_op validation error line=" + this.line + " pos=" + this.pos + ". un_op=" + this.op + " with type " + this.a.type + " should produce type " + v[1] + " but " + this.type + " found");
          }
          break;
        }
      }
      if (this.op === "IS_NOT_NULL") {
        if (this.type.main !== "bool") {
          throw new Error("Un_op validation error line=" + this.line + " pos=" + this.pos + ". un_op=" + this.op + " with type " + this.a.type + " should produce type bool but " + this.type + " found");
        }
        found = true;
      }
      if (!found) {
        throw new Error("Un_op validation error line=" + this.line + " pos=" + this.pos + ". Can't apply un_op=" + this.op + " to " + this.a.type);
      }
    };

    Un_op.prototype.clone = function() {
      var ret;
      ret = new module.Un_op;
      ret.a = this.a.clone();
      ret.op = this.op;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Un_op;

  })();

  this.Field_access = (function() {
    function Field_access() {}

    Field_access.prototype.t = null;

    Field_access.prototype.name = "";

    Field_access.prototype.type = null;

    Field_access.prototype.line = 0;

    Field_access.prototype.pos = 0;

    Field_access.prototype.validate = function(ctx) {
      var class_decl, nest_type, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.t) {
        throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Missing target");
      }
      this.t.validate(ctx);
      if (!this.name) {
        throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Missing name");
      }
      type_validate(this.type, ctx);
      if (this.name === "new") {
        if ((_ref6 = this.t.type.main) === "bool" || _ref6 === "int" || _ref6 === "float" || _ref6 === "string") {
          throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Access to missing field '" + this.name + "' in '" + this.t.type + "'.");
        }
        nest_type = new Type("function");
        nest_type.nest_list[0] = this.t.type;
      } else if (this.t.type.main === "struct") {
        if (!(nest_type = this.t.type.field_hash[this.name])) {
          throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Access to missing field '" + this.name + "' in '" + this.t.type + "'. Possible keys [" + (Object.keys(this.t.type.field_hash).join(', ')) + "]");
        }
      } else {
        class_decl = ctx.check_type(this.t.type.main);
        if (!(nest_type = class_decl._prepared_field2type[this.name])) {
          throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Access to missing class field '" + this.name + "' in '" + this.t.type + "'. Possible keys [" + (Object.keys(class_decl._prepared_field2type).join(', ')) + "]");
        }
      }
      nest_type = type_actualize(nest_type, this.t.type);
      if (!this.type.cmp(nest_type)) {
        throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Access to field '" + this.name + "' with type '" + nest_type + "' but result '" + this.type + "'");
      }
    };

    Field_access.prototype.clone = function() {
      var ret;
      ret = new module.Field_access;
      ret.t = this.t.clone();
      ret.name = this.name;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Field_access;

  })();

  this.Fn_call = (function() {
    Fn_call.prototype.fn = null;

    Fn_call.prototype.arg_list = [];

    Fn_call.prototype.splat_fin = false;

    Fn_call.prototype.type = null;

    Fn_call.prototype.line = 0;

    Fn_call.prototype.pos = 0;

    function Fn_call() {
      this.arg_list = [];
    }

    Fn_call.prototype.validate = function(ctx) {
      var arg, k, _len6, _o, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.fn) {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". fn missing");
      }
      this.fn.validate(ctx);
      if (this.fn.type.main !== "function") {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". Can't call type '@fn.type'. You can call only function");
      }
      if (!this.type.cmp(void_type)) {
        type_validate(this.type, ctx);
      }
      if (!this.type.cmp(this.fn.type.nest_list[0])) {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". Return type and function decl return type doesn't match " + this.fn.type.nest_list[0] + " != " + this.type);
      }
      if (this.fn.type.nest_list.length - 1 !== this.arg_list.length) {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". Expected arg count=" + (this.fn.type.nest_list.length - 1) + " found=" + this.arg_list.length);
      }
      _ref6 = this.arg_list;
      for (k = _o = 0, _len6 = _ref6.length; _o < _len6; k = ++_o) {
        arg = _ref6[k];
        arg.validate(ctx);
        if (!this.fn.type.nest_list[k + 1].cmp(arg.type)) {
          throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". arg[" + k + "] type mismatch. Expected=" + this.fn.type.nest_list[k + 1] + " found=" + arg.type);
        }
      }
    };

    Fn_call.prototype.clone = function() {
      var ret, _len6, _o, _ref6;
      ret = new module.Fn_call;
      ret.fn = this.fn.clone();
      _ref6 = this.arg_list;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        v = _ref6[_o];
        ret.arg_list.push(v.clone());
      }
      ret.splat_fin = this.splat_fin;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Fn_call;

  })();

  this.Scope = (function() {
    Scope.prototype.list = [];

    Scope.prototype.need_nest = true;

    Scope.prototype.line = 0;

    Scope.prototype.pos = 0;

    function Scope() {
      this.list = [];
    }

    Scope.prototype.validate = function(ctx) {
      var ctx_nest, stmt, _len6, _len7, _o, _p, _ref6, _ref7;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (this.need_nest) {
        ctx_nest = ctx.mk_nest(true);
      } else {
        ctx_nest = ctx;
      }
      _ref6 = this.list;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        stmt = _ref6[_o];
        if (typeof stmt.register === "function") {
          stmt.register(ctx_nest);
        }
      }
      _ref7 = this.list;
      for (_p = 0, _len7 = _ref7.length; _p < _len7; _p++) {
        stmt = _ref7[_p];
        stmt.validate(ctx_nest);
      }
    };

    Scope.prototype.clone = function() {
      var ret, _len6, _o, _ref6;
      ret = new module.Scope;
      _ref6 = this.list;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        v = _ref6[_o];
        ret.list.push(v.clone());
      }
      ret.need_nest = this.need_nest;
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Scope;

  })();

  this.If = (function() {
    If.prototype.cond = null;

    If.prototype.t = null;

    If.prototype.f = null;

    If.prototype.line = 0;

    If.prototype.pos = 0;

    function If() {
      this.t = new module.Scope;
      this.f = new module.Scope;
    }

    If.prototype.validate = function(ctx) {
      var _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.cond) {
        throw new Error("If validation error line=" + this.line + " pos=" + this.pos + ". cond missing");
      }
      this.cond.validate(ctx);
      if ((_ref6 = this.cond.type.main) !== "bool" && _ref6 !== "int") {
        throw new Error("If validation error line=" + this.line + " pos=" + this.pos + ". cond must be bool or int but found '" + this.cond.type + "'");
      }
      this.t.validate(ctx);
      this.f.validate(ctx);
      if (this.t.list.length === 0) {
        perr("Warning. If empty true body");
      }
      if (this.t.list.length === 0 && this.f.list.length === 0) {
        throw new Error("If validation error line=" + this.line + " pos=" + this.pos + ". Empty true and false sections");
      }
    };

    If.prototype.clone = function() {
      var ret;
      ret = new module.If;
      ret.cond = this.cond.clone();
      ret.t = this.t.clone();
      ret.f = this.f.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return If;

  })();

  this.Switch = (function() {
    Switch.prototype.cond = null;

    Switch.prototype.hash = {};

    Switch.prototype.f = null;

    Switch.prototype.line = 0;

    Switch.prototype.pos = 0;

    function Switch() {
      this.hash = {};
      this.f = new module.Scope;
    }

    Switch.prototype.validate = function(ctx) {
      var k, _ref6, _ref7, _ref8;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.cond) {
        throw new Error("Switch validation error line=" + this.line + " pos=" + this.pos + ". cond missing");
      }
      this.cond.validate(ctx);
      if (0 === h_count(this.hash)) {
        throw new Error("Switch validation error line=" + this.line + " pos=" + this.pos + ". no when conditions found");
      }
      switch (this.cond.type.main) {
        case "int":
          _ref6 = this.hash;
          for (k in _ref6) {
            v = _ref6[k];
            if (parseInt(k).toString() !== k || !isFinite(k)) {
              throw new Error("Switch validation error line=" + this.line + " pos=" + this.pos + ". key '" + k + "' can't be int");
            }
          }
          break;
        case "string":
          "nothing";
          break;
        default:
          throw new Error("Switch validation error line=" + this.line + " pos=" + this.pos + ". Can't implement switch for condition type '" + this.cond.type + "'");
      }
      _ref7 = this.hash;
      for (k in _ref7) {
        v = _ref7[k];
        v.validate(ctx.mk_nest());
      }
      if ((_ref8 = this.f) != null) {
        _ref8.validate(ctx);
      }
    };

    Switch.prototype.clone = function() {
      var k, ret, _ref6;
      ret = new module.Switch;
      ret.cond = this.cond.clone();
      _ref6 = this.hash;
      for (k in _ref6) {
        v = _ref6[k];
        ret.hash[k] = v.clone();
      }
      ret.f = this.f.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Switch;

  })();

  this.Loop = (function() {
    Loop.prototype.scope = null;

    Loop.prototype.line = 0;

    Loop.prototype.pos = 0;

    function Loop() {
      this.scope = new module.Scope;
    }

    Loop.prototype.validate = function(ctx) {
      var ctx_nest, found, walk;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      ctx_nest = ctx.mk_nest();
      ctx_nest.breakable = true;
      this.scope.validate(ctx_nest);
      found = false;
      walk = function(t) {
        var _len6, _o, _ref6;
        switch (t.constructor.name) {
          case "Scope":
            _ref6 = t.list;
            for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
              v = _ref6[_o];
              walk(v);
            }
            break;
          case "If":
            walk(t.t);
            walk(t.f);
            break;
          case "Break":
          case "Ret":
            found = true;
        }
      };
      walk(this.scope);
      if (!found) {
        throw new Error("Loop validation error line=" + this.line + " pos=" + this.pos + ". Break or Ret not found");
      }
    };

    Loop.prototype.clone = function() {
      var ret;
      ret = new module.Loop;
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Loop;

  })();

  this.Break = (function() {
    Break.prototype.line = 0;

    Break.prototype.pos = 0;

    function Break() {}

    Break.prototype.validate = function(ctx) {
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!ctx.breakable) {
        throw new Error("Break validation error line=" + this.line + " pos=" + this.pos + ". You can't use break outside loop, while");
      }
    };

    Break.prototype.clone = function() {
      var ret;
      ret = new module.Break;
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Break;

  })();

  this.Continue = (function() {
    Continue.prototype.line = 0;

    Continue.prototype.pos = 0;

    function Continue() {}

    Continue.prototype.validate = function(ctx) {
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!ctx.breakable) {
        throw new Error("Continue validation error line=" + this.line + " pos=" + this.pos + ". You can't use continue outside loop, while");
      }
    };

    Continue.prototype.clone = function() {
      var ret;
      ret = new module.Continue;
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Continue;

  })();

  this.While = (function() {
    While.prototype.cond = null;

    While.prototype.scope = null;

    While.prototype.line = 0;

    While.prototype.pos = 0;

    function While() {
      this.scope = new module.Scope;
    }

    While.prototype.validate = function(ctx) {
      var ctx_nest, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.cond) {
        throw new Error("While validation error line=" + this.line + " pos=" + this.pos + ". cond missing");
      }
      this.cond.validate(ctx);
      if ((_ref6 = this.cond.type.main) !== "bool" && _ref6 !== "int") {
        throw new Error("While validation error line=" + this.line + " pos=" + this.pos + ". cond must be bool or int");
      }
      ctx_nest = ctx.mk_nest();
      ctx_nest.breakable = true;
      this.scope.validate(ctx_nest);
      if (this.scope.list.length === 0) {
        throw new Error("While validation error line=" + this.line + " pos=" + this.pos + ". Empty while is not allowed");
      }
    };

    While.prototype.clone = function() {
      var ret;
      ret = new module.While;
      ret.cond = this.cond.clone();
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return While;

  })();

  this.For_range = (function() {
    For_range.prototype.exclusive = true;

    For_range.prototype.i = null;

    For_range.prototype.a = null;

    For_range.prototype.b = null;

    For_range.prototype.step = null;

    For_range.prototype.scope = null;

    For_range.prototype.line = 0;

    For_range.prototype.pos = 0;

    function For_range() {
      this.scope = new module.Scope;
    }

    For_range.prototype.validate = function(ctx) {
      var ctx_nest, _ref10, _ref6, _ref7, _ref8, _ref9;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.i) {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Iterator is missing");
      }
      if (!this.a) {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range a is missing");
      }
      if (!this.b) {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range b is missing");
      }
      this.i.validate(ctx);
      this.a.validate(ctx);
      this.b.validate(ctx);
      if ((_ref6 = this.step) != null) {
        _ref6.validate(ctx);
      }
      if ((_ref7 = this.i.type.main) !== "int" && _ref7 !== "float") {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Iterator should be type int or float but '" + this.i.type + "' found");
      }
      if ((_ref8 = this.a.type.main) !== "int" && _ref8 !== "float") {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range a should be type int or float but '" + this.a.type + "' found");
      }
      if ((_ref9 = this.b.type.main) !== "int" && _ref9 !== "float") {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range b should be type int or float but '" + this.b.type + "' found");
      }
      if (this.step) {
        if ((_ref10 = this.step.type.main) !== "int" && _ref10 !== "float") {
          throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Step should be type int or float but '" + this.step.type + "' found");
        }
      }
      if (this.i.type.main === "int") {
        if (this.a.type.main !== "int") {
          throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range a should be type int because iterator is int but '" + this.a.type + "' found");
        }
        if (this.b.type.main !== "int") {
          throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range b should be type int because iterator is int but '" + this.b.type + "' found");
        }
        if (this.step) {
          if (this.step.type.main !== "int") {
            throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Step should be type int because iterator is int but '" + this.step.type + "' found");
          }
        }
      }
      ctx_nest = ctx.mk_nest();
      ctx_nest.breakable = true;
      this.scope.validate(ctx_nest);
    };

    For_range.prototype.clone = function() {
      var ret;
      ret = new module.For_range;
      ret.exclusive = this.exclusive;
      ret.i = this.i.clone();
      ret.a = this.a.clone();
      ret.b = this.b.clone();
      if (this.step) {
        ret.step = this.step.clone();
      }
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return For_range;

  })();

  this.For_col = (function() {
    For_col.prototype.k = null;

    For_col.prototype.v = null;

    For_col.prototype.t = null;

    For_col.prototype.scope = null;

    For_col.prototype.line = 0;

    For_col.prototype.pos = 0;

    function For_col() {
      this.scope = new module.Scope;
    }

    For_col.prototype.validate = function(ctx) {
      var ctx_nest, _ref6, _ref7;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.t) {
        throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". Target is missing");
      }
      if (!this.k && !this.v) {
        throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". Key and value is missing");
      }
      this.t.validate(ctx);
      if ((_ref6 = this.k) != null) {
        _ref6.validate(ctx);
      }
      if ((_ref7 = this.v) != null) {
        _ref7.validate(ctx);
      }
      switch (this.t.type.main) {
        case "array":
        case "hash_int":
          if (this.k) {
            if (this.k.type.main !== "int") {
              throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". Key must be int for array<t> target but found '" + this.k.type + "'");
            }
          }
          break;
        case "hash":
          if (this.k) {
            if (this.k.type.main !== "string") {
              throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". Key must be string for hash<t> target but found '" + this.k.type + "'");
            }
          }
          break;
        default:
          throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". For_col accepts types array<t>, hash<t> and hash_int<t> but found '" + this.t.type + "'");
      }
      if (this.v) {
        if (!this.v.type.cmp(this.t.type.nest_list[0])) {
          throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". Value must be '" + this.t.type.nest_list[0] + "' but found '" + this.v.type + "'");
        }
      }
      ctx_nest = ctx.mk_nest();
      ctx_nest.breakable = true;
      this.scope.validate(ctx_nest);
    };

    For_col.prototype.clone = function() {
      var ret;
      ret = new module.For_col;
      ret.t = this.t.clone();
      if (this.v) {
        ret.v = this.v.clone();
      }
      if (this.k) {
        ret.k = this.k.clone();
      }
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return For_col;

  })();

  this.Ret = (function() {
    function Ret() {}

    Ret.prototype.t = null;

    Ret.prototype.line = 0;

    Ret.prototype.pos = 0;

    Ret.prototype.validate = function(ctx) {
      var return_type, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if ((_ref6 = this.t) != null) {
        _ref6.validate(ctx);
      }
      if (!ctx.returnable) {
        throw new Error("Ret validation error line=" + this.line + " pos=" + this.pos + ". ctx must be returnable");
      }
      return_type = ctx.check_id("$_return_type");
      if (this.t != null) {
        if (!this.t.type.cmp(return_type)) {
          throw new Error("Ret validation error line=" + this.line + " pos=" + this.pos + ". Ret type must be '" + return_type + "' but found '" + this.t.type + "'");
        }
      } else {
        if (return_type.main !== "void") {
          throw new Error("Ret validation error line=" + this.line + " pos=" + this.pos + ". Ret type must be '" + return_type + "' but found void (no return value)");
        }
      }
    };

    Ret.prototype.clone = function() {
      var ret;
      ret = new module.Ret;
      if (this.t) {
        ret.t = this.t.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Ret;

  })();

  this.Try = (function() {
    Try.prototype.t = null;

    Try.prototype.c = null;

    Try.prototype.exception_var_name = "";

    Try.prototype.line = 0;

    Try.prototype.pos = 0;

    function Try() {
      this.t = new module.Scope;
      this.c = new module.Scope;
    }

    Try.prototype.clone = function() {
      var ret;
      ret = new module.Try;
      ret.t = this.t.clone();
      ret.c = this.c.clone();
      ret.exception_var_name = this.exception_var_name;
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Try;

  })();

  this.Throw = (function() {
    function Throw() {}

    Throw.prototype.t = null;

    Throw.prototype.line = 0;

    Throw.prototype.pos = 0;

    Throw.prototype.clone = function() {
      var ret;
      ret = new module.Throw;
      if (this.t) {
        ret.t = this.t.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Throw;

  })();

  this.Var_decl = (function() {
    function Var_decl() {}

    Var_decl.prototype.name = "";

    Var_decl.prototype.type = null;

    Var_decl.prototype.size = null;

    Var_decl.prototype.assign_value = null;

    Var_decl.prototype.assign_value_list = null;

    Var_decl.prototype.line = 0;

    Var_decl.prototype.pos = 0;

    Var_decl.prototype.validate = function(ctx) {
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      type_validate(this.type, ctx);
      if (ctx.check_id_decl(this.name)) {
        throw new Error("Var_decl validation error line=" + this.line + " pos=" + this.pos + ". Redeclare '" + this.name + "'");
      }
      ctx.var_hash[this.name] = this;
    };

    Var_decl.prototype.clone = function() {
      var ret, _len6, _o, _ref6;
      ret = new module.Var_decl;
      ret.name = this.name;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.size = this.size;
      if (this.assign_value) {
        ret.assign_value = this.assign_value.clone();
      }
      if (this.assign_value_list) {
        ret.assign_value_list = [];
        _ref6 = this.assign_value_list;
        for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
          v = _ref6[_o];
          ret.assign_value_list.push(v.clone());
        }
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Var_decl;

  })();

  this.Class_decl = (function() {
    Class_decl.prototype.name = "";

    Class_decl.prototype.scope = null;

    Class_decl.prototype._prepared_field2type = {};

    Class_decl.prototype.line = 0;

    Class_decl.prototype.pos = 0;

    function Class_decl() {
      this.scope = new module.Scope;
      this._prepared_field2type = {};
    }

    Class_decl.prototype.register = function(ctx) {
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (ctx.check_type(this.name)) {
        throw new Error("Already registered '" + this.name + "'");
      }
      ctx.type_hash[this.name] = this;
    };

    Class_decl.prototype.validate = function(ctx) {
      var ctx_nest, var_decl, _len6, _o, _ref6, _ref7;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.name) {
        throw new Error("Class_decl validation error line=" + this.line + " pos=" + this.pos + ". Class should have name");
      }
      this._prepared_field2type = {};
      _ref6 = this.scope.list;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        v = _ref6[_o];
        if ((_ref7 = v.constructor.name) !== "Var_decl" && _ref7 !== "Fn_decl") {
          throw new Error("Class_decl validation error line=" + this.line + " pos=" + this.pos + ". Only Var_decl and Fn_decl allowed at Class_decl, but '" + v.constructor.name + "' found");
        }
        this._prepared_field2type[v.name] = v.type;
      }
      ctx_nest = ctx.mk_nest();
      var_decl = new module.Var_decl;
      var_decl.name = "this";
      var_decl.type = new Type(this.name);
      ctx_nest.var_hash["this"] = var_decl;
      this.scope.validate(ctx_nest);
    };

    Class_decl.prototype.clone = function() {
      var k, ret, _ref6;
      ret = new module.Class_decl;
      ret.name = this.name;
      ret.scope = this.scope.clone();
      _ref6 = this._prepared_field2type;
      for (k in _ref6) {
        v = _ref6[k];
        ret._prepared_field2type[k] = v.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Class_decl;

  })();

  this.Fn_decl = (function() {
    Fn_decl.prototype.is_closure = false;

    Fn_decl.prototype.name = "";

    Fn_decl.prototype.type = null;

    Fn_decl.prototype.arg_name_list = [];

    Fn_decl.prototype.scope = null;

    Fn_decl.prototype.line = 0;

    Fn_decl.prototype.pos = 0;

    function Fn_decl() {
      this.arg_name_list = [];
      this.scope = new module.Scope;
    }

    Fn_decl.prototype.validate = function(ctx) {
      var ctx_nest, decl, k, name, var_decl, _len6, _o, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.name && !this.is_closure) {
        throw new Error("Fn_decl validation error line=" + this.line + " pos=" + this.pos + ". Function should have name");
      }
      type_validate(this.type, ctx);
      if (this.type.main !== "function") {
        throw new Error("Fn_decl validation error line=" + this.line + " pos=" + this.pos + ". Type must be function but '" + this.type + "' found");
      }
      if (this.type.nest_list.length - 1 !== this.arg_name_list.length) {
        throw new Error("Fn_decl validation error line=" + this.line + " pos=" + this.pos + ". @type.nest_list.length-1 != @arg_name_list " + (this.type.nest_list.length - 1) + " != " + this.arg_name_list.length);
      }
      if (this.is_closure) {
        ctx_nest = ctx.mk_nest();
      } else {
        ctx_nest = ctx.seek_non_executable_parent().mk_nest();
      }
      ctx_nest.executable = true;
      ctx_nest.returnable = true;
      _ref6 = this.arg_name_list;
      for (k = _o = 0, _len6 = _ref6.length; _o < _len6; k = ++_o) {
        name = _ref6[k];
        decl = new module.Var_decl;
        decl.name = name;
        decl.type = this.type.nest_list[1 + k];
        ctx_nest.var_hash[name] = decl;
      }
      ctx_nest.var_hash["$_return_type"] = this.type.nest_list[0];
      this.scope.validate(ctx_nest);
      var_decl = new module.Var_decl;
      var_decl.name = this.name;
      var_decl.type = this.type;
      ctx.var_hash[this.name] = var_decl;
    };

    Fn_decl.prototype.clone = function() {
      var ret;
      ret = new module.Fn_decl;
      ret.is_closure = this.is_closure;
      ret.name = this.name;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.arg_name_list = this.arg_name_list.clone();
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Fn_decl;

  })();

}).call(window.ast4gen = {});
/*/lib/ast.js*/(function() {
  var ast, k, module, v;

  module = this;

  ast = window.ast4gen;

  for (k in ast) {
    v = ast[k];
    this[k] = v;
  }

  this.INPUT_ARGS = 0;

  this.RETURN_VALUES = 1;

  this.Class_decl = (function() {
    Class_decl.prototype.name = "";

    Class_decl.prototype.namespace_name = true;

    Class_decl.prototype.is_contract = false;

    Class_decl.prototype.is_library = false;

    Class_decl.prototype.is_interface = false;

    Class_decl.prototype.is_struct = false;

    Class_decl.prototype.need_skip = false;

    Class_decl.prototype.scope = null;

    Class_decl.prototype._prepared_field2type = {};

    Class_decl.prototype.inheritance_list = [];

    Class_decl.prototype.using_map = {};

    Class_decl.prototype.line = 0;

    Class_decl.prototype.pos = 0;

    Class_decl.prototype.file = "";

    function Class_decl() {
      this.scope = new module.Scope;
      this._prepared_field2type = {};
      this.inheritance_list = [];
      this.using_map = {};
    }

    Class_decl.prototype.clone = function() {
      var arg, arg_list, ret, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      ret = new module.Class_decl;
      ret.name = this.name;
      ret.namespace_name = this.namespace_name;
      ret.is_contract = this.is_contract;
      ret.is_library = this.is_library;
      ret.is_interface = this.is_interface;
      ret.is_struct = this.is_struct;
      ret.need_skip = this.need_skip;
      ret.scope = this.scope.clone();
      _ref = this._prepared_field2type;
      for (k in _ref) {
        v = _ref[k];
        ret._prepared_field2type[k] = v.clone();
      }
      _ref1 = this.inheritance_list;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        v = _ref1[_i];
        arg_list = [];
        _ref2 = v.arg_list;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          arg = _ref2[_j];
          arg_list.push(arg.clone());
        }
        ret.inheritance_list.push({
          name: v.name,
          arg_list: arg_list
        });
      }
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Class_decl;

  })();

  this.Var = (function() {
    function Var() {}

    Var.prototype.name = "";

    Var.prototype.name_translate = true;

    Var.prototype.type = null;

    Var.prototype.line = 0;

    Var.prototype.pos = 0;

    Var.prototype.file = "";

    Var.prototype.clone = function() {
      var ret;
      ret = new module.Var;
      ret.name = this.name;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Var;

  })();

  this.Var_decl = (function() {
    function Var_decl() {}

    Var_decl.prototype.name = "";

    Var_decl.prototype.name_translate = true;

    Var_decl.prototype.contract_name = "";

    Var_decl.prototype.contract_type = "";

    Var_decl.prototype.type = null;

    Var_decl.prototype.size = null;

    Var_decl.prototype.assign_value = null;

    Var_decl.prototype.assign_value_list = null;

    Var_decl.prototype.is_enum_decl = false;

    Var_decl.prototype.is_const = false;

    Var_decl.prototype.line = 0;

    Var_decl.prototype.pos = 0;

    Var_decl.prototype.file = "";

    Var_decl.prototype.clone = function() {
      var ret, _i, _len, _ref;
      ret = new module.Var_decl;
      ret.name = this.name;
      ret.name_translate = this.name_translate;
      ret.contract_name = this.contract_name;
      ret.contract_type = this.contract_type;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.size = this.size;
      if (this.assign_value) {
        ret.assign_value = this.assign_value.clone();
      }
      if (this.assign_value_list) {
        ret.assign_value_list = [];
        _ref = this.assign_value_list;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          ret.assign_value_list.push(v.clone());
        }
      }
      ret.is_enum_decl = this.is_enum_decl;
      ret.is_const = this.is_const;
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Var_decl;

  })();

  this.Fn_call = (function() {
    Fn_call.prototype.fn = null;

    Fn_call.prototype.arg_list = [];

    Fn_call.prototype.splat_fin = false;

    Fn_call.prototype.type = null;

    Fn_call.prototype.left_unpack = true;

    Fn_call.prototype.fn_decl = null;

    Fn_call.prototype.is_fn_decl_from_using = false;

    Fn_call.prototype.fn_name_using = null;

    Fn_call.prototype.line = 0;

    Fn_call.prototype.pos = 0;

    Fn_call.prototype.file = "";

    function Fn_call() {
      this.arg_list = [];
    }

    Fn_call.prototype.validate = function(ctx) {
      var arg, _i, _len, _ref;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.fn) {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". fn missing");
      }
      this.fn.validate(ctx);
      if (this.fn.type.main !== "function") {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". Can't call type '@fn.type'. You can call only function");
      }
      if (!this.type.cmp(void_type)) {
        type_validate(this.type, ctx);
      }
      if (!this.type.cmp(this.fn.type.nest_list[0])) {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". Return type and function decl return type doesn't match " + this.fn.type.nest_list[0] + " != " + this.type);
      }
      if (this.fn.type.nest_list.length - 1 !== this.arg_list.length) {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". Expected arg count=" + (this.fn.type.nest_list.length - 1) + " found=" + this.arg_list.length);
      }
      _ref = this.arg_list;
      for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
        arg = _ref[k];
        arg.validate(ctx);
        if (!this.fn.type.nest_list[k + 1].cmp(arg.type)) {
          throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". arg[" + k + "] type mismatch. Expected=" + this.fn.type.nest_list[k + 1] + " found=" + arg.type);
        }
      }
    };

    Fn_call.prototype.clone = function() {
      var ret, _i, _len, _ref;
      ret = new module.Fn_call;
      ret.fn = this.fn.clone();
      _ref = this.arg_list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        ret.arg_list.push(v.clone());
      }
      ret.splat_fin = this.splat_fin;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.left_unpack = this.left_unpack;
      ret.fn_decl = this.fn_decl;
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Fn_call;

  })();

  this.Fn_decl_multiret = (function() {
    Fn_decl_multiret.prototype.is_closure = false;

    Fn_decl_multiret.prototype.name = "";

    Fn_decl_multiret.prototype.type_i = null;

    Fn_decl_multiret.prototype.type_o = null;

    Fn_decl_multiret.prototype.arg_name_list = [];

    Fn_decl_multiret.prototype.scope = null;

    Fn_decl_multiret.prototype.line = 0;

    Fn_decl_multiret.prototype.pos = 0;

    Fn_decl_multiret.prototype.file = "";

    Fn_decl_multiret.prototype.visibility = "";

    Fn_decl_multiret.prototype.state_mutability = "";

    Fn_decl_multiret.prototype.contract_name = "";

    Fn_decl_multiret.prototype.contract_type = "";

    Fn_decl_multiret.prototype.is_modifier = false;

    Fn_decl_multiret.prototype.is_constructor = false;

    Fn_decl_multiret.prototype.modifier_list = [];

    Fn_decl_multiret.prototype.returns_op_list = false;

    Fn_decl_multiret.prototype.uses_storage = false;

    Fn_decl_multiret.prototype.modifies_storage = false;

    Fn_decl_multiret.prototype.returns_value = false;

    function Fn_decl_multiret() {
      this.arg_name_list = [];
      this.scope = new ast.Scope;
      this.modifier_list = [];
      this.contract_name = "";
      this.contract_type = "";
    }

    Fn_decl_multiret.prototype.clone = function() {
      var ret, _i, _len, _ref;
      ret = new module.Fn_decl_multiret;
      ret.is_closure = this.is_closure;
      ret.name = this.name;
      ret.type_i = this.type_i.clone();
      ret.type_o = this.type_o.clone();
      ret.arg_name_list = this.arg_name_list.clone();
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      ret.visibility = this.visibility;
      ret.state_mutability = this.state_mutability;
      ret.contract_name = this.contract_name;
      ret.contract_type = this.contract_type;
      ret.is_modifier = this.is_modifier;
      ret.is_constructor = this.is_constructor;
      _ref = this.modifier_list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        ret.modifier_list.push(v.clone());
      }
      ret.returns_op_list = this.returns_op_list;
      ret.uses_storage = this.uses_storage;
      ret.modifies_storage = this.modifies_storage;
      ret.returns_value = this.returns_value;
      return ret;
    };

    return Fn_decl_multiret;

  })();

  this.Ret_multi = (function() {
    Ret_multi.prototype.t_list = [];

    Ret_multi.prototype.line = 0;

    Ret_multi.prototype.pos = 0;

    Ret_multi.prototype.file = 0;

    function Ret_multi() {
      this.t_list = [];
    }

    Ret_multi.prototype.clone = function() {
      var ret, _i, _len, _ref;
      ret = new module.Ret_multi;
      _ref = this.t_list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        ret.t_list.push(v.clone());
      }
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Ret_multi;

  })();

  this.Comment = (function() {
    function Comment() {}

    Comment.prototype.text = "";

    Comment.prototype.line = 0;

    Comment.prototype.pos = 0;

    Comment.prototype.can_skip = false;

    Comment.prototype.file = "";

    Comment.prototype.clone = function() {
      var ret;
      ret = new module.Comment;
      ret.text = this.text;
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      ret.can_skip = this.can_skip;
      return ret;
    };

    return Comment;

  })();

  this.Tuple = (function() {
    Tuple.prototype.list = [];

    Tuple.prototype.type = null;

    Tuple.prototype.line = 0;

    Tuple.prototype.pos = 0;

    function Tuple() {
      this.list = [];
    }

    Tuple.prototype.clone = function() {
      var ret, _i, _len, _ref;
      ret = new module.Tuple;
      _ref = this.list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        ret.list.push(v.clone());
      }
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Tuple;

  })();

  this.Var_decl_multi = (function() {
    Var_decl_multi.prototype.list = [];

    Var_decl_multi.prototype.assign_value = null;

    Var_decl_multi.prototype.type = null;

    Var_decl_multi.prototype.line = 0;

    Var_decl_multi.prototype.pos = 0;

    Var_decl_multi.prototype.file = "";

    function Var_decl_multi() {
      this.list = [];
    }

    Var_decl_multi.prototype.clone = function() {
      var ret, _i, _len, _ref;
      ret = new module.Var_decl_multi;
      _ref = this.list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        if (v.skip) {
          ret.list.push({
            name: v.name,
            skip: v.skip
          });
        } else {
          ret.list.push({
            name: v.name,
            type: v.type.clone()
          });
        }
      }
      ret.assign_value = this.assign_value.clone();
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Var_decl_multi;

  })();

  this.Ternary = (function() {
    function Ternary() {}

    Ternary.prototype.cond = null;

    Ternary.prototype.t = null;

    Ternary.prototype.f = null;

    Ternary.prototype.line = 0;

    Ternary.prototype.pos = 0;

    Ternary.prototype.file = "";

    Ternary.prototype.clone = function() {
      var ret;
      ret = new module.Ternary;
      ret.cond = this.cond.clone();
      ret.t = this.t.clone();
      ret.f = this.f.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Ternary;

  })();

  this.New = (function() {
    New.prototype.cls = null;

    New.prototype.arg_list = [];

    New.prototype.line = 0;

    New.prototype.pos = 0;

    function New() {
      this.arg_list = [];
    }

    New.prototype.clone = function() {
      var ret, _i, _len, _ref;
      ret = new module.New;
      ret.cls = this.cls;
      _ref = this.arg_list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        ret.arg_list.push(v.clone());
      }
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return New;

  })();

  this.Type_cast = (function() {
    function Type_cast() {}

    Type_cast.prototype.target_type = null;

    Type_cast.prototype.t = null;

    Type_cast.prototype.line = 0;

    Type_cast.prototype.pos = 0;

    Type_cast.prototype.file = "";

    Type_cast.prototype.clone = function() {
      var ret;
      ret = new module.Type_cast;
      ret.target_type = this.target_type.clone();
      ret.t = this.t.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Type_cast;

  })();

  this.For3 = (function() {
    For3.prototype.init = null;

    For3.prototype.cond = null;

    For3.prototype.iter = null;

    For3.prototype.scope = null;

    For3.prototype.line = 0;

    For3.prototype.pos = 0;

    For3.prototype.file = "";

    function For3() {
      this.scope = new ast.Scope;
    }

    For3.prototype.clone = function() {
      var ret;
      ret = new module.For3;
      if (this.init) {
        ret.init = this.init.clone();
      }
      if (this.cond) {
        ret.cond = this.cond.clone();
      }
      if (this.init) {
        ret.iter = this.iter.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return For3;

  })();

  this.PM_switch = (function() {
    PM_switch.prototype.cond = null;

    PM_switch.prototype.scope = null;

    PM_switch.prototype.line = 0;

    PM_switch.prototype.pos = 0;

    PM_switch.prototype.file = "";

    function PM_switch() {
      this.scope = new ast.Scope;
    }

    PM_switch.prototype.clone = function() {
      var ret;
      ret = new module.PM_switch;
      ret.cond = this.cond.clone();
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return PM_switch;

  })();

  this.PM_case = (function() {
    PM_case.prototype.struct_name = "";

    PM_case.prototype.var_decl = null;

    PM_case.prototype.scope = null;

    PM_case.prototype.line = 0;

    PM_case.prototype.pos = 0;

    function PM_case() {
      this.var_decl = new ast.Var_decl;
      this.scope = new ast.Scope;
    }

    PM_case.prototype.clone = function() {
      var ret;
      ret = new module.PM_case;
      ret.struct_name = this.struct_name;
      ret.var_decl = this.var_decl.clone();
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return PM_case;

  })();

  this.Enum_decl = (function() {
    Enum_decl.prototype.name = "";

    Enum_decl.prototype.value_list = [];

    Enum_decl.prototype.int_type = true;

    Enum_decl.prototype.line = 0;

    Enum_decl.prototype.pos = 0;

    Enum_decl.prototype.file = "";

    function Enum_decl() {
      this.value_list = [];
    }

    Enum_decl.prototype.clone = function() {
      var ret, _i, _len, _ref;
      ret = new module.Enum_decl;
      ret.name = this.name;
      _ref = this.value_list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        ret.value_list.push(v.clone());
      }
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Enum_decl;

  })();

  this.Event_decl = (function() {
    function Event_decl() {}

    Event_decl.prototype.name = "";

    Event_decl.prototype.arg_list = [];

    Event_decl.prototype.line = 0;

    Event_decl.prototype.pos = 0;

    Event_decl.prototype.file = "";

    Event_decl.prototype.clone = function() {
      var ret;
      ret = new module.Event_decl;
      ret.name = this.name;
      ret.arg_list = this.arg_list;
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Event_decl;

  })();

  this.Struct_init = (function() {
    Struct_init.prototype.fn = null;

    Struct_init.prototype.arg_names = [];

    Struct_init.prototype.val_list = [];

    Struct_init.prototype.line = 0;

    Struct_init.prototype.pos = 0;

    Struct_init.prototype.file = "";

    function Struct_init() {
      this.val_list = [];
      this.arg_names = [];
    }

    Struct_init.prototype.clone = function() {
      var idx, ret, _i, _j, _len, _len1, _ref, _ref1;
      ret = new module.Struct_init;
      ret.fn = this.fn;
      _ref = this.val_list;
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        v = _ref[idx];
        ret.val_list[idx] = v.clone();
      }
      _ref1 = this.arg_names;
      for (idx = _j = 0, _len1 = _ref1.length; _j < _len1; idx = ++_j) {
        v = _ref1[idx];
        ret.arg_names[idx] = v;
      }
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Struct_init;

  })();

  this.Include = (function() {
    function Include() {}

    Include.prototype.path = "";

    Include.prototype.line = 0;

    Include.prototype.pos = 0;

    Include.prototype.file = "";

    Include.prototype.clone = function() {
      var path;
      path = "";
      ret.line = this.line;
      ret.pos = this.pos;
      ret.file = this.file;
      return ret;
    };

    return Include;

  })();

}).call(window.require_register("./ast"));
/*/lib/type_generalize.js*/(function() {
  var config, module;

  module = this;

  config = require("./config");

  this.type_generalize = function(type) {
    if (config.uint_type_list.has(type)) {
      type = "uint";
    }
    if (config.int_type_list.has(type)) {
      type = "int";
    }
    if (config.bytes_type_list.has(type)) {
      type = "bytes";
    }
    return type;
  };

}).call(window.require_register("./type_generalize"));
/*/lib/translate_var_name.js*/(function() {
  var bad_spec_id_trans_map, config, reserved_map, spec_id_trans_map, warning_once_map;

  config = require("./config");

  reserved_map = {
    "get_force": true,
    "get_chain_id": true,
    "transaction": true,
    "get_contract": true,
    "get_entrypoint": true,
    "size": true,
    "abs": true,
    "is_nat": true,
    "amount": true,
    "balance": true,
    "now": true,
    "unit": true,
    "source": true,
    "sender": true,
    "failwith": true,
    "bitwise_or": true,
    "bitwise_and": true,
    "bitwise_xor": true,
    "bitwise_lsl": true,
    "bitwise_lsr": true,
    "Bitwise": true,
    "string_concat": true,
    "string_slice": true,
    "crypto_check": true,
    "crypto_map_key": true,
    "bytes_concat": true,
    "bytes_slice": true,
    "bytes_pack": true,
    "bytes_unpack": true,
    "set_empty": true,
    "set_mem": true,
    "set_add": true,
    "set_remove": true,
    "set_iter": true,
    "set_fold": true,
    "list_iter": true,
    "list_fold": true,
    "list_map": true,
    "map_iter": true,
    "map_map": true,
    "map_fold": true,
    "map_remove": true,
    "map_update": true,
    "map_get": true,
    "map_mem": true,
    "sha_256": true,
    "sha_512": true,
    "blake2b": true,
    "cons": true,
    "EQ": true,
    "NEQ": true,
    "NEG": true,
    "ADD": true,
    "SUB": true,
    "TIMES": true,
    "DIV": true,
    "MOD": true,
    "NOT": true,
    "AND": true,
    "OR": true,
    "GT": true,
    "GE": true,
    "LT": true,
    "LE": true,
    "CONS": true,
    "self_address": true,
    "implicit_account": true,
    "set_delegate": true,
    "to": true,
    "args": true,
    "main": true,
    "Tezos": true,
    "map": true,
    "some": true
  };

  reserved_map[config.contract_storage] = true;

  reserved_map[config.op_list] = true;

  this.translate_var_name = function(name, ctx) {
    if (name[0] === "_") {
      name = name.replace("_", "") + "_";
    }
    name = name[0].toLowerCase() + name.substr(1);
    if (name.startsWith("@")) {
      return name.substr(1);
    } else if (reserved_map.hasOwnProperty(name)) {
      return "" + config.reserved + "__" + name;
    } else {
      return name;
    }
  };

  spec_id_trans_map = {
    "now": "abs(now - (\"1970-01-01T00:00:00Z\": timestamp))",
    "msg.sender": "sender",
    "tx.origin": "source",
    "block.timestamp": "abs(now - (\"1970-01-01T00:00:00Z\": timestamp))",
    "msg.value": "(amount / 1mutez)",
    "abi.encodePacked": ""
  };

  bad_spec_id_trans_map = {
    "block.coinbase": "(" + (JSON.stringify(config.default_address)) + " : address)",
    "block.difficulty": "0n",
    "block.gaslimit": "0n",
    "block.number": "0n",
    "msg.data": "(\"00\": bytes)",
    "msg.gas": "0n",
    "msg.sig": "(\"00\": bytes)",
    "tx.gasprice": "0n"
  };

  warning_once_map = {};

  this.spec_id_translate = function(t, name) {
    var val;
    if (spec_id_trans_map.hasOwnProperty(t)) {
      return spec_id_trans_map[t];
    } else if (bad_spec_id_trans_map.hasOwnProperty(t)) {
      val = bad_spec_id_trans_map[t];
      if (!warning_once_map.hasOwnProperty(t)) {
        warning_once_map.hasOwnProperty[t] = true;
        perr("WARNING (translate). We don't have a proper translation for Solidity '" + t + "', so it is translated as '" + val + "'");
      }
      return val;
    } else {
      return name;
    }
  };

}).call(window.require_register("./translate_var_name"));
/*/lib/type_inference/common.js*/(function() {
  var Type, config, is_composite_type, is_defined_number_or_byte_type, module, op, translate_var_name, type_resolve, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;

  module = this;

  translate_var_name = require("../translate_var_name").translate_var_name;

  config = require("../config");

  Type = window.Type;

  this.default_var_map_gen = function() {
    return {
      msg: (function() {
        var ret;
        ret = new Type("struct");
        ret.field_map.sender = new Type("address");
        ret.field_map.value = new Type("uint256");
        ret.field_map.data = new Type("bytes");
        ret.field_map.gas = new Type("uint256");
        ret.field_map.sig = new Type("bytes4");
        return ret;
      })(),
      tx: (function() {
        var ret;
        ret = new Type("struct");
        ret.field_map["origin"] = new Type("address");
        ret.field_map["gasprice"] = new Type("uint256");
        return ret;
      })(),
      block: (function() {
        var ret;
        ret = new Type("struct");
        ret.field_map["timestamp"] = new Type("uint256");
        ret.field_map["coinbase"] = new Type("address");
        ret.field_map["difficulty"] = new Type("uint256");
        ret.field_map["gaslimit"] = new Type("uint256");
        ret.field_map["number"] = new Type("uint256");
        return ret;
      })(),
      abi: (function() {
        var ret;
        ret = new Type("struct");
        ret.field_map["encodePacked"] = new Type("function2<function<bytes>,function<bytes>>");
        return ret;
      })(),
      now: new Type("uint256"),
      require: new Type("function2<function<bool>,function<>>"),
      require2: new Type("function2<function<bool, string>,function<>>"),
      assert: new Type("function2<function<bool>,function<>>"),
      revert: new Type("function2<function<string>,function<>>"),
      sha256: new Type("function2<function<bytes>,function<bytes32>>"),
      sha3: new Type("function2<function<bytes>,function<bytes32>>"),
      blockhash: new Type("function2<function<uint256>,function<bytes32>>"),
      selfdestruct: new Type("function2<function<address>,function<>>"),
      blockmap: new Type("function2<function<address>,function<bytes32>>"),
      keccak256: new Type("function2<function<bytes>,function<bytes32>>"),
      ripemd160: new Type("function2<function<bytes>,function<bytes20>>"),
      ecrecover: new Type("function2<function<bytes, uint8, bytes32, bytes32>,function<address>>")
    };
  };

  this.array_field_map = {
    "length": new Type("uint256"),
    "push": function(type) {
      var ret;
      ret = new Type("function2<function<>,function<>>");
      ret.nest_list[0].nest_list.push(type.nest_list[0]);
      return ret;
    }
  };

  this.bytes_field_map = {
    "length": new Type("uint256")
  };

  this.address_field_map = {
    "send": new Type("function2<function2<uint256>,function2<bool>>"),
    "transfer": new Type("function2<function2<uint256>,function2<>>")
  };

  this.is_not_defined_type = function(type) {
    var _ref;
    return !type || ((_ref = type.main) === "number" || _ref === "unsigned_number" || _ref === "signed_number");
  };

  this.is_number_type = function(type) {
    var _ref;
    if (!type) {
      return false;
    }
    return (_ref = type.main) === "number" || _ref === "unsigned_number" || _ref === "signed_number";
  };

  is_composite_type = function(type) {
    var _ref;
    return (_ref = type.main) === "array" || _ref === "tuple" || _ref === "map" || _ref === "struct";
  };

  is_defined_number_or_byte_type = function(type) {
    return config.any_int_type_map[type.main] || config.bytes_type_map[type.main];
  };

  type_resolve = function(type, ctx) {
    if (type && type.main !== "struct") {
      if (ctx.type_map[type.main]) {
        type = ctx.check_id(type.main);
      }
    }
    return type;
  };

  this.default_type_map_gen = function() {
    var ret, type, _i, _j, _len, _len1, _ref, _ref1;
    ret = {
      bool: new Type("struct"),
      array: new Type("struct"),
      string: new Type("struct"),
      address: new Type("struct")
    };
    _ref = config.any_int_type_list;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      type = _ref[_i];
      ret[type] = new Type("struct");
    }
    _ref1 = config.bytes_type_list;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      type = _ref1[_j];
      ret[type] = new Type("struct");
    }
    return ret;
  };

  this.bin_op_ret_type_map_list = {
    BOOL_AND: [["bool", "bool", "bool"]],
    BOOL_OR: [["bool", "bool", "bool"]],
    BOOL_GT: [["bool", "bool", "bool"]],
    BOOL_LT: [["bool", "bool", "bool"]],
    BOOL_GTE: [["bool", "bool", "bool"]],
    BOOL_LTE: [["bool", "bool", "bool"]],
    ASSIGN: []
  };

  this.un_op_ret_type_map_list = {
    BOOL_NOT: [["bool", "bool"]],
    BIT_NOT: [],
    MINUS: []
  };

  _ref = "ADD SUB MUL DIV MOD POW".split(/\s+/g);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    v = _ref[_i];
    this.bin_op_ret_type_map_list[v] = [];
  }

  _ref1 = "BIT_AND BIT_OR BIT_XOR".split(/\s+/g);
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    v = _ref1[_j];
    this.bin_op_ret_type_map_list[v] = [];
  }

  _ref2 = "EQ NE GT LT GTE LTE".split(/\s+/g);
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    v = _ref2[_k];
    this.bin_op_ret_type_map_list[v] = [];
  }

  _ref3 = "SHL SHR POW".split(/\s+/g);
  for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
    v = _ref3[_l];
    this.bin_op_ret_type_map_list[v] = [];
  }

  _ref4 = "RET_INC RET_DEC INC_RET DEC_RET".split(/\s+/g);
  for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
    op = _ref4[_m];
    this.un_op_ret_type_map_list[op] = [];
  }

  (function(_this) {
    return (function() {
      var idx1, idx2, list, type, type1, type2, type_index, type_main, _aa, _ab, _ac, _ad, _ae, _af, _ag, _ah, _ai, _len10, _len11, _len12, _len13, _len14, _len15, _len16, _len17, _len18, _len19, _len20, _len21, _len22, _len23, _len24, _len25, _len26, _len5, _len6, _len7, _len8, _len9, _n, _o, _p, _q, _r, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u, _v, _w, _x, _y, _z;
      _ref5 = config.any_int_type_list;
      for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
        type = _ref5[_n];
        _this.un_op_ret_type_map_list.BIT_NOT.push([type, type]);
      }
      _ref6 = config.int_type_list;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        type = _ref6[_o];
        _this.un_op_ret_type_map_list.MINUS.push([type, type]);
      }
      _ref7 = "RET_INC RET_DEC INC_RET DEC_RET".split(/\s+/g);
      for (_p = 0, _len7 = _ref7.length; _p < _len7; _p++) {
        op = _ref7[_p];
        _ref8 = config.any_int_type_list;
        for (_q = 0, _len8 = _ref8.length; _q < _len8; _q++) {
          type = _ref8[_q];
          _this.un_op_ret_type_map_list[op].push([type, type]);
        }
      }
      _ref9 = "ADD SUB MUL DIV MOD POW".split(/\s+/g);
      for (_r = 0, _len9 = _ref9.length; _r < _len9; _r++) {
        op = _ref9[_r];
        list = _this.bin_op_ret_type_map_list[op];
        _ref10 = config.any_int_type_list;
        for (_s = 0, _len10 = _ref10.length; _s < _len10; _s++) {
          type = _ref10[_s];
          list.push([type, type, type]);
        }
      }
      _ref11 = "ADD SUB MUL DIV MOD POW".split(/\s+/g);
      for (_t = 0, _len11 = _ref11.length; _t < _len11; _t++) {
        op = _ref11[_t];
        list = _this.bin_op_ret_type_map_list[op];
        _ref12 = config.int_type_list;
        for (idx1 = _u = 0, _len12 = _ref12.length; _u < _len12; idx1 = ++_u) {
          type1 = _ref12[idx1];
          _ref13 = config.int_type_list;
          for (idx2 = _v = 0, _len13 = _ref13.length; _v < _len13; idx2 = ++_v) {
            type2 = _ref13[idx2];
            if (idx1 >= idx2) {
              continue;
            }
            list.push([type1, type2, type2]);
            list.push([type2, type1, type2]);
          }
        }
        _ref14 = config.uint_type_list;
        for (idx1 = _w = 0, _len14 = _ref14.length; _w < _len14; idx1 = ++_w) {
          type1 = _ref14[idx1];
          _ref15 = config.uint_type_list;
          for (idx2 = _x = 0, _len15 = _ref15.length; _x < _len15; idx2 = ++_x) {
            type2 = _ref15[idx2];
            if (idx1 >= idx2) {
              continue;
            }
            list.push([type1, type2, type2]);
            list.push([type2, type1, type2]);
          }
        }
      }
      _ref16 = "BIT_AND BIT_OR BIT_XOR".split(/\s+/g);
      for (_y = 0, _len16 = _ref16.length; _y < _len16; _y++) {
        op = _ref16[_y];
        list = _this.bin_op_ret_type_map_list[op];
        _ref17 = config.uint_type_list;
        for (_z = 0, _len17 = _ref17.length; _z < _len17; _z++) {
          type = _ref17[_z];
          list.push([type, type, type]);
        }
        _ref18 = config.int_type_list;
        for (_aa = 0, _len18 = _ref18.length; _aa < _len18; _aa++) {
          type = _ref18[_aa];
          list.push([type, type, type]);
        }
        _ref19 = config.bytes_type_list;
        for (_ab = 0, _len19 = _ref19.length; _ab < _len19; _ab++) {
          type = _ref19[_ab];
          list.push([type, type, type]);
        }
      }
      _ref20 = "EQ NE GT LT GTE LTE".split(/\s+/g);
      for (_ac = 0, _len20 = _ref20.length; _ac < _len20; _ac++) {
        op = _ref20[_ac];
        list = _this.bin_op_ret_type_map_list[op];
        _ref21 = config.any_int_type_list;
        for (_ad = 0, _len21 = _ref21.length; _ad < _len21; _ad++) {
          type = _ref21[_ad];
          list.push([type, type, "bool"]);
        }
      }
      _ref22 = "SHL SHR POW".split(/\s+/g);
      for (_ae = 0, _len22 = _ref22.length; _ae < _len22; _ae++) {
        op = _ref22[_ae];
        list = _this.bin_op_ret_type_map_list[op];
        _ref23 = config.uint_type_list;
        for (_af = 0, _len23 = _ref23.length; _af < _len23; _af++) {
          type_main = _ref23[_af];
          _ref24 = config.uint_type_list;
          for (_ag = 0, _len24 = _ref24.length; _ag < _len24; _ag++) {
            type_index = _ref24[_ag];
            list.push([type_main, type_index, type_main]);
          }
        }
        _ref25 = config.int_type_list;
        for (_ah = 0, _len25 = _ref25.length; _ah < _len25; _ah++) {
          type_main = _ref25[_ah];
          _ref26 = config.int_type_list;
          for (_ai = 0, _len26 = _ref26.length; _ai < _len26; _ai++) {
            type_index = _ref26[_ai];
            list.push([type_main, type_index, type_main]);
          }
        }
      }
    });
  })(this)();

  (function(_this) {
    return (function() {
      var type, type_byte, type_int, _len10, _len5, _len6, _len7, _len8, _len9, _n, _o, _p, _q, _r, _ref10, _ref5, _ref6, _ref7, _ref8, _ref9, _s;
      _ref5 = config.bytes_type_list;
      for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
        type = _ref5[_n];
        _this.un_op_ret_type_map_list.BIT_NOT.push([type, type]);
      }
      _ref6 = config.bytes_type_list;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        type_byte = _ref6[_o];
        _ref7 = config.any_int_type_list;
        for (_p = 0, _len7 = _ref7.length; _p < _len7; _p++) {
          type_int = _ref7[_p];
          _this.bin_op_ret_type_map_list.ASSIGN.push([type_byte, type_int, type_int]);
          _this.bin_op_ret_type_map_list.ASSIGN.push([type_int, type_byte, type_int]);
        }
      }
      _ref8 = "EQ NE GT LT GTE LTE".split(/\s+/g);
      for (_q = 0, _len8 = _ref8.length; _q < _len8; _q++) {
        op = _ref8[_q];
        _ref9 = config.bytes_type_list;
        for (_r = 0, _len9 = _ref9.length; _r < _len9; _r++) {
          type_byte = _ref9[_r];
          _ref10 = config.any_int_type_list;
          for (_s = 0, _len10 = _ref10.length; _s < _len10; _s++) {
            type_int = _ref10[_s];
            _this.bin_op_ret_type_map_list[op].push([type_byte, type_int, "bool"]);
            _this.bin_op_ret_type_map_list[op].push([type_int, type_byte, "bool"]);
          }
          _this.bin_op_ret_type_map_list[op].push([type_byte, type_byte, "bool"]);
        }
      }
    });
  })(this)();

  this.Ti_context = (function() {
    Ti_context.prototype.parent = null;

    Ti_context.prototype.parent_fn = null;

    Ti_context.prototype.current_class = null;

    Ti_context.prototype.var_map = {};

    Ti_context.prototype.type_map = {};

    Ti_context.prototype.library_map = {};

    Ti_context.prototype.walk = null;

    Ti_context.prototype.first_stage_walk = null;

    Ti_context.prototype.change_count = 0;

    function Ti_context() {
      this.var_map = module.default_var_map_gen();
      this.type_map = module.default_type_map_gen();
      this.library_map = {};
    }

    Ti_context.prototype.mk_nest = function() {
      var ret;
      ret = new Ti_context;
      ret.parent = this;
      ret.parent_fn = this.parent_fn;
      ret.current_class = this.current_class;
      ret.first_stage_walk = this.first_stage_walk;
      ret.walk = this.walk;
      obj_set(ret.type_map, this.type_map);
      ret.library_map = this.library_map;
      return ret;
    };

    Ti_context.prototype.type_proxy = function(cls) {
      var k, ret, _len5, _n, _ref5, _ref6;
      if (cls.constructor.name === "Enum_decl") {
        ret = new Type("enum");
        _ref5 = cls.value_list;
        for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
          v = _ref5[_n];
          ret.field_map[v.name] = new Type("int");
        }
        return ret;
      } else {
        ret = new Type("struct");
        _ref6 = cls._prepared_field2type;
        for (k in _ref6) {
          v = _ref6[k];
          if (v.main !== "function2") {
            continue;
          }
          ret.field_map[k] = v;
        }
        return ret;
      }
    };

    Ti_context.prototype.check_id = function(id) {
      var ret, state_class;
      if (id === "this") {
        return this.type_proxy(this.current_class);
      }
      if (this.type_map.hasOwnProperty(id)) {
        return this.type_proxy(this.type_map[id]);
      }
      if (this.var_map.hasOwnProperty(id)) {
        return this.var_map[id];
      }
      if (state_class = this.type_map[config.storage]) {
        if (ret = state_class._prepared_field2type[id]) {
          return ret;
        }
      }
      if (this.parent) {
        return this.parent.check_id(id);
      }
      throw new Error("can't find decl for id '" + id + "'");
    };

    Ti_context.prototype.check_type = function(_type) {
      if (this.type_map.hasOwnProperty(_type)) {
        return this.type_map[_type];
      }
      if (this.parent) {
        return this.parent.check_type(_type);
      }
      throw new Error("can't find type '" + _type + "'");
    };

    return Ti_context;

  })();

  this.class_prepare = function(root, ctx) {
    var type, _len5, _n, _ref5;
    ctx.type_map[root.name] = root;
    if (ctx.parent && ctx.current_class) {
      ctx.parent.type_map["" + ctx.current_class.name + "." + root.name] = root;
    }
    _ref5 = root.scope.list;
    for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
      v = _ref5[_n];
      switch (v.constructor.name) {
        case "Var_decl":
          root._prepared_field2type[v.name] = v.type;
          break;
        case "Fn_decl_multiret":
          type = new Type("function2<function,function>");
          type.nest_list[0] = v.type_i;
          type.nest_list[1] = v.type_o;
          root._prepared_field2type[v.name] = type;
      }
    }
  };

  this.type_resolve = function(type, ctx) {
    if (type && type.main !== "struct") {
      if (ctx.type_map[type.main]) {
        type = ctx.check_id(type.main);
      }
    }
    return type;
  };

  this.type_spread_left = function(a_type, b_type, ctx) {
    var idx, inner_a, inner_b, new_inner_a, _n, _ref5, _ref6, _ref7, _ref8;
    if (!b_type) {
      return a_type;
    }
    if (!a_type && b_type) {
      a_type = b_type.clone();
      ctx.change_count++;
    } else if (a_type.main === "number") {
      if ((_ref5 = b_type.main) === "unsigned_number" || _ref5 === "signed_number") {
        a_type = b_type.clone();
        ctx.change_count++;
      } else if (b_type.main === "number") {
        "nothing";
      } else {
        if (b_type.main === "address") {
          perr("NOTE address to number type cast is not supported in LIGO");
          return a_type;
        }
        if (!is_defined_number_or_byte_type(b_type)) {
          throw new Error("can't spread '" + b_type + "' to '" + a_type + "'");
        }
        a_type = b_type.clone();
        ctx.change_count++;
      }
    } else if (this.is_not_defined_type(a_type) && !this.is_not_defined_type(b_type)) {
      if ((_ref6 = a_type.main) === "unsigned_number" || _ref6 === "signed_number") {
        if (!is_defined_number_or_byte_type(b_type)) {
          throw new Error("can't spread '" + b_type + "' to '" + a_type + "'");
        }
      } else {
        throw new Error("unknown is_not_defined_type spread case");
      }
      a_type = b_type.clone();
      ctx.change_count++;
    } else if (!this.is_not_defined_type(a_type) && this.is_not_defined_type(b_type)) {
      if ((_ref7 = b_type.main) === "number" || _ref7 === "unsigned_number" || _ref7 === "signed_number") {
        if (!is_defined_number_or_byte_type(a_type)) {
          if (a_type.main === "address") {
            perr("WARNING (Type inference). address <-> number operation detected. Generated code will be not compilable by LIGO");
            return a_type;
          }
          throw new Error("can't spread '" + b_type + "' to '" + a_type + "'. Reverse spread collision detected");
        }
      }
    } else {
      if (a_type.cmp(b_type)) {
        return a_type;
      }
      if (a_type.main === "bytes" && config.bytes_type_map.hasOwnProperty(b_type.main)) {
        return a_type;
      }
      if (config.bytes_type_map.hasOwnProperty(a_type.main) && b_type.main === "bytes") {
        return a_type;
      }
      if (a_type.main === "string" && config.bytes_type_map.hasOwnProperty(b_type.main)) {
        return a_type;
      }
      if (config.bytes_type_map.hasOwnProperty(a_type.main) && b_type.main === "string") {
        return a_type;
      }
      if (a_type.main !== "struct" && b_type.main === "struct") {
        a_type = type_resolve(a_type, ctx);
      }
      if (a_type.main === "struct" && b_type.main !== "struct") {
        b_type = type_resolve(b_type, ctx);
      }
      if (is_composite_type(a_type)) {
        if (!is_composite_type(b_type)) {
          perr("can't spread between '" + a_type + "' '" + b_type + "'. Reason: is_composite_type mismatch");
          return a_type;
        }
        if (a_type.main !== b_type.main) {
          throw new Error("spread composite collision '" + a_type + "' '" + b_type + "'. Reason: composite container mismatch");
        }
        if (a_type.nest_list.length !== b_type.nest_list.length) {
          throw new Error("spread composite collision '" + a_type + "' '" + b_type + "'. Reason: nest_list length mismatch");
        }
        for (idx = _n = 0, _ref8 = a_type.nest_list.length; 0 <= _ref8 ? _n < _ref8 : _n > _ref8; idx = 0 <= _ref8 ? ++_n : --_n) {
          inner_a = a_type.nest_list[idx];
          inner_b = b_type.nest_list[idx];
          new_inner_a = this.type_spread_left(inner_a, inner_b, ctx);
          a_type.nest_list[idx] = new_inner_a;
        }
      } else {
        if (is_composite_type(b_type)) {
          perr("can't spread between '" + a_type + "' '" + b_type + "'. Reason: is_composite_type mismatch");
          return a_type;
        }
        if (this.is_number_type(a_type) && this.is_number_type(b_type)) {
          return a_type;
        }
        if (a_type.main === "address" && config.any_int_type_map.hasOwnProperty(b_type)) {
          perr("WARNING (Type inference). address <-> number operation detected. Generated code will be not compilable by LIGO");
          return a_type;
        }
        if (b_type.main === "address" && config.any_int_type_map.hasOwnProperty(a_type)) {
          perr("WARNING (Type inference). address <-> number operation detected. Generated code will be not compilable by LIGO");
          return a_type;
        }
        if (config.bytes_type_map.hasOwnProperty(a_type.main) && config.bytes_type_map.hasOwnProperty(b_type.main)) {
          perr("WARNING (Type inference). Bytes with different sizes are in type collision '" + a_type + "' '" + b_type + "'. This can lead to runtime error.");
          return a_type;
        }
      }
    }
    return a_type;
  };

}).call(window.require_register("./type_inference/common"));
/*/lib/type_inference/stage1.js*/(function() {
  var Type, config, ti, type_generalize;

  Type = window.Type;

  config = require("../config");

  require("../type_safe");

  ti = require("./common");

  type_generalize = require("../type_generalize").type_generalize;

  this.walk = function(root, ctx) {
    var a, a_type, arg, class_decl, complex_type, ctx_nest, decl, expected, expected_type, f, field_map, field_type, fn_decl, i, idx, k, name, nest_list, nest_type, offset, real, ret_type, root_type, t, tuple_value, type, using, using_list, v, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len12, _len13, _len14, _len15, _len16, _len17, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u, _v, _w, _x, _y, _z;
    switch (root.constructor.name) {
      case "Var":
        return root.type = ti.type_spread_left(root.type, ctx.check_id(root.name), ctx);
      case "Const":
        return root.type;
      case "Bin_op":
        ctx.walk(root.a, ctx);
        ctx.walk(root.b, ctx);
        switch (root.op) {
          case "ASSIGN":
            root.a.type = ti.type_spread_left(root.a.type, root.b.type, ctx);
            root.b.type = ti.type_spread_left(root.b.type, root.a.type, ctx);
            root.type = ti.type_spread_left(root.type, root.a.type, ctx);
            root.a.type = ti.type_spread_left(root.a.type, root.type, ctx);
            root.b.type = ti.type_spread_left(root.b.type, root.type, ctx);
            break;
          case "EQ":
          case "NE":
          case "GT":
          case "GTE":
          case "LT":
          case "LTE":
            root.type = ti.type_spread_left(root.type, new Type("bool"), ctx);
            root.a.type = ti.type_spread_left(root.a.type, root.b.type, ctx);
            root.b.type = ti.type_spread_left(root.b.type, root.a.type, ctx);
            break;
          case "INDEX_ACCESS":
            switch ((_ref = root.a.type) != null ? _ref.main : void 0) {
              case "string":
                root.b.type = ti.type_spread_left(root.b.type, new Type("uint256"), ctx);
                root.type = ti.type_spread_left(root.type, new Type("string"), ctx);
                break;
              case "map":
                root.b.type = ti.type_spread_left(root.b.type, root.a.type.nest_list[0], ctx);
                root.type = ti.type_spread_left(root.type, root.a.type.nest_list[1], ctx);
                break;
              case "array":
                root.b.type = ti.type_spread_left(root.b.type, new Type("uint256"), ctx);
                root.type = ti.type_spread_left(root.type, root.a.type.nest_list[0], ctx);
                break;
              default:
                if (config.bytes_type_map.hasOwnProperty((_ref1 = root.a.type) != null ? _ref1.main : void 0)) {
                  root.b.type = ti.type_spread_left(root.b.type, new Type("uint256"), ctx);
                  root.type = ti.type_spread_left(root.type, new Type("bytes1"), ctx);
                }
            }
        }
        return root.type;
      case "Un_op":
        a = ctx.walk(root.a, ctx);
        if (root.op === "DELETE") {
          if (root.a.constructor.name === "Bin_op") {
            if (root.a.op === "INDEX_ACCESS") {
              if (((_ref2 = root.a.a.type) != null ? _ref2.main : void 0) === "array") {
                return root.type;
              }
              if (((_ref3 = root.a.a.type) != null ? _ref3.main : void 0) === "map") {
                return root.type;
              }
            }
          }
        }
        return root.type;
      case "Field_access":
        root_type = ctx.walk(root.t, ctx);
        field_map = {};
        if (root_type) {
          switch (root_type.main) {
            case "array":
              field_map = ti.array_field_map;
              break;
            case "address":
              field_map = ti.address_field_map;
              break;
            case "struct":
              field_map = root_type.field_map;
              break;
            case "enum":
              field_map = root_type.field_map;
              break;
            default:
              if (config.bytes_type_map.hasOwnProperty(root_type.main)) {
                field_map = ti.bytes_field_map;
              } else {
                class_decl = ctx.check_type(root_type.main);
                if (class_decl != null ? class_decl._prepared_field2type : void 0) {
                  field_map = class_decl._prepared_field2type;
                } else {
                  type = type_generalize(root_type.main);
                  using_list = ctx.current_class.using_map[type] || ctx.current_class.using_map["*"];
                  if (using_list) {
                    for (_i = 0, _len = using_list.length; _i < _len; _i++) {
                      using = using_list[_i];
                      class_decl = ctx.check_type(using);
                      if (!class_decl) {
                        perr("WARNING (Type inference). Bad using '" + using + "'");
                        continue;
                      }
                      if (!(fn_decl = class_decl._prepared_field2type[root.name])) {
                        continue;
                      }
                      ret_type = fn_decl.clone();
                      a_type = ret_type.nest_list[0].nest_list.shift();
                      if (!a_type.cmp(root_type)) {
                        perr("WARNING (Type inference). Bad using '" + using + "' types for self are not same " + a_type + " != " + root_type);
                      }
                      root.type = ti.type_spread_left(root.type, ret_type, ctx);
                      return root.type;
                    }
                    perr("WARNING (Type inference). Can't find " + root.name + " for Field_access");
                    return root_type;
                  } else {
                    perr("WARNING (Type inference). Can't find declaration for Field_access ." + root.name);
                    return root_type;
                  }
                }
              }
          }
        }
        if (!field_map.hasOwnProperty(root.name)) {
          perr("WARNING (Type inference). Unknown field. '" + root.name + "' at type '" + root_type + "'. Allowed fields [" + (Object.keys(field_map).join(', ')) + "]");
          return root.type;
        }
        field_type = field_map[root.name];
        if (typeof field_type === "function") {
          field_type = field_type(root.t.type);
        }
        root.type = ti.type_spread_left(root.type, field_type, ctx);
        return root.type;
      case "Fn_call":
        switch (root.fn.constructor.name) {
          case "Var":
            if (root.fn.name === "super") {
              perr("WARNING (Type inference). Skipping super() call");
              _ref4 = root.arg_list;
              for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                arg = _ref4[_j];
                ctx.walk(arg, ctx);
              }
              return root.type;
            }
            break;
          case "Field_access":
            if (root.fn.t.constructor.name === "Var") {
              if (root.fn.t.name === "super") {
                perr("WARNING (Type inference). Skipping super.fn call");
                _ref5 = root.arg_list;
                for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
                  arg = _ref5[_k];
                  ctx.walk(arg, ctx);
                }
                return root.type;
              }
            }
        }
        root_type = ctx.walk(root.fn, ctx);
        root_type = ti.type_resolve(root_type, ctx);
        if (!root_type) {
          perr("WARNING (Type inference). Can't resolve function type for Fn_call");
          return root.type;
        }
        offset = 0;
        _ref6 = root.arg_list;
        for (i = _l = 0, _len3 = _ref6.length; _l < _len3; i = ++_l) {
          arg = _ref6[i];
          ctx.walk(arg, ctx);
          if (root_type.main !== "struct") {
            expected_type = root_type.nest_list[0].nest_list[i + offset];
            arg.type = ti.type_spread_left(arg.type, expected_type, ctx);
          }
        }
        if (root_type.main === "struct") {
          if (root.arg_list.length !== 1) {
            perr("WARNING (Type inference). contract(address) call should have 1 argument. real=" + root.arg_list.length);
            return root.type;
          }
          arg = root.arg_list[0];
          arg.type = ti.type_spread_left(arg.type, new Type("address"), ctx);
          return root.type = ti.type_spread_left(root.type, root_type, ctx);
        } else {
          return root.type = ti.type_spread_left(root.type, root_type.nest_list[1].nest_list[offset], ctx);
        }
        break;
      case "Struct_init":
        root_type = ctx.walk(root.fn, ctx);
        root_type = ti.type_resolve(root_type, ctx);
        if (!root_type) {
          perr("WARNING (Type inference). Can't resolve function type for Struct_init");
          return root.type;
        }
        _ref7 = root.val_list;
        for (i = _m = 0, _len4 = _ref7.length; _m < _len4; i = ++_m) {
          arg = _ref7[i];
          ctx.walk(arg, ctx);
        }
        return root.type;
      case "Comment":
        return null;
      case "Continue":
      case "Break":
        return root;
      case "Var_decl":
        if (root.assign_value) {
          root.assign_value.type = ti.type_spread_left(root.assign_value.type, root.type, ctx);
          ctx.walk(root.assign_value, ctx);
        }
        ctx.var_map[root.name] = root.type;
        return null;
      case "Var_decl_multi":
        if (root.assign_value) {
          root.assign_value.type = ti.type_spread_left(root.assign_value.type, root.type, ctx);
          ctx.walk(root.assign_value, ctx);
        }
        _ref8 = root.list;
        for (_n = 0, _len5 = _ref8.length; _n < _len5; _n++) {
          decl = _ref8[_n];
          ctx.var_map[decl.name] = decl.type;
        }
        return null;
      case "Throw":
        if (root.t) {
          ctx.walk(root.t, ctx);
        }
        return null;
      case "Scope":
        ctx_nest = ctx.mk_nest();
        _ref9 = root.list;
        for (_o = 0, _len6 = _ref9.length; _o < _len6; _o++) {
          v = _ref9[_o];
          if (v.constructor.name === "Class_decl") {
            ti.class_prepare(v, ctx);
          }
        }
        _ref10 = root.list;
        for (_p = 0, _len7 = _ref10.length; _p < _len7; _p++) {
          v = _ref10[_p];
          ctx.walk(v, ctx_nest);
        }
        return null;
      case "Ret_multi":
        _ref11 = root.t_list;
        for (idx = _q = 0, _len8 = _ref11.length; _q < _len8; idx = ++_q) {
          v = _ref11[idx];
          v.type = ti.type_spread_left(v.type, ctx.parent_fn.type_o.nest_list[idx], ctx);
          expected = ctx.parent_fn.type_o.nest_list[idx];
          real = v.type;
          if (!expected.cmp(real)) {
            perr(root);
            perr("fn_type=" + ctx.parent_fn.type_o);
            perr(v);
            throw new Error("Ret_multi type mismatch [" + idx + "] expected=" + expected + " real=" + real + " @fn=" + ctx.parent_fn.name);
          }
          ctx.walk(v, ctx);
        }
        return null;
      case "Class_decl":
        ti.class_prepare(root, ctx);
        ctx_nest = ctx.mk_nest();
        ctx_nest.current_class = root;
        _ref12 = root._prepared_field2type;
        for (k in _ref12) {
          v = _ref12[k];
          ctx_nest.var_map[k] = v;
        }
        ctx.walk(root.scope, ctx_nest);
        return root.type;
      case "Fn_decl_multiret":
        complex_type = new Type("function2");
        complex_type.nest_list.push(root.type_i);
        complex_type.nest_list.push(root.type_o);
        ctx.var_map[root.name] = complex_type;
        ctx_nest = ctx.mk_nest();
        ctx_nest.parent_fn = root;
        _ref13 = root.arg_name_list;
        for (k = _r = 0, _len9 = _ref13.length; _r < _len9; k = ++_r) {
          name = _ref13[k];
          type = root.type_i.nest_list[k];
          ctx_nest.var_map[name] = type;
        }
        ctx.walk(root.scope, ctx_nest);
        return root.type;
      case "PM_switch":
        return null;
      case "If":
        ctx.walk(root.cond, ctx);
        ctx.walk(root.t, ctx.mk_nest());
        ctx.walk(root.f, ctx.mk_nest());
        return null;
      case "While":
        ctx.walk(root.cond, ctx.mk_nest());
        ctx.walk(root.scope, ctx.mk_nest());
        return null;
      case "Enum_decl":
        ctx.type_map[root.name] = root;
        _ref14 = root.value_list;
        for (_s = 0, _len10 = _ref14.length; _s < _len10; _s++) {
          decl = _ref14[_s];
          ctx.var_map[decl.name] = decl.type;
        }
        return new Type("enum");
      case "Type_cast":
        ctx.walk(root.t, ctx);
        return root.type;
      case "Ternary":
        ctx.walk(root.cond, ctx);
        t = ctx.walk(root.t, ctx);
        f = ctx.walk(root.f, ctx);
        root.t.type = ti.type_spread_left(root.t.type, root.f.type, ctx);
        root.f.type = ti.type_spread_left(root.f.type, root.t.type, ctx);
        root.type = ti.type_spread_left(root.type, root.t.type, ctx);
        return root.type;
      case "New":
        _ref15 = root.arg_list;
        for (_t = 0, _len11 = _ref15.length; _t < _len11; _t++) {
          arg = _ref15[_t];
          ctx.walk(arg, ctx);
        }
        return root.type;
      case "Tuple":
        _ref16 = root.list;
        for (_u = 0, _len12 = _ref16.length; _u < _len12; _u++) {
          v = _ref16[_u];
          ctx.walk(v, ctx);
        }
        nest_list = [];
        _ref17 = root.list;
        for (_v = 0, _len13 = _ref17.length; _v < _len13; _v++) {
          v = _ref17[_v];
          nest_list.push(v.type);
        }
        type = new Type("tuple<>");
        type.nest_list = nest_list;
        root.type = ti.type_spread_left(root.type, type, ctx);
        _ref18 = root.type.nest_list;
        for (idx = _w = 0, _len14 = _ref18.length; _w < _len14; idx = ++_w) {
          v = _ref18[idx];
          tuple_value = root.list[idx];
          tuple_value.type = ti.type_spread_left(tuple_value.type, v, ctx);
        }
        return root.type;
      case "Array_init":
        _ref19 = root.list;
        for (_x = 0, _len15 = _ref19.length; _x < _len15; _x++) {
          v = _ref19[_x];
          ctx.walk(v, ctx);
        }
        nest_type = null;
        if (root.type) {
          if (root.type.main !== "array") {
            throw new Error("Array_init can have only array type");
          }
          nest_type = root.type.nest_list[0];
        }
        _ref20 = root.list;
        for (_y = 0, _len16 = _ref20.length; _y < _len16; _y++) {
          v = _ref20[_y];
          nest_type = ti.type_spread_left(nest_type, v.type, ctx);
        }
        _ref21 = root.list;
        for (_z = 0, _len17 = _ref21.length; _z < _len17; _z++) {
          v = _ref21[_z];
          v.type = ti.type_spread_left(v.type, nest_type, ctx);
        }
        type = new Type("array<>");
        type.nest_list[0] = nest_type.clone();
        root.type = ti.type_spread_left(root.type, type, ctx);
        return root.type;
      case "Event_decl":
        return null;
      default:

        /* !pragma coverage-skip-block */
        perr(root);
        throw new Error("ti phase 1 unknown node '" + root.constructor.name + "'");
    }
  };

}).call(window.require_register("./type_inference/stage1"));
/*/lib/type_inference/stage2.js*/(function() {
  var Type, config, get_list_sign, ti;

  config = require("../config");

  Type = window.Type;

  ti = require("./common");

  get_list_sign = function(list) {
    var has_signed, has_unsigned, has_wtf, v, _i, _len;
    has_signed = false;
    has_unsigned = false;
    has_wtf = false;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      v = list[_i];
      if (config.int_type_map.hasOwnProperty(v)) {
        has_signed = true;
      } else if (config.uint_type_map.hasOwnProperty(v)) {
        has_unsigned = true;
      } else if (v === "number") {
        has_signed = true;
        has_unsigned = true;
      } else {
        has_wtf = true;
      }
    }
    if (has_wtf) {
      return null;
    }
    if (has_signed && has_unsigned) {
      return "number";
    }
    if (has_signed && !has_unsigned) {
      return "signed_number";
    }
    if (!has_signed && has_unsigned) {
      return "unsigned_number";
    }
    throw new Error("unreachable");
  };

  this.walk = function(root, ctx) {
    var a, a_type_list, b, b_type_list, bruteforce_a, bruteforce_b, bruteforce_ret, filter_found_list, found_list, list, new_type, ret, ret_type_list, tuple, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _s, _t;
    switch (root.constructor.name) {
      case "Var":
      case "Const":
      case "Field_access":
      case "Struct_init":
      case "Comment":
      case "Continue":
      case "Break":
      case "Var_decl":
      case "Var_decl_multi":
      case "Throw":
      case "Scope":
      case "Ret_multi":
      case "Class_decl":
      case "Fn_decl_multiret":
      case "PM_switch":
      case "If":
      case "While":
      case "Enum_decl":
      case "Type_cast":
      case "Ternary":
      case "New":
      case "Tuple":
      case "Event_decl":
      case "Fn_call":
      case "Array_init":
        return ctx.first_stage_walk(root, ctx);
      case "Bin_op":
        ctx.walk(root.a, ctx);
        ctx.walk(root.b, ctx);
        switch (root.op) {
          case "ASSIGN":
            root.a.type = ti.type_spread_left(root.a.type, root.b.type, ctx);
            root.b.type = ti.type_spread_left(root.b.type, root.a.type, ctx);
            root.type = ti.type_spread_left(root.type, root.a.type, ctx);
            root.a.type = ti.type_spread_left(root.a.type, root.type, ctx);
            root.b.type = ti.type_spread_left(root.b.type, root.type, ctx);
            return root.type;
          case "EQ":
          case "NE":
          case "GT":
          case "GTE":
          case "LT":
          case "LTE":
            root.type = ti.type_spread_left(root.type, new Type("bool"), ctx);
            root.a.type = ti.type_spread_left(root.a.type, root.b.type, ctx);
            root.b.type = ti.type_spread_left(root.b.type, root.a.type, ctx);
            return root.type;
          case "INDEX_ACCESS":
            switch ((_ref = root.a.type) != null ? _ref.main : void 0) {
              case "string":
                root.b.type = ti.type_spread_left(root.b.type, new Type("uint256"), ctx);
                root.type = ti.type_spread_left(root.type, new Type("string"), ctx);
                return root.type;
              case "map":
                root.b.type = ti.type_spread_left(root.b.type, root.a.type.nest_list[0], ctx);
                root.type = ti.type_spread_left(root.type, root.a.type.nest_list[1], ctx);
                return root.type;
              case "array":
                root.b.type = ti.type_spread_left(root.b.type, new Type("uint256"), ctx);
                root.type = ti.type_spread_left(root.type, root.a.type.nest_list[0], ctx);
                return root.type;
              default:
                if (config.bytes_type_map.hasOwnProperty((_ref1 = root.a.type) != null ? _ref1.main : void 0)) {
                  root.b.type = ti.type_spread_left(root.b.type, new Type("uint256"), ctx);
                  root.type = ti.type_spread_left(root.type, new Type("bytes1"), ctx);
                  return root.type;
                }
            }
        }
        bruteforce_a = ti.is_not_defined_type(root.a.type);
        bruteforce_b = ti.is_not_defined_type(root.b.type);
        bruteforce_ret = ti.is_not_defined_type(root.type);
        a = (root.a.type || "").toString();
        b = (root.b.type || "").toString();
        ret = (root.type || "").toString();
        if (!(list = ti.bin_op_ret_type_map_list[root.op])) {
          throw new Error("unknown bin_op " + root.op);
        }
        found_list = [];
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          tuple = list[_i];
          if (tuple[0] !== a && !bruteforce_a) {
            continue;
          }
          if (tuple[1] !== b && !bruteforce_b) {
            continue;
          }
          if (tuple[2] !== ret && !bruteforce_ret) {
            continue;
          }
          found_list.push(tuple);
        }
        if (ti.is_number_type(root.a.type)) {
          filter_found_list = [];
          for (_j = 0, _len1 = found_list.length; _j < _len1; _j++) {
            tuple = found_list[_j];
            if (!config.any_int_type_map.hasOwnProperty(tuple[0])) {
              continue;
            }
            filter_found_list.push(tuple);
          }
          found_list = filter_found_list;
        }
        if (ti.is_number_type(root.b.type)) {
          filter_found_list = [];
          for (_k = 0, _len2 = found_list.length; _k < _len2; _k++) {
            tuple = found_list[_k];
            if (!config.any_int_type_map.hasOwnProperty(tuple[1])) {
              continue;
            }
            filter_found_list.push(tuple);
          }
          found_list = filter_found_list;
        }
        if (ti.is_number_type(root.type)) {
          filter_found_list = [];
          for (_l = 0, _len3 = found_list.length; _l < _len3; _l++) {
            tuple = found_list[_l];
            if (!config.any_int_type_map.hasOwnProperty(tuple[2])) {
              continue;
            }
            filter_found_list.push(tuple);
          }
          found_list = filter_found_list;
        }
        if (found_list.length === 0) {
          throw new Error("type inference stuck bin_op " + root.op + " invalid a=" + a + " b=" + b + " ret=" + ret);
        } else if (found_list.length === 1) {
          _ref2 = found_list[0], a = _ref2[0], b = _ref2[1], ret = _ref2[2];
          root.a.type = ti.type_spread_left(root.a.type, new Type(a), ctx);
          root.b.type = ti.type_spread_left(root.b.type, new Type(b), ctx);
          root.type = ti.type_spread_left(root.type, new Type(ret), ctx);
        } else {
          if (bruteforce_a) {
            a_type_list = [];
            for (_m = 0, _len4 = found_list.length; _m < _len4; _m++) {
              tuple = found_list[_m];
              a_type_list.upush(tuple[0]);
            }
            if (a_type_list.length === 0) {
              perr("bruteforce stuck bin_op " + root.op + " caused a can't be any type");
            } else if (a_type_list.length === 1) {
              root.a.type = ti.type_spread_left(root.a.type, new Type(a_type_list[0]), ctx);
            } else {
              if (new_type = get_list_sign(a_type_list)) {
                root.a.type = ti.type_spread_left(root.a.type, new Type(new_type), ctx);
              }
            }
          }
          if (bruteforce_b) {
            b_type_list = [];
            for (_n = 0, _len5 = found_list.length; _n < _len5; _n++) {
              tuple = found_list[_n];
              b_type_list.upush(tuple[1]);
            }
            if (b_type_list.length === 0) {
              perr("bruteforce stuck bin_op " + root.op + " caused b can't be any type");
            } else if (b_type_list.length === 1) {
              root.b.type = ti.type_spread_left(root.b.type, new Type(b_type_list[0]), ctx);
            } else {
              if (new_type = get_list_sign(b_type_list)) {
                root.b.type = ti.type_spread_left(root.b.type, new Type(new_type), ctx);
              }
            }
          }
          if (bruteforce_ret) {
            ret_type_list = [];
            for (_o = 0, _len6 = found_list.length; _o < _len6; _o++) {
              tuple = found_list[_o];
              ret_type_list.upush(tuple[2]);
            }
            if (ret_type_list.length === 0) {
              perr("bruteforce stuck bin_op " + root.op + " caused ret can't be any type");
            } else if (ret_type_list.length === 1) {
              root.type = ti.type_spread_left(root.type, new Type(ret_type_list[0]), ctx);
            } else {
              if (new_type = get_list_sign(ret_type_list)) {
                root.type = ti.type_spread_left(root.type, new Type(new_type), ctx);
              }
            }
          }
        }
        return root.type;
      case "Un_op":
        ctx.walk(root.a, ctx);
        if (root.op === "DELETE") {
          if (root.a.constructor.name === "Bin_op") {
            if (root.a.op === "INDEX_ACCESS") {
              if (((_ref3 = root.a.a.type) != null ? _ref3.main : void 0) === "array") {
                return root.type;
              }
              if (((_ref4 = root.a.a.type) != null ? _ref4.main : void 0) === "map") {
                return root.type;
              }
            }
          }
        }
        bruteforce_a = ti.is_not_defined_type(root.a.type);
        bruteforce_ret = ti.is_not_defined_type(root.type);
        a = (root.a.type || "").toString();
        ret = (root.type || "").toString();
        if (!(list = ti.un_op_ret_type_map_list[root.op])) {
          throw new Error("unknown un_op " + root.op);
        }
        found_list = [];
        for (_p = 0, _len7 = list.length; _p < _len7; _p++) {
          tuple = list[_p];
          if (tuple[0] !== a && !bruteforce_a) {
            continue;
          }
          if (tuple[1] !== ret && !bruteforce_ret) {
            continue;
          }
          found_list.push(tuple);
        }
        if (ti.is_number_type(root.a.type)) {
          filter_found_list = [];
          for (_q = 0, _len8 = found_list.length; _q < _len8; _q++) {
            tuple = found_list[_q];
            if (!config.any_int_type_map.hasOwnProperty(tuple[0])) {
              continue;
            }
            filter_found_list.push(tuple);
          }
          found_list = filter_found_list;
        }
        if (ti.is_number_type(root.type)) {
          filter_found_list = [];
          for (_r = 0, _len9 = found_list.length; _r < _len9; _r++) {
            tuple = found_list[_r];
            if (!config.any_int_type_map.hasOwnProperty(tuple[1])) {
              continue;
            }
            filter_found_list.push(tuple);
          }
          found_list = filter_found_list;
        }
        if (found_list.length === 0) {
          throw new Error("type inference stuck un_op " + root.op + " invalid a=" + a + " ret=" + ret);
        } else if (found_list.length === 1) {
          _ref5 = found_list[0], a = _ref5[0], ret = _ref5[1];
          root.a.type = ti.type_spread_left(root.a.type, new Type(a), ctx);
          root.type = ti.type_spread_left(root.type, new Type(ret), ctx);
        } else {
          if (bruteforce_a) {
            a_type_list = [];
            for (_s = 0, _len10 = found_list.length; _s < _len10; _s++) {
              tuple = found_list[_s];
              a_type_list.upush(tuple[0]);
            }
            if (a_type_list.length === 0) {
              throw new Error("type inference bruteforce stuck un_op " + root.op + " caused a can't be any type");
            } else if (a_type_list.length === 1) {
              root.a.type = ti.type_spread_left(root.a.type, new Type(a_type_list[0]), ctx);
            } else {
              if (new_type = get_list_sign(a_type_list)) {
                root.a.type = ti.type_spread_left(root.a.type, new Type(new_type), ctx);
              }
            }
          }
          if (bruteforce_ret) {
            ret_type_list = [];
            for (_t = 0, _len11 = found_list.length; _t < _len11; _t++) {
              tuple = found_list[_t];
              ret_type_list.upush(tuple[1]);
            }
            if (ret_type_list.length === 0) {
              throw new Error("type inference bruteforce stuck un_op " + root.op + " caused ret can't be any type");
            } else if (ret_type_list.length === 1) {
              root.type = ti.type_spread_left(root.type, new Type(ret_type_list[0]), ctx);
            } else {
              if (new_type = get_list_sign(ret_type_list)) {
                root.type = ti.type_spread_left(root.type, new Type(new_type), ctx);
              }
            }
          }
        }
        return root.type;
      default:

        /* !pragma coverage-skip-block */
        perr(root);
        throw new Error("ti phase 2 unknown node '" + root.constructor.name + "'");
    }
  };

}).call(window.require_register("./type_inference/stage2"));
/*/lib/type_inference.js*/(function() {
  var Ti_context, stage1, stage2;

  Ti_context = require("./type_inference/common").Ti_context;

  stage1 = require("./type_inference/stage1");

  stage2 = require("./type_inference/stage2");

  this.gen = function(ast_tree, opt) {
    var ctx, i, _i;
    ctx = new Ti_context;
    ctx.walk = stage1.walk;
    stage1.walk(ast_tree, ctx);
    for (i = _i = 0; _i < 100; i = ++_i) {
      ctx = new Ti_context;
      ctx.first_stage_walk = stage1.walk;
      ctx.walk = stage2.walk;
      stage2.walk(ast_tree, ctx);
      if (ctx.change_count === 0) {
        break;
      }
    }
    return ast_tree;
  };

}).call(window.require_register("./type_inference"));
/*/lib/translate_ligo.js*/(function() {
  var Type, config, default_var_map_gen, last_bracket_state, module, number2bytes, some2nat, spec_id_translate, string2bytes, ti_map, translate_type, translate_var_name, type2default_value, type_generalize, walk, _ref;

  module = this;

  

  config = require("./config");

  Type = window.Type;

  _ref = require("./translate_var_name"), translate_var_name = _ref.translate_var_name, spec_id_translate = _ref.spec_id_translate;

  default_var_map_gen = require("./type_inference/common").default_var_map_gen;

  type_generalize = require("./type_generalize").type_generalize;

  ti_map = default_var_map_gen();

  ti_map["encodePacked"] = new Type("function2<function<bytes>,function<bytes>>");

  module.warning_counter = 0;

  walk = null;

  this.bin_op_name_map = {
    ADD: "+",
    MUL: "*",
    DIV: "/",
    EQ: "=",
    NE: "=/=",
    GT: ">",
    LT: "<",
    GTE: ">=",
    LTE: "<=",
    BOOL_AND: "and",
    BOOL_OR: "or"
  };

  string2bytes = function(val) {
    var ch, ret, _i, _len;
    ret = ["0x"];
    for (_i = 0, _len = val.length; _i < _len; _i++) {
      ch = val[_i];
      ret.push(ch.charCodeAt(0).rjust(2, "0"));
    }
    if (ret.length === 1) {
      return "(\"00\": bytes)";
    }
    return ret.join("");
  };

  some2nat = function(val, type) {
    if (config.int_type_map.hasOwnProperty(type)) {
      if (/^\d+$/.test(val)) {
        val = "" + val + "n";
      } else {
        val = "abs(" + val + ")";
      }
    }
    if (type.match(/^byte[s]?\d{0,2}$/)) {
      val = "(case (bytes_unpack (" + val + ") : option (nat)) of | Some(a) -> a | None -> 0n end)";
    }
    return val;
  };

  number2bytes = function(val, precision) {
    var hex, i, ret, _i;
    if (precision == null) {
      precision = 32;
    }
    ret = [];
    val = BigInt(val);
    for (i = _i = 0; 0 <= precision ? _i < precision : _i > precision; i = 0 <= precision ? ++_i : --_i) {
      hex = val & BigInt("0xFF");
      ret.push(hex.toString(16).rjust(2, "0"));
      val >>= BigInt(8);
    }
    ret.push("0x");
    ret.reverse();
    return ret.join("");
  };

  config.uint_type_map["unsigned_number"] = true;

  config.int_type_map["signed_number"] = true;

  this.bin_op_name_cb_map = {
    ASSIGN: function(a, b, ctx, ast) {
      if (config.bytes_type_map.hasOwnProperty(ast.a.type.main) && ast.b.type.main === "string" && ast.b.constructor.name === "Const") {
        b = string2bytes(ast.b.val);
      }
      return "" + a + " := " + b;
    },
    BIT_AND: function(a, b, ctx, ast) {
      var ret;
      a = some2nat(a, ast.a.type.main);
      b = some2nat(b, ast.b.type.main);
      ret = "Bitwise.and(" + a + ", " + b + ")";
      if (config.int_type_map.hasOwnProperty(ast.a.type.main) && config.int_type_map.hasOwnProperty(ast.b.type.main)) {
        return "int(" + ret + ")";
      } else {
        return ret;
      }
    },
    BIT_OR: function(a, b, ctx, ast) {
      var ret;
      a = some2nat(a, ast.a.type.main);
      b = some2nat(b, ast.b.type.main);
      ret = "Bitwise.or(" + a + ", " + b + ")";
      if (config.int_type_map.hasOwnProperty(ast.a.type.main) && config.int_type_map.hasOwnProperty(ast.b.type.main)) {
        return "int(" + ret + ")";
      } else {
        return ret;
      }
    },
    BIT_XOR: function(a, b, ctx, ast) {
      var ret;
      a = some2nat(a, ast.a.type.main);
      b = some2nat(b, ast.b.type.main);
      ret = "Bitwise.xor(" + a + ", " + b + ")";
      if (config.int_type_map.hasOwnProperty(ast.a.type.main) && config.int_type_map.hasOwnProperty(ast.b.type.main)) {
        return "int(" + ret + ")";
      } else {
        return ret;
      }
    },
    SHR: function(a, b, ctx, ast) {
      var ret;
      a = some2nat(a, ast.a.type.main);
      b = some2nat(b, ast.b.type.main);
      ret = "Bitwise.shift_right(" + a + ", " + b + ")";
      if (config.int_type_map.hasOwnProperty(ast.a.type.main) && config.int_type_map.hasOwnProperty(ast.b.type.main)) {
        return "int(" + ret + ")";
      } else {
        return ret;
      }
    },
    SHL: function(a, b, ctx, ast) {
      var ret;
      a = some2nat(a, ast.a.type.main);
      b = some2nat(b, ast.b.type.main);
      ret = "Bitwise.shift_left(" + a + ", " + b + ")";
      if (config.int_type_map.hasOwnProperty(ast.a.type.main) && config.int_type_map.hasOwnProperty(ast.b.type.main)) {
        return "int(" + ret + ")";
      } else {
        return ret;
      }
    },
    INDEX_ACCESS: function(a, b, ctx, ast) {
      var ret, val;
      return ret = ctx.lvalue ? "" + a + "[" + b + "]" : (val = type2default_value(ast.type, ctx), "(case " + a + "[" + b + "] of | None -> " + val + " | Some(x) -> x end)");
    },
    SUB: function(a, b, ctx, ast) {
      if (config.uint_type_map.hasOwnProperty(ast.a.type.main) && config.uint_type_map.hasOwnProperty(ast.b.type.main)) {
        return "abs(" + a + " - " + b + ")";
      } else {
        return "(" + a + " - " + b + ")";
      }
    },
    MOD: function(a, b, ctx, ast) {
      if (config.int_type_map.hasOwnProperty(ast.a.type.main) && config.int_type_map.hasOwnProperty(ast.b.type.main)) {
        return "int(" + a + " mod " + b + ")";
      } else {
        return "(" + a + " mod " + b + ")";
      }
    },
    POW: function(a, b, ctx, ast) {
      if (config.uint_type_map.hasOwnProperty(ast.a.type.main) && config.uint_type_map.hasOwnProperty(ast.b.type.main)) {
        return "pow(" + a + ", " + b + ")";
      } else {
        return "failwith('Exponentiation is only available for unsigned types. Here operands " + a + " and " + b + " have types " + ast.a.type.main + " and " + ast.a.type.main + "');";
      }
    }
  };

  this.un_op_name_cb_map = {
    MINUS: function(a) {
      return "-(" + a + ")";
    },
    PLUS: function(a) {
      return "+(" + a + ")";
    },
    BIT_NOT: function(a, ctx, ast) {
      if (!ast.type) {
        perr("WARNING (Translate). BIT_NOT ( ~" + a + " ) translation may be incorrect. Read more https://git.io/JUqiS");
        module.warning_counter++;
      }
      if (ast.type && config.uint_type_map.hasOwnProperty(ast.type.main)) {
        return "abs(not (" + a + "))";
      } else {
        return "not (" + a + ")";
      }
    },
    BOOL_NOT: function(a) {
      return "not (" + a + ")";
    },
    RET_INC: function(a, ctx, ast) {
      var is_uint, one;
      perr("WARNING (Translate). RET_INC may have not fully correct implementation. Read more https://git.io/JUqiS");
      module.warning_counter++;
      is_uint = config.uint_type_map.hasOwnProperty(ast.a.type.main);
      one = "1";
      if (is_uint) {
        one += "n";
      }
      ctx.sink_list.push("" + a + " := " + a + " + " + one);
      if (is_uint) {
        return ctx.trim_expr = "abs(" + a + " - " + one + ")";
      } else {
        return ctx.trim_expr = "(" + a + " - " + one + ")";
      }
    },
    RET_DEC: function(a, ctx, ast) {
      var is_uint, one;
      perr("WARNING (Translate). RET_DEC may have not fully correct implementation. Read more https://git.io/JUqiS");
      module.warning_counter++;
      is_uint = config.uint_type_map.hasOwnProperty(ast.a.type.main);
      one = "1";
      if (is_uint) {
        one += "n";
      }
      if (is_uint) {
        ctx.sink_list.push("" + a + " := abs(" + a + " - " + one + ")");
      } else {
        ctx.sink_list.push("" + a + " := " + a + " - " + one);
      }
      return ctx.trim_expr = "(" + a + " + " + one + ")";
    },
    INC_RET: function(a, ctx, ast) {
      var is_uint, one;
      perr("WARNING (Translate). INC_RET may have not fully correct implementation. Read more https://git.io/JUqiS");
      module.warning_counter++;
      is_uint = config.uint_type_map.hasOwnProperty(ast.a.type.main);
      one = "1";
      if (is_uint) {
        one += "n";
      }
      ctx.sink_list.push("" + a + " := " + a + " + " + one);
      return ctx.trim_expr = "" + a;
    },
    DEC_RET: function(a, ctx, ast) {
      var is_uint, one;
      perr("WARNING (Translate). DEC_RET may have not fully correct implementation. Read more https://git.io/JUqiS");
      module.warning_counter++;
      is_uint = config.uint_type_map.hasOwnProperty(ast.a.type.main);
      one = "1";
      if (is_uint) {
        one += "n";
      }
      if (is_uint) {
        ctx.sink_list.push("" + a + " := abs(" + a + " - " + one + ")");
      } else {
        ctx.sink_list.push("" + a + " := " + a + " - " + one);
      }
      return ctx.trim_expr = "" + a;
    },
    DELETE: function(a, ctx, ast) {
      var bin_op_a, bin_op_b, nest_ctx;
      if (ast.a.constructor.name !== "Bin_op") {
        throw new Error("can't compile DELETE operation for non 'delete a[b]' like construction. Reason not Bin_op");
      }
      if (ast.a.op !== "INDEX_ACCESS") {
        throw new Error("can't compile DELETE operation for non 'delete a[b]' like construction. Reason not INDEX_ACCESS");
      }
      nest_ctx = ctx.mk_nest();
      bin_op_a = walk(ast.a.a, nest_ctx);
      bin_op_b = walk(ast.a.b, nest_ctx);
      return "remove " + bin_op_b + " from map " + bin_op_a;
    }
  };

  this.translate_type = translate_type = function(type, ctx) {
    var is_struct, key, list, name, nest, translated_type, type_list, v, value, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
    switch (type.main) {
      case "bool":
        return "bool";
      case "Unit":
        return "Unit";
      case "string":
        return "string";
      case "address":
        return "address";
      case "timestamp":
        return "timestamp";
      case "operation":
        return "operation";
      case "built_in_op_list":
        return "list(operation)";
      case "list":
        nest = translate_type(type.nest_list[0], ctx);
        return "list(" + nest + ")";
      case "array":
        nest = translate_type(type.nest_list[0], ctx);
        return "map(nat, " + nest + ")";
      case "tuple":
        list = [];
        _ref1 = type.nest_list;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          v = _ref1[_i];
          list.push(translate_type(v, ctx));
        }
        if (list.length === 0) {
          return "unit";
        } else {
          return "(" + (list.join(' * ')) + ")";
        }
        break;
      case "map":
        key = translate_type(type.nest_list[0], ctx);
        value = translate_type(type.nest_list[1], ctx);
        return "map(" + key + ", " + value + ")";
      case config.storage:
        return config.storage;
      case "contract":
        if (type.val) {
          return "contract(" + type.val + ")";
        } else {
          type_list = [];
          _ref2 = type.nest_list;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            type = _ref2[_j];
            translated_type = translate_type(type, ctx);
            type_list.push(translated_type);
          }
          return "contract(" + (type_list.join(", ")) + ")";
        }
        break;
      default:
        if ((_ref3 = ctx.type_decl_map) != null ? _ref3.hasOwnProperty(type.main) : void 0) {
          name = type.main.replace(/\./g, "_");
          is_struct = ((ctx.current_class && ctx.type_decl_map["" + ctx.current_class.name + "_" + name]) || ctx.type_decl_map[name]) && ((_ref4 = ctx.type_decl_map[name]) != null ? _ref4.constructor.name : void 0) === "Class_decl";
          if (ctx.current_class && is_struct) {
            name = "" + ctx.current_class.name + "_" + name;
          }
          name = translate_var_name(name, ctx);
          return name;
        } else if (type.main.match(/^byte[s]?\d{0,2}$/)) {
          return "bytes";
        } else if (config.uint_type_map.hasOwnProperty(type.main)) {
          return "nat";
        } else if (config.int_type_map.hasOwnProperty(type.main)) {
          return "int";
        } else if (type.main.match(RegExp("^" + config.storage + "_"))) {
          return type.main;
        } else if (type.main.startsWith("@")) {
          return type.main.substr(1);
        } else {
          perr("WARNING (Translate). translate_type unknown solidity type '" + type + "'");
          return "UNKNOWN_TYPE_" + type;
        }
    }
  };

  this.type2default_value = type2default_value = function(type, ctx) {
    var first_item, name, prefix, t, _ref1;
    if (config.uint_type_map.hasOwnProperty(type.main)) {
      return "0n";
    }
    if (config.int_type_map.hasOwnProperty(type.main)) {
      return "0";
    }
    if (config.bytes_type_map.hasOwnProperty(type.main)) {
      return "(\"00\": bytes)";
    }
    switch (type.main) {
      case "bool":
        return "False";
      case "address":
        if (!ctx.parent) {
          return "(" + (JSON.stringify(config.burn_address)) + " : address)";
        } else {
          return "burn_address";
        }
        break;
      case "built_in_op_list":
        return "(nil: list(operation))";
      case "contract":
        return "contract(unit)";
      case "map":
      case "array":
        return "(map end : " + (translate_type(type, ctx)) + ")";
      case "string":
        return '""';
      default:
        if (ctx.type_decl_map.hasOwnProperty(type.main)) {
          t = ctx.type_decl_map[type.main];
          if (t.constructor.name === "Enum_decl") {
            first_item = t.value_list[0].name;
            if (ctx.current_class.name) {
              prefix = "";
              if (ctx.current_class.name) {
                prefix = "" + ctx.current_class.name + "_";
              }
              return "" + name + "_" + first_item;
            } else {
              return "" + name + "(unit)";
            }
          }
          if (t.constructor.name === "Class_decl") {
            name = type.main;
            if ((_ref1 = ctx.current_class) != null ? _ref1.name : void 0) {
              name = "" + ctx.current_class.name + "_" + type.main;
            }
            return translate_var_name("" + name + "_default", ctx);
          }
        }
        perr("WARNING (Translate). Can't translate unknown Solidity type '" + type + "'");
        return "UNKNOWN_TYPE_DEFAULT_VALUE_" + type;
    }
  };

  this.Gen_context = (function() {
    Gen_context.prototype.parent = null;

    Gen_context.prototype.next_gen = null;

    Gen_context.prototype.current_class = null;

    Gen_context.prototype.is_class_scope = false;

    Gen_context.prototype.lvalue = false;

    Gen_context.prototype.type_decl_map = {};

    Gen_context.prototype.contract_var_map = {};

    Gen_context.prototype.contract = false;

    Gen_context.prototype.trim_expr = "";

    Gen_context.prototype.terminate_expr_check = "";

    Gen_context.prototype.terminate_expr_replace_fn = null;

    Gen_context.prototype.sink_list = [];

    Gen_context.prototype.tmp_idx = 0;

    Gen_context.prototype.storage_sink_list = {};

    Gen_context.prototype.type_decl_sink_list = [];

    Gen_context.prototype.structs_default_list = [];

    Gen_context.prototype.enum_list = [];

    Gen_context.prototype.files = null;

    Gen_context.prototype.keep_dir_structure = false;

    Gen_context.prototype.scope_root = null;

    function Gen_context() {
      this.type_decl_map = {};
      this.contract_var_map = {};
      this.storage_sink_list = {};
      this.sink_list = [];
      this.type_decl_sink_list = [];
      this.structs_default_list = [];
      this.enum_list = [];
      this.contract = false;
      this.files = null;
      this.keep_dir_structure = false;
    }

    Gen_context.prototype.mk_nest = function() {
      var t;
      t = new module.Gen_context;
      t.parent = this;
      t.current_class = this.current_class;
      obj_set(t.contract_var_map, this.contract_var_map);
      obj_set(t.type_decl_map, this.type_decl_map);
      t.type_decl_sink_list = this.type_decl_sink_list;
      t.structs_default_list = this.structs_default_list;
      t.enum_list = this.enum_list;
      t.contract = this.contract;
      t.files = this.files;
      t.keep_dir_structure = this.keep_dir_structure;
      t.scope_root = this.scope_root;
      return t;
    };

    return Gen_context;

  })();

  last_bracket_state = false;

  walk = function(root, ctx) {
    var a, arg, arg_jl, arg_list, arg_num, args, aux, body, call_expr, case_scope, cb, chk_ret, code, cond, ctx_lvalue, decl, decls, entry, f, field_access_translation, field_decl_jl, fn, get_tmp, i, idx, jl, jls, k, loc_code, main_file, main_file_unshift_list, modifies_storage, msg, name, old_scope_root, op, orig_ctx, path, prefix, ret, ret_jl, ret_types_list, returns_op_list, returns_value, scope, shift_self, state_name, str, t, target_type, text, tmp_var, translated_type, type, type_decl, type_decl_jl, type_list, type_o, type_str, uses_storage, v, val, _a, _aa, _ab, _ac, _ad, _ae, _af, _ag, _ah, _ai, _b, _base, _case, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len12, _len13, _len14, _len15, _len16, _len17, _len18, _len19, _len2, _len20, _len21, _len22, _len23, _len24, _len25, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref27, _ref28, _ref29, _ref3, _ref30, _ref31, _ref32, _ref33, _ref34, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u, _v, _var, _w, _x, _y, _z;
    main_file = "";
    last_bracket_state = false;
    switch (root.constructor.name) {
      case "Scope":
        switch (root.original_node_type) {
          case "SourceUnit":
            jls = {};
            jls[main_file] = [];
            main_file_unshift_list = [];
            _ref1 = root.list;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              v = _ref1[_i];
              code = walk(v, ctx);
              path = ctx.keep_dir_structure ? v.file : null;
              if (path == null) {
                path = main_file;
              }
              if (code) {
                if ((_ref2 = v.constructor.name) !== "Comment" && _ref2 !== "Scope" && _ref2 !== "Include") {
                  if (!/;$/.test(code)) {
                    code += ";";
                  }
                  if ((_ref3 = v.name) === "burn_address" || _ref3 === "pow") {
                    code += "\n";
                    main_file_unshift_list.push(code);
                    continue;
                  }
                }
                if (jls[path] == null) {
                  jls[path] = [];
                }
                jls[path].push(code);
              }
            }
            if (ctx.structs_default_list.length) {
              jls[main_file].unshift("" + (join_list(ctx.structs_default_list)));
            }
            name = config.storage;
            while ((v = main_file_unshift_list.pop()) != null) {
              jls[main_file].unshift(v);
            }
            jls[main_file].unshift("");
            if (Object.keys(ctx.storage_sink_list).length === 0) {
              jls[main_file].unshift("type " + name + " is unit;");
            } else {
              _ref4 = ctx.storage_sink_list;
              for (k in _ref4) {
                v = _ref4[k];
                if (v.length === 0) {
                  jls[main_file].unshift("type " + k + " is unit;");
                } else {
                  jls[main_file].unshift("type " + k + " is record\n  " + (join_list(v, '  ')) + "\nend;");
                }
              }
            }
            ctx.storage_sink_list = {};
            if (ctx.type_decl_sink_list.length) {
              type_decl_jl = [];
              _ref5 = ctx.type_decl_sink_list;
              for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
                type_decl = _ref5[_j];
                name = type_decl.name, field_decl_jl = type_decl.field_decl_jl;
                if (field_decl_jl.length === 0) {
                  type_decl_jl.push("type " + name + " is unit;");
                } else {
                  type_decl_jl.push("type " + name + " is record\n  " + (join_list(field_decl_jl, '  ')) + "\nend;\n");
                }
              }
              jls[main_file].unshift("" + (join_list(type_decl_jl)));
              if (ctx.enum_list.length) {
                jls[main_file].unshift("");
                jls[main_file].unshift("" + (join_list(ctx.enum_list)));
                ctx.enum_list = [];
              }
            }
            for (path in jls) {
              jl = jls[path];
              ctx.files[path] = join_list(jl, "");
            }
            return ctx.files[main_file];
          default:
            if (!root.original_node_type) {
              jls = {};
              jls[main_file] = [];
              _ref6 = root.list;
              for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
                v = _ref6[_k];
                path = ctx.keep_dir_structure ? v.file : null;
                if (path == null) {
                  path = main_file;
                }
                if (jls[path] == null) {
                  jls[path] = [];
                }
                code = walk(v, ctx);
                _ref7 = ctx.sink_list;
                for (_l = 0, _len3 = _ref7.length; _l < _len3; _l++) {
                  loc_code = _ref7[_l];
                  if (!/;$/.test(loc_code)) {
                    loc_code += ";";
                  }
                  jls[path].push(loc_code);
                }
                ctx.sink_list.clear();
                if (ctx.trim_expr === code) {
                  ctx.trim_expr = "";
                  continue;
                }
                if (ctx.terminate_expr_check === code) {
                  ctx.terminate_expr_check = "";
                  code = ctx.terminate_expr_replace_fn();
                }
                if (code) {
                  if ((_ref8 = v.constructor.name) !== "Comment" && _ref8 !== "Scope" && _ref8 !== "Include") {
                    if (!/;$/.test(code)) {
                      code += ";";
                    }
                  }
                  jls[path].push(code);
                }
              }
              for (path in jls) {
                jl = jls[path];
                ret = jl.pop() || "";
                if (!ret.startsWith("with")) {
                  jl.push(ret);
                  ret = "";
                }
                jl = jl.filter(function(t) {
                  return t !== "";
                });
                if (!root.need_nest) {
                  if (jl.length) {
                    body = join_list(jl, "");
                  } else {
                    body = "";
                  }
                  ret = "";
                } else {
                  if (jl.length) {
                    body = "block {\n  " + (join_list(jl, '  ')) + "\n}";
                  } else {
                    body = "block {\n  skip\n}";
                  }
                }
                if (ret) {
                  ret = " " + ret;
                }
                code = "" + body + ret;
                ctx.files[path] = code;
              }
              return ctx.files[main_file];
            } else {
              puts(root);
              throw new Error("Unknown root.original_node_type " + root.original_node_type);
            }
        }
        break;
      case "Var":
        name = root.name;
        if (name === "this" || name === "super") {
          return "";
        }
        if (ctx.contract_var_map.hasOwnProperty(name)) {
          return "" + config.contract_storage + "." + name;
        } else {
          return name;
        }
        break;
      case "Const":
        if (!root.type) {
          puts(root);
          throw new Error("Can't type inference");
        }
        if (config.uint_type_map.hasOwnProperty(root.type.main)) {
          return "" + root.val + "n";
        }
        switch (root.type.main) {
          case "bool":
            switch (root.val) {
              case "true":
                return "True";
              case "false":
                return "False";
              default:
                throw new Error("can't translate bool constant '" + root.val + "'");
            }
            break;
          case "Unit":
            return "unit";
          case "number":
            perr("WARNING (Translate). Number constant passed to the translation stage. That's a type inference mistake");
            module.warning_counter++;
            return root.val;
          case "unsigned_number":
            return "" + root.val + "n";
          case "mutez":
            return "" + root.val + "mutez";
          case "string":
            return JSON.stringify(root.val);
          case "built_in_op_list":
            if (root.val) {
              return "" + root.val;
            } else {
              return "(nil: list(operation))";
            }
            break;
          default:
            if (config.bytes_type_map.hasOwnProperty(root.type.main)) {
              return number2bytes(root.val, +root.type.main.replace(/bytes/, ''));
            } else {
              return root.val;
            }
        }
        break;
      case "Bin_op":
        ctx_lvalue = ctx.mk_nest();
        if (0 === root.op.indexOf("ASS")) {
          ctx_lvalue.lvalue = true;
        }
        _a = walk(root.a, ctx_lvalue);
        ctx.sink_list.append(ctx_lvalue.sink_list);
        _b = walk(root.b, ctx);
        return ret = (function() {
          if (op = module.bin_op_name_map[root.op]) {
            last_bracket_state = true;
            if (((root.a.type && root.a.type.main === 'bool') || (root.b.type && root.b.type.main === 'bool')) && (op === '>=' || op === '=/=' || op === '<=' || op === '>' || op === '<' || op === '=')) {
              switch (op) {
                case "=":
                  return "(" + _a + " = " + _b + ")";
                case "=/=":
                  return "(" + _a + " =/= " + _b + ")";
                case ">":
                  return "(" + _a + " and not " + _b + ")";
                case "<":
                  return "((not " + _a + ") and " + _b + ")";
                case ">=":
                  return "(" + _a + " or not " + _b + ")";
                case "<=":
                  return "((not " + _a + ") or " + _b + ")";
                default:
                  return "(" + _a + " " + op + " " + _b + ")";
              }
            } else {
              return "(" + _a + " " + op + " " + _b + ")";
            }
          } else if (cb = module.bin_op_name_cb_map[root.op]) {
            return cb(_a, _b, ctx, root);
          } else {
            throw new Error("Unknown/unimplemented bin_op " + root.op);
          }
        })();
      case "Un_op":
        a = walk(root.a, ctx);
        if (cb = module.un_op_name_cb_map[root.op]) {
          return cb(a, ctx, root);
        } else {
          throw new Error("Unknown/unimplemented un_op " + root.op);
        }
        break;
      case "Field_access":
        t = walk(root.t, ctx);
        if (!root.t.type) {
          perr("WARNING (Translate). Some of types in Field_access aren't resolved. This can cause invalid code generated");
        } else {
          switch (root.t.type.main) {
            case "array":
              switch (root.name) {
                case "length":
                  return "size(" + t + ")";
                default:
                  throw new Error("unknown array field " + root.name);
              }
              break;
            case "bytes":
              switch (root.name) {
                case "length":
                  return "size(" + t + ")";
                default:
                  throw new Error("unknown array field " + root.name);
              }
              break;
            case "enum":
              return root.name;
          }
        }
        if (t === "") {
          return root.name;
        }
        chk_ret = "" + t + "." + root.name;
        ret = "" + t + "." + root.name;
        if (root.t.constructor.name === "Var") {
          if ((_ref9 = ctx.type_decl_map[root.t.name]) != null ? _ref9.is_library : void 0) {
            ret = translate_var_name("" + t + "_" + root.name, ctx);
          }
        }
        return spec_id_translate(chk_ret, ret);
      case "Fn_call":
        arg_list = [];
        _ref10 = root.arg_list;
        for (_m = 0, _len4 = _ref10.length; _m < _len4; _m++) {
          v = _ref10[_m];
          arg_list.push(walk(v, ctx));
        }
        field_access_translation = null;
        if (root.fn.constructor.name === "Field_access") {
          field_access_translation = walk(root.fn.t, ctx);
          if (root.fn.t.type) {
            switch (root.fn.t.type.main) {
              case "array":
                switch (root.fn.name) {
                  case "push":
                    tmp_var = "tmp_" + (ctx.tmp_idx++);
                    ctx.sink_list.push("const " + tmp_var + " : " + (translate_type(root.fn.t.type, ctx)) + " = " + field_access_translation + ";");
                    return "" + tmp_var + "[size(" + tmp_var + ")] := " + arg_list[0];
                  default:
                    throw new Error("unknown array field function " + root.fn.name);
                }
            }
          }
        }
        if (root.fn.constructor.name === "Var") {
          switch (root.fn.name) {
            case "require":
            case "assert":
            case "require2":
              cond = arg_list[0];
              str = arg_list[1];
              if (str) {
                return "assert(" + cond + ") (* " + str + " *)";
              } else {
                return "assert(" + cond + ")";
              }
              break;
            case "revert":
              str = arg_list[0] || '"revert"';
              return "failwith(" + str + ")";
            case "sha256":
              msg = arg_list[0];
              return "sha_256(" + msg + ")";
            case "sha3":
            case "keccak256":
              perr("WARNING (Translate). " + root.fn.name + " hash function will be translated as sha_256. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#hash-functions");
              msg = arg_list[0];
              return "sha_256(" + msg + ")";
            case "selfdestruct":
              perr("WARNING (Translate). " + root.fn.name + " does not exist in LIGO. Statement translated as is");
              msg = arg_list[0];
              return "selfdestruct(" + msg + ") (* unsupported *)";
            case "blockhash":
              msg = arg_list[0];
              perr("WARNING (Translate). " + root.fn.name + " does not exist in LIGO. We replaced it with (\"" + msg + "\" : bytes).");
              return "(\"00\" : bytes) (* Should be blockhash of " + msg + " *)";
            case "ripemd160":
              perr("WARNING (Translate). " + root.fn.name + " hash function will be translated as blake2b. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#hash-functions");
              msg = arg_list[0];
              return "blake2b(" + msg + ")";
            case "ecrecover":
              perr("WARNING (Translate). ecrecover function does not exist in LIGO. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#ecrecover");
              fn = "ecrecover";
              break;
            case "@respond":
              type_list = [];
              _ref11 = root.arg_list;
              for (_n = 0, _len5 = _ref11.length; _n < _len5; _n++) {
                v = _ref11[_n];
                type_list.push(translate_type(v.type, ctx));
              }
              type_str = type_list.join(" * ");
              return "var " + config.op_list + " : list(operation) := list transaction((" + (arg_list.join(' * ')) + "), 0mutez, (get_contract(match_action." + config.callback_address + ") : contract(" + type_str + "))) end";
            case "@respond_append":
              type_list = [];
              _ref12 = root.arg_list;
              for (_o = 0, _len6 = _ref12.length; _o < _len6; _o++) {
                v = _ref12[_o];
                type_list.push(translate_type(v.type, ctx));
              }
              type_str = type_list.join(" * ");
              return "var " + config.op_list + " : list(operation) := cons(" + arg_list[0] + ", list transaction((" + (arg_list.slice(1).join(' * ')) + "), 0mutez, (get_contract(match_action." + config.callback_address + ") : contract(" + type_str + "))) end)";
            default:
              fn = root.fn.name;
          }
        } else {
          fn = walk(root.fn, ctx);
        }
        if (arg_list.length === 0) {
          arg_list.push("unit");
        }
        call_expr = "" + fn + "(" + (arg_list.join(', ')) + ")";
        if (!root.left_unpack || (fn === "get_contract" || fn === "transaction")) {
          return call_expr;
        } else {
          if (root.fn_decl) {
            _ref13 = root.fn_decl, returns_op_list = _ref13.returns_op_list, uses_storage = _ref13.uses_storage, modifies_storage = _ref13.modifies_storage, returns_value = _ref13.returns_value;
            type_o = root.fn_decl.type_o;
            if (root.is_fn_decl_from_using) {
              if (uses_storage) {
                shift_self = arg_list.shift();
              }
              arg_list.unshift(field_access_translation);
              if (uses_storage) {
                arg_list.unshift(shift_self);
              }
              call_expr = "" + root.fn_name_using + "(" + (arg_list.join(', ')) + ")";
            }
          } else if (type_decl = ti_map[root.fn.name]) {
            returns_op_list = false;
            modifies_storage = false;
            returns_value = type_decl.nest_list[1].nest_list.length > 0;
            type_o = type_decl.nest_list[1];
          } else if (ctx.contract_var_map.hasOwnProperty(root.fn.name)) {
            decl = ctx.contract_var_map[root.fn.name];
            if (decl.constructor.name === "Fn_decl_multiret") {
              return call_expr;
            }
            return "" + config.contract_storage + "." + root.fn.name;
          } else {
            perr("WARNING (Translate). !root.fn_decl " + root.fn.name);
            return call_expr;
          }
          ret_types_list = [];
          _ref14 = type_o.nest_list;
          for (_p = 0, _len7 = _ref14.length; _p < _len7; _p++) {
            v = _ref14[_p];
            ret_types_list.push(translate_type(v, ctx));
          }
          if (ret_types_list.length === 0) {
            return call_expr;
          } else if (ret_types_list.length === 1 && returns_value) {
            ctx.terminate_expr_replace_fn = function() {
              perr("WARNING (Translate). " + call_expr + " was terminated with dummy variable declaration");
              tmp_var = "terminate_tmp_" + (ctx.tmp_idx++);
              return "const " + tmp_var + " : (" + (ret_types_list.join(' * ')) + ") = " + call_expr;
            };
            return ctx.terminate_expr_check = call_expr;
          } else {
            if (ret_types_list.length === 1) {
              if (returns_op_list) {
                return "" + config.op_list + " := " + call_expr;
              } else if (modifies_storage) {
                return "" + config.contract_storage + " := " + call_expr;
              } else {
                throw new Error("WTF !returns_op_list !modifies_storage");
              }
            } else {
              tmp_var = "tmp_" + (ctx.tmp_idx++);
              ctx.sink_list.push("const " + tmp_var + " : (" + (ret_types_list.join(' * ')) + ") = " + call_expr);
              arg_num = 0;
              get_tmp = function() {
                if (ret_types_list.length === 1) {
                  return tmp_var;
                } else {
                  return "" + tmp_var + "." + (arg_num++);
                }
              };
              if (returns_op_list) {
                ctx.sink_list.push("" + config.op_list + " := " + (get_tmp()));
              }
              if (modifies_storage) {
                ctx.sink_list.push("" + config.contract_storage + " := " + (get_tmp()));
              }
              return ctx.trim_expr = get_tmp();
            }
          }
        }
        break;
      case "Struct_init":
        arg_list = [];
        for (i = _q = 0, _ref15 = root.val_list.length - 1; 0 <= _ref15 ? _q <= _ref15 : _q >= _ref15; i = 0 <= _ref15 ? ++_q : --_q) {
          arg_list.push("" + root.arg_names[i] + " = " + (walk(root.val_list[i], ctx)));
        }
        return "record [ " + (arg_list.join(";\n  ")) + " ]";
      case "Type_cast":
        target_type = translate_type(root.target_type, ctx);
        t = walk(root.t, ctx);
        if (t === "" && target_type === "address") {
          return "self_address";
        }
        if (target_type === "int") {
          return "int(abs(" + t + "))";
        } else if (target_type === "nat") {
          return "abs(" + t + ")";
        } else if (target_type === "bytes" && ((_ref16 = root.t.type) != null ? _ref16.main : void 0) === "string") {
          return "bytes_pack(" + t + ")";
        } else if (target_type === "address") {
          if (+t === 0) {
            return "burn_address";
          } else if (root.t.constructor.name === "Const") {
            root.t.type = new Type("string");
            t = walk(root.t, ctx);
            return "(" + t + " : " + target_type + ")";
          } else {
            return "(" + t + " : " + target_type + ")";
          }
        } else {
          return "(" + t + " : " + target_type + ")";
        }
        break;
      case "Comment":
        if (ctx.keep_dir_structure && root.text.startsWith("#include")) {
          text = root.text.replace(".sol", ".ligo");
          return text;
        } else if (root.can_skip) {
          return "";
        } else {
          return "(* " + root.text + " *)";
        }
        break;
      case "Continue":
        return "(* `continue` statement is not supported in LIGO *)";
      case "Break":
        return "(* `break` statement is not supported in LIGO *)";
      case "Var_decl":
        name = root.name;
        type = translate_type(root.type, ctx);
        if (ctx.is_class_scope && !root.is_const) {
          if (root.special_type) {
            type = "" + ctx.current_class.name + "_" + root.type.main;
          }
          type = translate_var_name(type, ctx);
          ctx.contract_var_map[name] = root;
          return "" + name + " : " + type + ";";
        } else {
          if (root.assign_value) {
            if (((_ref17 = root.assign_value) != null ? _ref17.constructor.name : void 0) === "Struct_init") {
              type = "" + ctx.current_class.name + "_" + root.type.main;
              type = translate_var_name(type, ctx);
            }
            val = walk(root.assign_value, ctx);
            if (config.bytes_type_map.hasOwnProperty(root.type.main) && root.assign_value.type.main === "string" && root.assign_value.constructor.name === "Const") {
              val = string2bytes(root.assign_value.val);
            }
            if (config.bytes_type_map.hasOwnProperty(root.type.main) && root.assign_value.type.main === "number" && root.assign_value.constructor.name === "Const") {
              val = number2bytes(root.assign_value.val);
            }
            return "const " + name + " : " + type + " = " + val;
          } else {
            return "const " + name + " : " + type + " = " + (type2default_value(root.type, ctx));
          }
        }
        break;
      case "Var_decl_multi":
        if (root.assign_value) {
          val = walk(root.assign_value, ctx);
          tmp_var = "tmp_" + (ctx.tmp_idx++);
          jl = [];
          type_list = [];
          _ref18 = root.list;
          for (idx = _r = 0, _len8 = _ref18.length; _r < _len8; idx = ++_r) {
            _var = _ref18[idx];
            name = _var.name;
            type_list.push(type = translate_type(_var.type, ctx));
            jl.push("const " + name + " : " + type + " = " + tmp_var + "." + idx + ";");
          }
          return "const " + tmp_var + " : (" + (type_list.join(' * ')) + ") = " + val + ";\n" + (join_list(jl));
        } else {
          perr("WARNING (Translate). Var_decl_multi with no assign value should be unreachable, but something went wrong");
          module.warning_counter++;
          jl = [];
          _ref19 = root.list;
          for (_s = 0, _len9 = _ref19.length; _s < _len9; _s++) {
            _var = _ref19[_s];
            name = _var.name;
            type = translate_type(root.type, ctx);
            jl.push("const " + name + " : " + type + " = " + (type2default_value(_var.type, ctx)));
          }
          return jl.join("\n");
        }
        break;
      case "Throw":
        if (root.t) {
          t = walk(root.t, ctx);
          return "failwith(" + t + ")";
        } else {
          return 'failwith("throw")';
        }
        break;
      case "Ret_multi":
        jl = [];
        _ref20 = root.t_list;
        for (idx = _t = 0, _len10 = _ref20.length; _t < _len10; idx = ++_t) {
          v = _ref20[idx];
          jl.push(walk(v, ctx));
        }
        if (ctx.scope_root.constructor.name === "Fn_decl_multiret") {
          if (ctx.scope_root.name !== "main") {
            _ref21 = ctx.scope_root.type_o.nest_list;
            for (idx = _u = 0, _len11 = _ref21.length; _u < _len11; idx = ++_u) {
              type = _ref21[idx];
              if (!root.t_list[idx]) {
                jl.push(type2default_value(type, ctx));
              }
            }
          }
          if (jl.length === 0) {
            jl.push("unit");
          }
          return "with (" + (jl.join(', ')) + ")";
        } else {
          perr("WARNING (Translate). Return at non end-of-function position is prohibited");
          return "failwith(\"return at non end-of-function position is prohibited\")";
        }
        break;
      case "If":
        cond = walk(root.cond, ctx);
        if (!last_bracket_state) {
          cond = "(" + cond + ")";
        }
        old_scope_root = ctx.scope_root;
        ctx.scope_root = root;
        t = walk(root.t, ctx);
        f = walk(root.f, ctx);
        ctx.scope_root = old_scope_root;
        return "if " + cond + " then " + t + " else " + f + ";";
      case "While":
        cond = walk(root.cond, ctx);
        if (!last_bracket_state) {
          cond = "(" + cond + ")";
        }
        old_scope_root = ctx.scope_root;
        ctx.scope_root = root;
        scope = walk(root.scope, ctx);
        ctx.scope_root = old_scope_root;
        return "while " + cond + " " + scope + ";";
      case "PM_switch":
        cond = walk(root.cond, ctx);
        ctx = ctx.mk_nest();
        jl = [];
        _ref22 = root.scope.list;
        for (_v = 0, _len12 = _ref22.length; _v < _len12; _v++) {
          _case = _ref22[_v];
          case_scope = walk(_case.scope, ctx);
          if (/;$/.test(case_scope)) {
            case_scope = case_scope.slice(0, -1);
          }
          jl.push("| " + _case.struct_name + "(" + _case.var_decl.name + ") -> " + case_scope);
        }
        if (jl.length) {
          return "case " + cond + " of\n" + (join_list(jl, '')) + "\nend";
        } else {
          return "unit";
        }
        break;
      case "Fn_decl_multiret":
        if (root.name === "pow") {
          return "function pow (const base : nat; const exp : nat) : nat is\n  block {\n    var b : nat := base;\n    var e : nat := exp;\n    var r : nat := 1n;\n    while e > 0n block {\n      if e mod 2n = 1n then {\n        r := r * b;\n      } else skip;\n      b := b * b;\n      e := e / 2n;\n    }\n  } with r;";
        }
        orig_ctx = ctx;
        ctx = ctx.mk_nest();
        arg_jl = [];
        _ref23 = root.arg_name_list;
        for (idx = _w = 0, _len13 = _ref23.length; _w < _len13; idx = ++_w) {
          v = _ref23[idx];
          type = translate_type(root.type_i.nest_list[idx], ctx);
          arg_jl.push("const " + v + " : " + type);
        }
        if (arg_jl.length === 0) {
          arg_jl.push("const " + config.reserved + "__unit : unit");
        }
        ret_jl = [];
        _ref24 = root.type_o.nest_list;
        for (_x = 0, _len14 = _ref24.length; _x < _len14; _x++) {
          v = _ref24[_x];
          type = translate_type(v, ctx);
          ret_jl.push("" + type);
        }
        if (ret_jl.length === 0) {
          ret_jl.push("unit");
        }
        ctx.scope_root = root;
        body = walk(root.scope, ctx);
        return "function " + root.name + " (" + (arg_jl.join('; ')) + ") : (" + (ret_jl.join(' * ')) + ") is\n  " + (make_tab(body, '  '));
      case "Class_decl":
        if (root.need_skip) {
          return "";
        }
        if (root.is_interface) {
          return "";
        }
        if (root.is_contract && !root.is_last) {
          return "";
        }
        orig_ctx = ctx;
        prefix = "";
        if (ctx.parent && ctx.current_class && root.namespace_name) {
          ctx.parent.type_decl_map["" + ctx.current_class.name + "." + root.name] = root;
          prefix = ctx.current_class.name;
        }
        ctx.type_decl_map[root.name] = root;
        ctx = ctx.mk_nest();
        ctx.current_class = root;
        ctx.is_class_scope = true;
        _ref25 = root.scope.list;
        for (_y = 0, _len15 = _ref25.length; _y < _len15; _y++) {
          v = _ref25[_y];
          switch (v.constructor.name) {
            case "Enum_decl":
            case "Class_decl":
              ctx.type_decl_map[v.name] = v;
              break;
            case "PM_switch":
              _ref26 = root.scope.list;
              for (_z = 0, _len16 = _ref26.length; _z < _len16; _z++) {
                _case = _ref26[_z];
                ctx.type_decl_map[_case.var_decl.type.main] = _case.var_decl;
              }
              break;
            default:
              "skip";
          }
        }
        field_decl_jl = [];
        _ref27 = root.scope.list;
        for (_aa = 0, _len17 = _ref27.length; _aa < _len17; _aa++) {
          v = _ref27[_aa];
          switch (v.constructor.name) {
            case "Var_decl":
              if (!v.is_const) {
                field_decl_jl.push(walk(v, ctx));
              } else {
                ctx.sink_list.push(walk(v, ctx));
              }
              break;
            case "Fn_decl_multiret":
              ctx.contract_var_map[v.name] = v;
              break;
            case "Enum_decl":
              "skip";
              break;
            case "Class_decl":
              code = walk(v, ctx);
              if (code) {
                ctx.sink_list.push(code);
              }
              break;
            case "Comment":
              "skip";
              break;
            case "Event_decl":
              ctx.sink_list.push(walk(v, ctx));
              break;
            default:
              throw new Error("unknown v.constructor.name " + v.constructor.name);
          }
        }
        jl = [];
        jl.append(ctx.sink_list);
        ctx.sink_list.clear();
        _ref28 = root.scope.list;
        for (_ab = 0, _len18 = _ref28.length; _ab < _len18; _ab++) {
          v = _ref28[_ab];
          switch (v.constructor.name) {
            case "Var_decl":
              "skip";
              break;
            case "Enum_decl":
              jl.unshift(walk(v, ctx));
              break;
            case "Comment":
              jl.push(walk(v, ctx));
              break;
            case "Fn_decl_multiret":
              jl.push(walk(v, ctx));
              break;
            case "Class_decl":
            case "Event_decl":
              "skip";
              break;
            default:
              throw new Error("unknown v.constructor.name " + v.constructor.name);
          }
        }
        if (root.is_contract || root.is_library) {
          state_name = config.storage;
          if ((_base = orig_ctx.storage_sink_list)[state_name] == null) {
            _base[state_name] = [];
          }
          orig_ctx.storage_sink_list[state_name].append(field_decl_jl);
        } else {
          name = root.name;
          if (prefix) {
            name = "" + prefix + "_" + name;
          }
          name = translate_var_name(name, ctx);
          if (root.is_struct) {
            arg_list = [];
            _ref29 = root.scope.list;
            for (_ac = 0, _len19 = _ref29.length; _ac < _len19; _ac++) {
              v = _ref29[_ac];
              arg_list.push("" + v.name + " = " + (type2default_value(v.type, ctx)));
            }
            ctx.structs_default_list.push("const " + name + "_default : " + name + " = record [ " + (arg_list.join(";\n  ")) + " ];\n");
          }
          ctx.type_decl_sink_list.push({
            name: name,
            field_decl_jl: field_decl_jl
          });
        }
        return jl.join("\n\n");
      case "Enum_decl":
        jl = [];
        _ref30 = root.value_list;
        for (idx = _ad = 0, _len20 = _ref30.length; _ad < _len20; idx = ++_ad) {
          v = _ref30[idx];
          ctx.contract_var_map[v.name] = v;
          aux = "";
          if (v.type) {
            aux = " of " + (translate_var_name(v.type.main.replace(/\./g, "_", ctx)));
          }
          jl.push("| " + v.name + aux);
        }
        if (jl.length) {
          entry = join_list(jl, ' ');
        } else {
          entry = "unit";
        }
        return "type " + root.name + " is\n  " + entry + ";";
      case "Ternary":
        cond = walk(root.cond, ctx);
        t = walk(root.t, ctx);
        f = walk(root.f, ctx);
        return "(case " + cond + " of | True -> " + t + " | False -> " + f + " end)";
      case "New":
        arg_list = [];
        _ref31 = root.arg_list;
        for (_ae = 0, _len21 = _ref31.length; _ae < _len21; _ae++) {
          v = _ref31[_ae];
          arg_list.push(walk(v, ctx));
        }
        args = "" + (join_list(arg_list, ', '));
        translated_type = translate_type(root.cls, ctx);
        if (root.cls.main === "array") {
          return "map end (* args: " + args + " *)";
        } else if (translated_type === "bytes") {
          return "(\"00\": bytes) (* args: " + args + " *)";
        } else {
          return "" + translated_type + "(" + args + ")";
        }
        break;
      case "Tuple":
        arg_list = [];
        _ref32 = root.list;
        for (_af = 0, _len22 = _ref32.length; _af < _len22; _af++) {
          v = _ref32[_af];
          arg_list.push(walk(v, ctx));
        }
        return "(" + (arg_list.join(', ')) + ")";
      case "Array_init":
        arg_list = [];
        _ref33 = root.list;
        for (_ag = 0, _len23 = _ref33.length; _ag < _len23; _ag++) {
          v = _ref33[_ag];
          arg_list.push(walk(v, ctx));
        }
        if (root.type.main === "built_in_op_list") {
          return "list [" + (arg_list.join("; ")) + "]";
        } else {
          decls = [];
          for (i = _ah = 0, _len24 = arg_list.length; _ah < _len24; i = ++_ah) {
            arg = arg_list[i];
            decls.push("" + i + "n -> " + arg + ";");
          }
          return "map\n  " + (join_list(decls, '  ')) + "\nend";
        }
        break;
      case "Event_decl":
        args = [];
        _ref34 = root.arg_list;
        for (_ai = 0, _len25 = _ref34.length; _ai < _len25; _ai++) {
          arg = _ref34[_ai];
          name = arg._name;
          type = translate_type(arg, ctx);
          args.push("" + name + " : " + type);
        }
        return "(* EventDefinition " + root.name + "(" + (args.join('; ')) + ") *)";
      case "Include":
        return "#include \"" + root.path + "\"";
      default:
        if (ctx.next_gen != null) {
          return ctx.next_gen(root, ctx);
        } else {
          perr(root);
          throw new Error("Unknown root.constructor.name " + root.constructor.name);
        }
    }
  };

  this.gen = function(root, opt) {
    var ctx, ret;
    if (opt == null) {
      opt = {};
    }
    ctx = new module.Gen_context;
    ctx.next_gen = opt.next_gen;
    ctx.keep_dir_structure = opt.keep_dir_structure;
    ctx.files = {};
    ret = walk(root, ctx);
    if (opt.keep_dir_structure) {
      return ctx.files[""];
    } else {
      return ret;
    }
  };

}).call(window.require_register("./translate_ligo"));
/*/lib/translate_ligo_default_state.js*/(function() {
  var Type, config, last_bracket_state, module, translate_type, type2default_value, walk, _ref;

  module = this;

  

  config = require("./config");

  Type = window.Type;

  _ref = require("./translate_ligo"), translate_type = _ref.translate_type, type2default_value = _ref.type2default_value;

  this.Gen_context = (function() {
    Gen_context.prototype.next_gen = null;

    Gen_context.prototype.var_map = {};

    Gen_context.prototype.contract_map = {};

    Gen_context.prototype.type_decl_map = {};

    function Gen_context() {
      this.var_map = {};
      this.contract_map = {};
      this.type_decl_map = {};
    }

    Gen_context.prototype.mk_nest_contract = function(name) {
      var t;
      t = new module.Gen_context;
      this.contract_map[name] = t.var_map;
      obj_set(t.type_decl_map, this.type_decl_map);
      return t;
    };

    return Gen_context;

  })();

  last_bracket_state = false;

  walk = function(root, ctx) {
    var v, _i, _len, _ref1;
    last_bracket_state = false;
    switch (root.constructor.name) {
      case "Scope":
        _ref1 = root.list;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          v = _ref1[_i];
          walk(v, ctx);
        }
        return "nothing";
      case "Comment":
      case "Fn_decl_multiret":
      case "Enum_decl":
      case "Event_decl":
      case "Include":
        return "nothing";
      case "Var_decl":
        ctx.var_map[root.name] = {
          type: translate_type(root.type, ctx),
          value: type2default_value(root.type, ctx)
        };
        return "nothing";
      case "Class_decl":
        if (root.need_skip) {
          return;
        }
        ctx.type_decl_map[root.name] = root;
        if (root.is_contract) {
          ctx = ctx.mk_nest_contract(root.name);
        }
        return walk(root.scope, ctx);
      case "Enum_decl":
        ctx.type_decl_map[root.name] = root;
        return "nothing";
      default:
        if (ctx.next_gen != null) {
          return ctx.next_gen(root, ctx);
        } else {
          perr(root);
          throw new Error("Unknown root.constructor.name " + root.constructor.name);
        }
    }
  };

  this.gen = function(root, opt) {
    var contract, ctx, field_jl, jl, k, type, v, var_content, var_name, _ref1, _ref2;
    if (opt == null) {
      opt = {};
    }
    if (opt.convert_to_string == null) {
      opt.convert_to_string = true;
    }
    ctx = new module.Gen_context;
    ctx.next_gen = opt.next_gen;
    walk(root, ctx);
    _ref1 = ctx.contract_map;
    for (k in _ref1) {
      v = _ref1[k];
      if (0 === h_count(v)) {
        type = new Type("uint");
        v[config.empty_state] = {
          type: translate_type(type, ctx),
          value: type2default_value(type, ctx)
        };
      }
    }
    if (!opt.convert_to_string) {
      return ctx.contract_map;
    }
    jl = [];
    _ref2 = ctx.contract_map;
    for (k in _ref2) {
      contract = _ref2[k];
      field_jl = [];
      for (var_name in contract) {
        var_content = contract[var_name];
        field_jl.push("" + var_name + " = " + var_content.value + ";");
      }
      jl.push("record\n  " + (join_list(field_jl, '  ')) + "\nend");
    }
    return join_list(jl, '');
  };

}).call(window.require_register("./translate_ligo_default_state"));
/*/lib/solidity_to_ast4gen.js*/(function() {
  var Context, Type, ast, bin_op_map, config, ensure_scope, is_complex_assign_op, parse_line_pos, prev_root, type_generalize, un_op_map, un_op_post_map, un_op_pre_map, unpack_id_type, walk, walk_param, walk_type;

  

  config = require("./config");

  Type = window.Type;

  ast = require("./ast");

  type_generalize = require("./type_generalize").type_generalize;

  bin_op_map = {
    "+": "ADD",
    "-": "SUB",
    "*": "MUL",
    "/": "DIV",
    "%": "MOD",
    "**": "POW",
    ">>": "SHR",
    "<<": "SHL",
    "&": "BIT_AND",
    "|": "BIT_OR",
    "^": "BIT_XOR",
    "&&": "BOOL_AND",
    "||": "BOOL_OR",
    "==": "EQ",
    "!=": "NE",
    ">": "GT",
    "<": "LT",
    ">=": "GTE",
    "<=": "LTE",
    "=": "ASSIGN",
    "+=": "ASS_ADD",
    "-=": "ASS_SUB",
    "*=": "ASS_MUL",
    "/=": "ASS_DIV",
    "%=": "ASS_MOD",
    ">>=": "ASS_SHR",
    "<<=": "ASS_SHL",
    "&=": "ASS_BIT_AND",
    "|=": "ASS_BIT_OR",
    "^=": "ASS_BIT_XOR"
  };

  is_complex_assign_op = {
    "ASS_ADD": true,
    "ASS_SUB": true,
    "ASS_MUL": true,
    "ASS_DIV": true
  };

  un_op_map = {
    "-": "MINUS",
    "+": "PLUS",
    "~": "BIT_NOT",
    "!": "BOOL_NOT",
    "delete": "DELETE"
  };

  un_op_pre_map = {
    "++": "INC_RET",
    "--": "DEC_RET"
  };

  un_op_post_map = {
    "++": "RET_INC",
    "--": "RET_DEC"
  };

  walk_type = function(root, ctx) {
    var ret, _ref, _ref1;
    if (typeof root === "string") {
      return new Type(root);
    }
    switch (root.nodeType) {
      case "ElementaryTypeName":
        switch (root.name) {
          case "uint":
            return new Type("uint256");
          case "int":
            return new Type("int256");
          default:
            return new Type(root.name);
        }
        break;
      case "UserDefinedTypeName":
        return new Type(root.name);
      case "ArrayTypeName":
        ret = new Type("array");
        ret.nest_list.push(walk_type(root.baseType, ctx));
        _ref = parse_line_pos(root.src), ret.pos = _ref[0], ret.line = _ref[1];
        ret.file = ctx.file_stack.last();
        return ret;
      case "Mapping":
        ret = new Type("map");
        ret.nest_list.push(walk_type(root.keyType, ctx));
        ret.nest_list.push(walk_type(root.valueType, ctx));
        _ref1 = parse_line_pos(root.src), ret.pos = _ref1[0], ret.line = _ref1[1];
        ret.file = ctx.file_stack.last();
        return ret;
      default:
        perr(root);
        throw new Error("walk_type unknown nodeType '" + root.nodeType + "'");
    }
  };

  unpack_id_type = function(root, ctx) {
    var type_string;
    type_string = root.typeString;
    if (/\smemory$/.test(type_string)) {
      type_string = type_string.replace(/\smemory$/, "");
    }
    if (/\sstorage$/.test(type_string)) {
      type_string = type_string.replace(/\sstorage$/, "");
    }
    switch (type_string) {
      case "bool":
        return new Type("bool");
      case "uint":
        return new Type("uint256");
      case "int":
        return new Type("int256");
      case "byte":
        return new Type("bytes1");
      case "bytes":
        return new Type("bytes");
      case "address":
        return new Type("address");
      case "string":
        return new Type("string");
      case "msg":
        return null;
      case "block":
        return null;
      case "tx":
        return null;
      default:
        if (config.bytes_type_map.hasOwnProperty(type_string)) {
          return new Type(root.typeString);
        } else if (config.uint_type_map.hasOwnProperty(type_string)) {
          return new Type(root.typeString);
        } else if (config.int_type_map.hasOwnProperty(type_string)) {
          return new Type(root.typeString);
        } else {
          throw new Error("unpack_id_type unknown typeString '" + root.typeString + "'");
        }
    }
  };

  parse_line_pos = function(str) {
    return str.split(":", 2);
  };

  walk_param = function(root, ctx) {
    var ret, t, v, _i, _len, _ref;
    switch (root.nodeType) {
      case "ParameterList":
        ret = [];
        _ref = root.parameters;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          ret.append(walk_param(v, ctx));
        }
        return ret;
      case "VariableDeclaration":
        if (root.value) {
          throw new Error("root.value not implemented");
        }
        ret = [];
        t = walk_type(root.typeName, ctx);
        t._name = root.name;
        ret.push(t);
        return ret;
      default:
        perr(root);
        throw new Error("walk_param unknown nodeType '" + root.nodeType + "'");
    }
  };

  ensure_scope = function(t) {
    var ret;
    if (t.constructor.name === "Scope") {
      return t;
    }
    ret = new ast.Scope;
    ret.list.push(t);
    return ret;
  };

  Context = (function() {
    Context.prototype.contract = null;

    Context.prototype.contract_name = "";

    Context.prototype.contract_type = "";

    Context.prototype.file_stack = [];

    Context.prototype.need_prevent_deploy = false;

    function Context() {}

    return Context;

  })();

  prev_root = null;

  walk = function(root, ctx) {
    var arg, arg_list, arg_names, args, ast_mod, comment, decl, err, exp, failwith, failwith_msg, fn, list, member, modifier, mult, name, node, parameter, result, ret, ret_multi, scope_prepend_list, tuple, type, type_list, v, var_decl, _var;
    if (!root) {
      perr(prev_root);
      throw new Error("!root");
    }
    prev_root = root;
    result = (function() {
      var _base, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len12, _len13, _len14, _len15, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref27, _ref28, _ref29, _ref3, _ref30, _ref31, _ref32, _ref33, _ref34, _ref35, _ref36, _ref37, _ref38, _ref39, _ref4, _ref40, _ref41, _ref42, _ref43, _ref44, _ref45, _ref46, _ref47, _ref48, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u, _v, _w, _x;
      switch (root.nodeType) {
        case "SourceUnit":
          ret = new ast.Scope;
          ret.original_node_type = root.nodeType;
          _ref = root.nodes;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            ret.list.push(walk(node, ctx));
          }
          _ref1 = parse_line_pos(root.src), ret.pos = _ref1[0], ret.line = _ref1[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "ContractDefinition":
          if (root.name.startsWith("ImportPlaceholderStart")) {
            ctx.file_stack.push(root.nodes[0].value.value);
            ret = new ast.Comment;
            ret.text = "#include \"" + (ctx.file_stack.last()) + "\"";
            ret.can_skip = true;
            return ret;
          } else if (root.name.startsWith("ImportPlaceholderEnd")) {
            ret = new ast.Comment;
            ret.text = "end of include " + (ctx.file_stack.last());
            ret.can_skip = true;
            ctx.file_stack.pop();
            return ret;
          } else {
            ret = new ast.Class_decl;
            switch (root.contractKind) {
              case "contract":
                ret.is_contract = true;
                break;
              case "library":
                ret.is_library = true;
                break;
              case "interface":
                ret.is_interface = true;
                break;
              default:
                throw new Error("unknown contractKind " + root.contractKind);
            }
            ret.inheritance_list = [];
            ret.name = root.name;
            ctx.contract = ret;
            ctx.contract_name = root.name;
            ctx.contract_type = root.contractKind;
            _ref2 = root.baseContracts;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              v = _ref2[_j];
              arg_list = [];
              if (v["arguments"]) {
                _ref3 = v["arguments"];
                for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
                  arg = _ref3[_k];
                  arg_list.push(walk(arg, ctx));
                }
              }
              ret.inheritance_list.push({
                name: v.baseName.name,
                arg_list: arg_list
              });
            }
            _ref4 = root.nodes;
            for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
              node = _ref4[_l];
              ret.scope.list.push(walk(node, ctx));
            }
            _ref5 = parse_line_pos(root.src), ret.pos = _ref5[0], ret.line = _ref5[1];
            ret.file = ctx.file_stack.last();
            return ret;
          }
          break;
        case "PragmaDirective":
          ret = new ast.Comment;
          ret.text = "PragmaDirective " + (root.literals.join(' '));
          ret.can_skip = true;
          return ret;
        case "UsingForDirective":
          ret = new ast.Comment;
          ret.text = "UsingForDirective";
          _ref6 = parse_line_pos(root.src), ret.pos = _ref6[0], ret.line = _ref6[1];
          ret.file = ctx.file_stack.last();
          if (root.typeName === null) {
            type = "*";
          } else {
            type = type_generalize(root.typeName.name);
          }
          if ((_base = ctx.contract.using_map)[type] == null) {
            _base[type] = [];
          }
          ctx.contract.using_map[type].push(root.libraryName.name);
          return ret;
        case "StructDefinition":
          ret = new ast.Class_decl;
          ret.name = root.name;
          ret.is_struct = true;
          _ref7 = root.members;
          for (_m = 0, _len4 = _ref7.length; _m < _len4; _m++) {
            v = _ref7[_m];
            ret.scope.list.push(walk(v, ctx));
          }
          _ref8 = parse_line_pos(root.src), ret.pos = _ref8[0], ret.line = _ref8[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "InlineAssembly":
          perr("WARNING (AST gen). InlineAssembly is not supported. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#inline-assembler");
          failwith_msg = new ast.Const;
          failwith_msg.val = "Unsupported InlineAssembly";
          failwith_msg.type = new Type("string");
          failwith = new ast.Throw;
          failwith.t = failwith_msg;
          comment = new ast.Comment;
          comment.text = "InlineAssembly " + root.operations;
          ret = new ast.Scope;
          ret.need_nest = false;
          ret.list.push(failwith);
          ret.list.push(comment);
          _ref9 = parse_line_pos(root.src), ret.pos = _ref9[0], ret.line = _ref9[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "EventDefinition":
          perr("WARNING (AST gen). EventDefinition is not supported. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#solidity-events");
          ret = new ast.Event_decl;
          ret.name = root.name;
          ret.arg_list = walk_param(root.parameters, ctx);
          _ref10 = parse_line_pos(root.src), ret.pos = _ref10[0], ret.line = _ref10[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "EmitStatement":
          perr("WARNING (AST gen). EmitStatement is not supported. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#solidity-events");
          ret = new ast.Comment;
          args = [];
          name = ((_ref11 = root.fn) != null ? _ref11.name : void 0) || root.eventCall.name || root.eventCall.expression.name;
          args = root.arg_list || root.eventCall["arguments"];
          arg_names = args.map(function(arg) {
            return arg.name;
          });
          ret.text = "EmitStatement " + name + "(" + (arg_names.join(", ")) + ")";
          _ref12 = parse_line_pos(root.src), ret.pos = _ref12[0], ret.line = _ref12[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "PlaceholderStatement":
          ret = new ast.Comment;
          ret.text = "COMPILER MSG PlaceholderStatement";
          _ref13 = parse_line_pos(root.src), ret.pos = _ref13[0], ret.line = _ref13[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "Identifier":
          ret = new ast.Var;
          ret.name = root.name;
          try {
            ret.type = unpack_id_type(root.typeDescriptions, ctx);
          } catch (_error) {
            err = _error;
            perr("WARNING (AST gen). Can't resolve type " + err);
          }
          _ref14 = parse_line_pos(root.src), ret.pos = _ref14[0], ret.line = _ref14[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "Literal":
          ret = new ast.Const;
          ret.type = new Type(root.kind);
          ret.val = root.value;
          _ref15 = parse_line_pos(root.src), ret.pos = _ref15[0], ret.line = _ref15[1];
          ret.file = ctx.file_stack.last();
          switch (root.subdenomination) {
            case "seconds":
              return ret;
            case "minutes":
              mult = new ast.Const;
              mult.type = new Type(root.kind);
              mult.val = 60;
              exp = new ast.Bin_op;
              exp.op = bin_op_map["*"];
              exp.a = ret;
              exp.b = mult;
              return exp;
            case "hours":
              mult = new ast.Const;
              mult.type = new Type(root.kind);
              mult.val = 3600;
              exp = new ast.Bin_op;
              exp.op = bin_op_map["*"];
              exp.a = ret;
              exp.b = mult;
              return exp;
            case "days":
              mult = new ast.Const;
              mult.type = new Type(root.kind);
              mult.val = 86400;
              exp = new ast.Bin_op;
              exp.op = bin_op_map["*"];
              exp.a = ret;
              exp.b = mult;
              return exp;
            case "weeks":
              mult = new ast.Const;
              mult.type = new Type(root.kind);
              mult.val = 604800;
              exp = new ast.Bin_op;
              exp.op = bin_op_map["*"];
              exp.a = ret;
              exp.b = mult;
              return exp;
            case "szabo":
              return ret;
            case "finney":
              mult = new ast.Const;
              mult.type = new Type(root.kind);
              mult.val = 1000;
              exp = new ast.Bin_op;
              exp.op = bin_op_map["*"];
              exp.a = ret;
              exp.b = mult;
              return exp;
            case "ether":
              mult = new ast.Const;
              mult.type = new Type(root.kind);
              mult.val = 1000000;
              exp = new ast.Bin_op;
              exp.op = bin_op_map["*"];
              exp.a = ret;
              exp.b = mult;
              return exp;
            default:
              return ret;
          }
          break;
        case "VariableDeclaration":
          ret = new ast.Var_decl;
          ret.is_const = root.constant;
          ret.name = root.name;
          ret.contract_name = ctx.contract_name;
          ret.contract_type = ctx.contract_type;
          ret.type = walk_type(root.typeName, ctx);
          if (root.value) {
            ret.assign_value = walk(root.value, ctx);
          }
          _ref16 = parse_line_pos(root.src), ret.pos = _ref16[0], ret.line = _ref16[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "Assignment":
          ret = new ast.Bin_op;
          ret.op = bin_op_map[root.operator];
          if (!ret.op) {
            throw new Error("unknown bin_op " + root.operator);
          }
          ret.a = walk(root.leftHandSide, ctx);
          ret.b = walk(root.rightHandSide, ctx);
          _ref17 = parse_line_pos(root.src), ret.pos = _ref17[0], ret.line = _ref17[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "BinaryOperation":
          ret = new ast.Bin_op;
          ret.op = bin_op_map[root.operator];
          if (!ret.op) {
            throw new Error("unknown bin_op " + root.operator);
          }
          ret.a = walk(root.leftExpression, ctx);
          ret.b = walk(root.rightExpression, ctx);
          _ref18 = parse_line_pos(root.src), ret.pos = _ref18[0], ret.line = _ref18[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "MemberAccess":
          ret = new ast.Field_access;
          ret.t = walk(root.expression, ctx);
          ret.name = root.memberName;
          _ref19 = parse_line_pos(root.src), ret.pos = _ref19[0], ret.line = _ref19[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "IndexAccess":
          ret = new ast.Bin_op;
          ret.op = "INDEX_ACCESS";
          ret.a = walk(root.baseExpression, ctx);
          ret.b = walk(root.indexExpression, ctx);
          _ref20 = parse_line_pos(root.src), ret.pos = _ref20[0], ret.line = _ref20[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "UnaryOperation":
          ret = new ast.Un_op;
          ret.op = un_op_map[root.operator];
          if (!ret.op) {
            if (root.prefix) {
              ret.op = un_op_pre_map[root.operator];
            } else {
              ret.op = un_op_post_map[root.operator];
            }
          }
          if (!ret.op) {
            perr(root);
            throw new Error("unknown un_op " + root.operator);
          }
          ret.a = walk(root.subExpression, ctx);
          _ref21 = parse_line_pos(root.src), ret.pos = _ref21[0], ret.line = _ref21[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "FunctionCall":
          fn = walk(root.expression, ctx);
          arg_list = [];
          _ref22 = root["arguments"];
          for (_n = 0, _len5 = _ref22.length; _n < _len5; _n++) {
            v = _ref22[_n];
            arg_list.push(walk(v, ctx));
          }
          switch (fn.constructor.name) {
            case "New":
              ret = fn;
              ret.arg_list = arg_list;
              break;
            case "Type_cast":
              if (arg_list.length !== 1) {
                perr(arg_list);
                throw new Error("arg_list.length != 1");
              }
              ret = fn;
              ret.t = arg_list[0];
              break;
            default:
              if (root.kind === "structConstructorCall") {
                ret = new ast.Struct_init;
                ret.fn = fn;
                ret.val_list = arg_list;
                if (root.names) {
                  ret.arg_names = root.names;
                }
              } else {
                ret = new ast.Fn_call;
                ret.fn = fn;
                ret.arg_list = arg_list;
              }
          }
          _ref23 = parse_line_pos(root.src), ret.pos = _ref23[0], ret.line = _ref23[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "TupleExpression":
          if (root.isInlineArray) {
            ret = new ast.Array_init;
          } else {
            ret = new ast.Tuple;
          }
          _ref24 = root.components;
          for (_o = 0, _len6 = _ref24.length; _o < _len6; _o++) {
            v = _ref24[_o];
            if (v != null) {
              ret.list.push(walk(v, ctx));
            } else {
              ret.list.push(null);
            }
          }
          if (ret.constructor.name === "Tuple") {
            if (ret.list.length === 1) {
              ret = ret.list[0];
            }
          }
          _ref25 = parse_line_pos(root.src), ret.pos = _ref25[0], ret.line = _ref25[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "NewExpression":
          ret = new ast.New;
          ret.cls = walk_type(root.typeName, ctx);
          _ref26 = parse_line_pos(root.src), ret.pos = _ref26[0], ret.line = _ref26[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "ElementaryTypeNameExpression":
          ret = new ast.Type_cast;
          ret.target_type = walk_type(root.typeName, ctx);
          _ref27 = parse_line_pos(root.src), ret.pos = _ref27[0], ret.line = _ref27[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "Conditional":
          ret = new ast.Ternary;
          ret.cond = walk(root.condition, ctx);
          ret.t = walk(root.trueExpression, ctx);
          ret.f = walk(root.falseExpression, ctx);
          _ref28 = parse_line_pos(root.src), ret.pos = _ref28[0], ret.line = _ref28[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "ExpressionStatement":
          return walk(root.expression, ctx);
        case "VariableDeclarationStatement":
          if (root.declarations.length !== 1) {
            ret = new ast.Var_decl_multi;
            _ref29 = root.declarations;
            for (_p = 0, _len7 = _ref29.length; _p < _len7; _p++) {
              decl = _ref29[_p];
              if (decl == null) {
                ret.list.push({
                  skip: true
                });
                continue;
              }
              if (decl.typeName) {
                ret.list.push({
                  name: decl.name,
                  type: walk_type(decl.typeName, ctx)
                });
              } else {
                try {
                  type = unpack_id_type(decl.typeDescriptions, ctx);
                } catch (_error) {
                  err = _error;
                  perr("WARNING (AST gen). Can't resolve type " + err);
                }
                ret.list.push({
                  name: decl.name,
                  type: type
                });
              }
            }
            if (root.initialValue) {
              ret.assign_value = walk(root.initialValue, ctx);
            }
            type_list = [];
            _ref30 = ret.list;
            for (_q = 0, _len8 = _ref30.length; _q < _len8; _q++) {
              v = _ref30[_q];
              type_list.push(v.type);
            }
            ret.type = new Type("tuple<>");
            ret.type.nest_list = type_list;
            _ref31 = parse_line_pos(root.src), ret.pos = _ref31[0], ret.line = _ref31[1];
            ret.file = ctx.file_stack.last();
            return ret;
          } else {
            decl = root.declarations[0];
            if (decl.value) {
              throw new Error("decl.value not implemented");
            }
            ret = new ast.Var_decl;
            ret.name = decl.name;
            if (decl.typeName) {
              ret.type = walk_type(decl.typeName, ctx);
            } else {
              ret.type = unpack_id_type(decl.typeDescriptions, ctx);
            }
            if (root.initialValue) {
              ret.assign_value = walk(root.initialValue, ctx);
            }
            _ref32 = parse_line_pos(root.src), ret.pos = _ref32[0], ret.line = _ref32[1];
            ret.file = ctx.file_stack.last();
            return ret;
          }
          break;
        case "Block":
          ret = new ast.Scope;
          _ref33 = root.statements;
          for (_r = 0, _len9 = _ref33.length; _r < _len9; _r++) {
            node = _ref33[_r];
            ret.list.push(walk(node, ctx));
          }
          _ref34 = parse_line_pos(root.src), ret.pos = _ref34[0], ret.line = _ref34[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "IfStatement":
          ret = new ast.If;
          ret.cond = walk(root.condition, ctx);
          ret.t = ensure_scope(walk(root.trueBody, ctx));
          if (root.falseBody) {
            ret.f = ensure_scope(walk(root.falseBody, ctx));
          }
          _ref35 = parse_line_pos(root.src), ret.pos = _ref35[0], ret.line = _ref35[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "WhileStatement":
          ret = new ast.While;
          ret.cond = walk(root.condition, ctx);
          ret.scope = ensure_scope(walk(root.body, ctx));
          _ref36 = parse_line_pos(root.src), ret.pos = _ref36[0], ret.line = _ref36[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "ForStatement":
          ret = new ast.For3;
          if (root.initializationExpression) {
            ret.init = walk(root.initializationExpression, ctx);
          }
          if (root.condition) {
            ret.cond = walk(root.condition, ctx);
          }
          if (root.loopExpression) {
            ret.iter = walk(root.loopExpression, ctx);
          }
          ret.scope = ensure_scope(walk(root.body, ctx));
          _ref37 = parse_line_pos(root.src), ret.pos = _ref37[0], ret.line = _ref37[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "Return":
          ret = new ast.Ret_multi;
          if (root.expression) {
            ret.t_list.push(walk(root.expression, ctx));
          }
          _ref38 = parse_line_pos(root.src), ret.pos = _ref38[0], ret.line = _ref38[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "Continue":
          perr("WARNING (AST gen). 'continue' is not supported by LIGO. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#continue--break");
          ctx.need_prevent_deploy = true;
          ret = new ast.Continue;
          _ref39 = parse_line_pos(root.src), ret.pos = _ref39[0], ret.line = _ref39[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "Break":
          perr("WARNING (AST gen). 'break' is not supported by LIGO. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#continue--break");
          ctx.need_prevent_deploy = true;
          ret = new ast.Break;
          _ref40 = parse_line_pos(root.src), ret.pos = _ref40[0], ret.line = _ref40[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "Throw":
          ret = new ast.Throw;
          _ref41 = parse_line_pos(root.src), ret.pos = _ref41[0], ret.line = _ref41[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "FunctionDefinition":
        case "ModifierDefinition":
          ret = ctx.current_function = new ast.Fn_decl_multiret;
          ret.is_modifier = root.nodeType === "ModifierDefinition";
          ret.is_constructor = root.isConstructor || root.kind === "constructor";
          ret.name = root.name || "fallback";
          if (ret.is_constructor) {
            ret.name = "constructor";
          }
          ret.contract_name = ctx.contract_name;
          ret.contract_type = ctx.contract_type;
          ret.type_i = new Type("function");
          ret.type_o = new Type("function");
          ret.visibility = root.visibility;
          ret.state_mutability = root.stateMutability;
          ret.type_i.nest_list = walk_param(root.parameters, ctx);
          if (!ret.is_modifier) {
            list = walk_param(root.returnParameters, ctx);
            if (list.length <= 1) {
              ret.type_o.nest_list = list;
            } else {
              tuple = new Type("tuple<>");
              tuple.nest_list = list;
              ret.type_o.nest_list.push(tuple);
            }
          }
          scope_prepend_list = [];
          if (root.returnParameters) {
            _ref42 = root.returnParameters.parameters;
            for (_s = 0, _len10 = _ref42.length; _s < _len10; _s++) {
              parameter = _ref42[_s];
              if (!parameter.name) {
                continue;
              }
              scope_prepend_list.push(var_decl = new ast.Var_decl);
              var_decl.name = parameter.name;
              var_decl.type = walk_type(parameter.typeName, ctx);
            }
          }
          _ref43 = ret.type_i.nest_list;
          for (_t = 0, _len11 = _ref43.length; _t < _len11; _t++) {
            v = _ref43[_t];
            ret.arg_name_list.push(v._name);
          }
          if (!ret.is_modifier) {
            _ref44 = root.modifiers;
            for (_u = 0, _len12 = _ref44.length; _u < _len12; _u++) {
              modifier = _ref44[_u];
              ast_mod = new ast.Fn_call;
              ast_mod.fn = walk(modifier.modifierName, ctx);
              if (modifier["arguments"]) {
                _ref45 = modifier["arguments"];
                for (_v = 0, _len13 = _ref45.length; _v < _len13; _v++) {
                  v = _ref45[_v];
                  ast_mod.arg_list.push(walk(v, ctx));
                }
              }
              ret.modifier_list.push(ast_mod);
            }
          }
          if (root.body) {
            ret.scope = walk(root.body, ctx);
          } else {
            ret.scope = new ast.Scope;
          }
          if (scope_prepend_list.length) {
            ret.scope.list = arr_merge(scope_prepend_list, ret.scope.list);
            if (ret.scope.list.last().constructor.name !== "Ret_multi") {
              ret.scope.list.push(ret_multi = new ast.Ret_multi);
              switch (scope_prepend_list.length) {
                case 0:
                  "nothing";
                  break;
                case 1:
                  v = scope_prepend_list[0];
                  ret_multi.t_list.push(_var = new ast.Var);
                  _var.name = v.name;
                  break;
                default:
                  tuple = new ast.Tuple;
                  for (_w = 0, _len14 = scope_prepend_list.length; _w < _len14; _w++) {
                    v = scope_prepend_list[_w];
                    tuple.list.push(_var = new ast.Var);
                    _var.name = v.name;
                  }
                  ret_multi.t_list.push(tuple);
              }
            }
          }
          _ref46 = parse_line_pos(root.src), ret.pos = _ref46[0], ret.line = _ref46[1];
          ret.file = ctx.file_stack.last();
          return ret;
        case "EnumDefinition":
          ret = new ast.Enum_decl;
          ret.name = root.name;
          _ref47 = root.members;
          for (_x = 0, _len15 = _ref47.length; _x < _len15; _x++) {
            member = _ref47[_x];
            ret.value_list.push(decl = new ast.Var_decl);
            decl.name = member.name;
          }
          _ref48 = parse_line_pos(root.src), ret.pos = _ref48[0], ret.line = _ref48[1];
          ret.file = ctx.file_stack.last();
          return ret;
        default:
          perr(root);
          throw new Error("walk unknown nodeType '" + root.nodeType + "'");
      }
    })();
    if (ctx.need_prevent_deploy) {
      result.need_prevent_deploy = true;
    }
    return result;
  };

  this.gen = function(root) {
    return walk(root, new Context);
  };

}).call(window.require_register("./solidity_to_ast4gen"));
/*/lib/ast_builder.js*/(function() {
  var Type, ast;

  Type = window.Type;

  ast = require("./ast");

  this.unit = function() {
    var unit;
    unit = new ast.Const;
    unit.type = new Type("Unit");
    unit.val = "unit";
    return unit;
  };

  this.nat_literal = function(value) {
    var literal;
    literal = new ast.Const;
    literal.type = new Type("uint");
    literal.val = value;
    return literal;
  };

  this.list_init = function(array) {
    var init;
    init = new ast.Array_init;
    init.type = new Type("built_in_op_list");
    init.list = array;
    return init;
  };

  this.cast_to_tez = function(node) {
    var ret;
    ret = new ast.Bin_op;
    ret.op = "MUL";
    ret.a = node;
    ret.b = new ast.Const;
    ret.b.val = 1;
    ret.b.type = new Type("mutez");
    return ret;
  };

  this.contract_addr_transform = function(in_addr_expr) {
    var address_expr;
    if (in_addr_expr.type.main === "struct" && in_addr_expr.arg_list.length === 1) {
      address_expr = new ast.Type_cast;
      address_expr.t = in_addr_expr.arg_list[0];
      address_expr.target_type = new Type("address");
    } else {
      address_expr = in_addr_expr;
    }
    return address_expr;
  };

  this.transaction = function(input_args, entrypoint_expr, cost) {
    var inject, params;
    inject = new ast.Fn_call;
    inject.fn = new ast.Var;
    inject.fn.name = "@transaction";
    inject.arg_list.push(params = new ast.Tuple);
    params.list = input_args;
    if (!cost) {
      cost = new ast.Const;
      cost.val = 0;
      cost.type = new Type("mutez");
    }
    inject.arg_list.push(cost);
    inject.arg_list.push(entrypoint_expr);
    return inject;
  };

  this.foreign_entrypoint = function(address_expr, contract_type) {
    var contract_cast, get_contract;
    contract_cast = new ast.Type_cast;
    contract_cast.target_type = new Type("contract");
    contract_cast.target_type.val = contract_type;
    get_contract = new ast.Fn_call;
    get_contract.type = "function2<function<uint>, function<address>>";
    get_contract.fn = new ast.Var;
    get_contract.fn.name = "@get_contract";
    get_contract.arg_list.push(address_expr);
    contract_cast.t = get_contract;
    return contract_cast;
  };

  this.get_entrypoint = function(name, address, type) {
    var contract_cast, get_entrypoint;
    contract_cast = new ast.Type_cast;
    contract_cast.target_type = type;
    get_entrypoint = new ast.Fn_call;
    get_entrypoint.type = "function2<function<uint>, function<address>>";
    get_entrypoint.fn = new ast.Var;
    get_entrypoint.fn.name = "@get_entrypoint";
    get_entrypoint.arg_list.push(name);
    get_entrypoint.arg_list.push(address);
    contract_cast.t = get_entrypoint;
    return contract_cast;
  };

  this.self_entrypoint = function(name, contract_type) {
    var arg, cast, entrypoint_name, get_entrypoint;
    arg = new ast.Var;
    arg.name = "@Tezos";
    get_entrypoint = new ast.Fn_call;
    get_entrypoint.fn = new ast.Field_access;
    get_entrypoint.fn.name = "@self";
    get_entrypoint.fn.t = arg;
    entrypoint_name = new ast.Const;
    entrypoint_name.type = new Type("string");
    entrypoint_name.val = name;
    get_entrypoint.arg_list.push(entrypoint_name);
    cast = new ast.Type_cast;
    cast.t = get_entrypoint;
    if (!contract_type) {
      contract_type = new Type("contract");
      contract_type.val = "unit";
    }
    cast.target_type = contract_type;
    return cast;
  };

  this.assignment = function(name, rvalue, rtype) {
    var ass;
    ass = new ast.Bin_op;
    ass.op = "ASSIGN";
    ass.a = new ast.Var;
    ass.a.name = name;
    ass.a.type = rtype;
    ass.b = rvalue;
    return ass;
  };

  this.declaration = function(name, rvalue, rtype) {
    var decl;
    decl = new ast.Var_decl;
    decl.name = name;
    decl.type = rtype;
    decl.assign_value = rvalue;
    return decl;
  };

  this.struct_init = function(dict) {
    var structure;
    structure = new ast.Struct_init;
    structure.arg_names = Object.keys(dict);
    structure.val_list = Object.values(dict);
    return structure;
  };

  this.callback_declaration = function(name, arg_type) {
    var cb_decl, failwith;
    cb_decl = new ast.Fn_decl_multiret;
    cb_decl.name = name + "Callback";
    cb_decl.type_i = new Type("function");
    cb_decl.type_o = new Type("function");
    cb_decl.arg_name_list.push("arg");
    cb_decl.type_i.nest_list.push(arg_type);
    failwith = new ast.Throw;
    failwith.t = this.string_val("This method should handle return value of " + name + " of foreign contract. Read more at https://git.io/JfDxR");
    cb_decl.scope.list.push(failwith);
    return cb_decl;
  };

  this.tezos_var = function(name) {
    var ret;
    ret = new ast.Field_access;
    ret.t = new ast.Var;
    ret.t.name = "@Tezos";
    ret.name = "@" + name;
    return ret;
  };

  this.enum_val = function(name, payload) {
    var enum_val;
    enum_val = new ast.Fn_call;
    enum_val.fn = new ast.Var;
    enum_val.fn.name = name;
    enum_val.arg_list = payload;
    return enum_val;
  };

  this.string_val = function(str) {
    var ret;
    ret = new ast.Const;
    ret.type = new Type("string");
    ret.val = str;
    return ret;
  };

  this.to_right_comb = function(args) {
    var call, namespace;
    namespace = new ast.Var;
    namespace.name = "@Layout";
    call = new ast.Fn_call;
    call.fn = new ast.Field_access;
    call.fn.name = "convert_to_right_comb";
    call.fn.t = namespace;
    call.arg_list = args;
    return call;
  };

  this.cast_to_address = function(t) {
    var ret, _ref;
    if (((_ref = t.type) != null ? _ref.main : void 0) === "address") {
      return t;
    }
    ret = new ast.Type_cast;
    ret.target_type = new Type("address");
    ret.t = t;
    return ret;
  };

}).call(window.require_register("./ast_builder"));
/*/lib/transforms/default_walk.js*/(function() {
  this.default_walk = function(root, ctx) {
    var idx, v, walk, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    walk = ctx.walk;
    switch (root.constructor.name) {
      case "Scope":
        _ref = root.list;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          v = _ref[idx];
          root.list[idx] = walk(v, ctx);
        }
        return root;
      case "Var":
      case "Const":
        return root;
      case "Un_op":
        root.a = walk(root.a, ctx);
        return root;
      case "Bin_op":
        root.a = walk(root.a, ctx);
        root.b = walk(root.b, ctx);
        return root;
      case "Field_access":
        root.t = walk(root.t, ctx);
        return root;
      case "Fn_call":
        _ref1 = root.arg_list;
        for (idx = _j = 0, _len1 = _ref1.length; _j < _len1; idx = ++_j) {
          v = _ref1[idx];
          root.arg_list[idx] = walk(v, ctx);
        }
        root.fn = walk(root.fn, ctx);
        return root;
      case "Struct_init":
        root.fn = root.fn;
        if (ctx.class_map && root.arg_names.length === 0) {
          _ref2 = ctx.class_map[root.fn.name].scope.list;
          for (idx = _k = 0, _len2 = _ref2.length; _k < _len2; idx = ++_k) {
            v = _ref2[idx];
            root.arg_names.push(v.name);
          }
        }
        _ref3 = root.val_list;
        for (idx = _l = 0, _len3 = _ref3.length; _l < _len3; idx = ++_l) {
          v = _ref3[idx];
          root.val_list[idx] = walk(v, ctx);
        }
        return root;
      case "New":
        _ref4 = root.arg_list;
        for (idx = _m = 0, _len4 = _ref4.length; _m < _len4; idx = ++_m) {
          v = _ref4[idx];
          root.arg_list[idx] = walk(v, ctx);
        }
        return root;
      case "Comment":
        return root;
      case "Continue":
      case "Break":
        return root;
      case "Var_decl":
        if (root.assign_value) {
          root.assign_value = walk(root.assign_value, ctx);
        }
        return root;
      case "Var_decl_multi":
        if (root.assign_value) {
          root.assign_value = walk(root.assign_value, ctx);
        }
        return root;
      case "Throw":
        if (root.t) {
          root.t = walk(root.t, ctx);
        }
        return root;
      case "Type_cast":
        root.t = walk(root.t, ctx);
        return root;
      case "Enum_decl":
      case "PM_switch":
        return root;
      case "Ret_multi":
        _ref5 = root.t_list;
        for (idx = _n = 0, _len5 = _ref5.length; _n < _len5; idx = ++_n) {
          v = _ref5[idx];
          root.t_list[idx] = walk(v, ctx);
        }
        return root;
      case "If":
      case "Ternary":
        root.cond = walk(root.cond, ctx);
        root.t = walk(root.t, ctx);
        root.f = walk(root.f, ctx);
        return root;
      case "While":
        root.cond = walk(root.cond, ctx);
        root.scope = walk(root.scope, ctx);
        return root;
      case "For3":
        if (root.init) {
          root.init = walk(root.init, ctx);
        }
        if (root.cond) {
          root.cond = walk(root.cond, ctx);
        }
        if (root.iter) {
          root.iter = walk(root.iter, ctx);
        }
        root.scope = walk(root.scope, ctx);
        return root;
      case "Class_decl":
        root.scope = walk(root.scope, ctx);
        return root;
      case "Fn_decl_multiret":
        root.scope = walk(root.scope, ctx);
        return root;
      case "Tuple":
      case "Array_init":
        _ref6 = root.list;
        for (idx = _o = 0, _len6 = _ref6.length; _o < _len6; idx = ++_o) {
          v = _ref6[idx];
          root.list[idx] = walk(v, ctx);
        }
        return root;
      case "Event_decl":
        return root;
      case "Include":
        return root;
      default:

        /* !pragma coverage-skip-block */
        perr(root);
        throw new Error("unknown root.constructor.name " + root.constructor.name);
    }
  };

}).call(window.require_register("./transforms/default_walk"));
/*/lib/transforms/collect_fn_call.js*/(function() {
  var default_walk;

  default_walk = require("./default_walk").default_walk;

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        var mod, _i, _len, _ref;
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "Fn_decl_multiret":
            _ref = root.modifier_list;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              mod = _ref[_i];
              walk(mod, ctx);
            }
            return ctx.next_gen(root, ctx);
          case "Fn_call":
            switch (root.fn.constructor.name) {
              case "Var":
                ctx.fn_map[root.fn.name] = true;
                break;
              case "Field_access":
                if (root.fn.t.constructor.name === "Var") {
                  if (root.fn.t.name === "this") {
                    ctx.fn_map[root.fn.name] = true;
                  }
                }
            }
            return ctx.next_gen(root, ctx);
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.collect_fn_call = function(root) {
        var fn_map;
        fn_map = {};
        walk(root, {
          walk: walk,
          next_gen: default_walk,
          fn_map: fn_map
        });
        return fn_map;
      };
    });
  })(this)();

}).call(window.require_register("./transforms/collect_fn_call"));
/*/lib/transforms/placeholder_replace.js*/(function() {
  var default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  walk = function(root, ctx) {
    var list, v, _i, _len, _ref;
    walk = ctx.walk;
    switch (root.constructor.name) {
      case "Scope":
        root = ctx.next_gen(root, ctx);
        list = [];
        _ref = root.list;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          if (v.constructor.name === "Scope") {
            list.append(v.list);
          } else {
            list.push(v);
          }
        }
        root.list = list;
        return root;
      case "Comment":
        if (root.text !== "COMPILER MSG PlaceholderStatement") {
          return root;
        }
        return ctx.target_ast.clone();
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.placeholder_replace = function(root, target_ast) {
    return walk(root, {
      walk: walk,
      next_gen: default_walk,
      target_ast: target_ast
    });
  };

}).call(window.require_register("./transforms/placeholder_replace"));
/*/lib/transforms/var_translate.js*/(function() {
  var ast, config, default_walk, translate_var_name;

  default_walk = require("./default_walk").default_walk;

  translate_var_name = require("../translate_var_name").translate_var_name;

  config = require("../config");

  ast = require("../ast");

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        var arg, idx, library_name, name, prefix, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _var;
        switch (root.constructor.name) {
          case "Class_decl":
            ctx.current_class = root;
            if (root.is_library) {
              ctx.libraries[root.name] = true;
            }
            return default_walk(root, ctx);
          case "Var":
            root.name = translate_var_name(root.name);
            return root;
          case "Var_decl":
            if (root.assign_value) {
              root.assign_value = walk(root.assign_value, ctx);
            }
            root.name = translate_var_name(root.name);
            return root;
          case "Field_access":
            if (((_ref = root.t.type) != null ? _ref.main : void 0) === "enum") {
              name = translate_var_name(root.name, ctx);
              if (((_ref1 = root.t) != null ? _ref1.name : void 0) !== config.router_enum) {
                prefix = "";
                if (ctx.current_class.name) {
                  prefix = "" + ctx.current_class.name + "_";
                }
                root.name = "" + (translate_var_name(prefix + root.t.name)) + "_" + root.name;
              } else {
                name = "" + (ctx.current_class.name.toUpperCase()) + "_" + name;
                root.name = "" + name + "(unit)";
              }
            }
            root.name = translate_var_name(root.name);
            return default_walk(root, ctx);
          case "Var_decl_multi":
            if (root.assign_value) {
              root.assign_value = walk(root.assign_value, ctx);
            }
            _ref2 = root.list;
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              _var = _ref2[_i];
              _var.name = translate_var_name(_var.name);
            }
            return root;
          case "Fn_decl_multiret":
            name = root.name;
            if ((_ref3 = ctx.current_class) != null ? _ref3.is_library : void 0) {
              name = "" + ctx.current_class.name + "_" + name;
            }
            root.name = translate_var_name(name);
            root.scope = walk(root.scope, ctx);
            _ref4 = root.arg_name_list;
            for (idx = _j = 0, _len1 = _ref4.length; _j < _len1; idx = ++_j) {
              name = _ref4[idx];
              root.arg_name_list[idx] = translate_var_name(name);
            }
            return root;
          case "Fn_call":
            name = root.fn.name;
            if (root.fn.constructor.name === "Var") {
              if (((_ref5 = ctx.current_class) != null ? _ref5.is_library : void 0) && ctx.current_class._prepared_field2type[name]) {
                root.fn.name = "" + ctx.current_class.name + "_" + name;
              }
            } else if (root.fn.constructor.name === "Field_access") {
              library_name = root.fn.t.name;
              if (ctx.libraries.hasOwnProperty(library_name)) {
                name = "" + library_name + "_" + name;
                root.fn = new ast.Var;
                root.fn.name = name;
              }
            }
            return default_walk(root, ctx);
          case "Enum_decl":
            root.name = translate_var_name(root.name);
            _ref6 = root.value_list;
            for (idx = _k = 0, _len2 = _ref6.length; _k < _len2; idx = ++_k) {
              value = _ref6[idx];
              root.value_list[idx].name = "" + value.name;
            }
            return root;
          case "Event_decl":
            _ref7 = root.arg_list;
            for (idx = _l = 0, _len3 = _ref7.length; _l < _len3; idx = ++_l) {
              arg = _ref7[idx];
              root.arg_list[idx]._name = translate_var_name(arg._name);
            }
            return root;
          default:
            return default_walk(root, ctx);
        }
      };
      return _this.var_translate = function(root, ctx) {
        return walk(root, {
          walk: walk,
          next_gen: default_walk,
          libraries: {}
        });
      };
    });
  })(this)();

}).call(window.require_register("./transforms/var_translate"));
/*/lib/transforms/require_distinguish.js*/(function() {
  var default_walk, module;

  default_walk = require("./default_walk").default_walk;

  module = this;

  this.walk = function(root, ctx) {
    var walk;
    walk = ctx.walk;
    switch (root.constructor.name) {
      case "Fn_call":
        if (root.fn.constructor.name === "Var") {
          if (root.fn.name === "require") {
            if (root.arg_list.length === 2) {
              root.fn.name = "require2";
            }
          }
        }
        return ctx.next_gen(root, ctx);
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.require_distinguish = function(root) {
    return module.walk(root, {
      walk: module.walk,
      next_gen: default_walk
    });
  };

}).call(window.require_register("./transforms/require_distinguish"));
/*/lib/transforms/fix_missing_emit.js*/(function() {
  var ast, default_walk;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        var args, ret;
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "Event_decl":
            ctx.emit_decl_map[root.name] = true;
            return root;
          case "Fn_call":
            if (root.fn.constructor.name === "Var") {
              if (ctx.emit_decl_map.hasOwnProperty(root.fn.name)) {
                perr("WARNING (AST transform). EmitStatement is not supported. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#solidity-events");
                ret = new ast.Comment;
                args = root.arg_list.map(function(arg) {
                  return arg.name;
                });
                ret.text = "EmitStatement " + root.fn.name + "(" + (args.join(", ")) + ")";
                return ret;
              }
            }
            return ctx.next_gen(root, ctx);
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.fix_missing_emit = function(root) {
        return walk(root, {
          walk: walk,
          next_gen: default_walk,
          emit_decl_map: {}
        });
      };
    });
  })(this)();

}).call(window.require_register("./transforms/fix_missing_emit"));
/*/lib/transforms/fix_modifier_order.js*/(function() {
  var collect_fn_call, default_walk;

  default_walk = require("./default_walk").default_walk;

  collect_fn_call = require("./collect_fn_call").collect_fn_call;

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        var change_count, clone_fn_dep_map_map, fn, fn_decl, fn_dep_map_map, fn_left_name_list, fn_list, fn_map, fn_move_list, fn_name, fn_use_map, fn_use_refined_map, i, idx, k, min_idx, move_entity, name, old_idx, retry_count, use_list, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _p, _ref;
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "Class_decl":
            for (retry_count = _i = 0; _i < 5; retry_count = ++_i) {
              if (retry_count) {
                perr("NOTE method reorder requires additional attempt retry_count=" + retry_count + ". That's not good, but we try resolve that");
              }
              fn_list = [];
              _ref = root.scope.list;
              for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                v = _ref[_j];
                if (v.constructor.name !== "Fn_decl_multiret") {
                  continue;
                }
                fn_list.push(v);
              }
              fn_map = {};
              for (_k = 0, _len1 = fn_list.length; _k < _len1; _k++) {
                fn = fn_list[_k];
                fn_map[fn.name] = fn;
              }
              fn_dep_map_map = {};
              for (_l = 0, _len2 = fn_list.length; _l < _len2; _l++) {
                fn = fn_list[_l];
                fn_use_map = collect_fn_call(fn);
                fn_use_refined_map = {};
                for (k in fn_use_map) {
                  v = fn_use_map[k];
                  if (!fn_map.hasOwnProperty(k)) {
                    continue;
                  }
                  fn_use_refined_map[k] = v;
                }
                if (fn_use_refined_map.hasOwnProperty(fn.name)) {
                  delete fn_use_refined_map[fn.name];
                  perr("WARNING (AST transform). We found that function " + fn.name + " has self recursion. This will produce uncompilable target. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#self-recursion--function-calls");
                }
                fn_dep_map_map[fn.name] = fn_use_refined_map;
              }
              clone_fn_dep_map_map = deep_clone(fn_dep_map_map);
              fn_move_list = [];
              for (i = _m = 0; _m < 100; i = ++_m) {
                change_count = 0;
                fn_left_name_list = Object.keys(clone_fn_dep_map_map);
                for (_n = 0, _len3 = fn_left_name_list.length; _n < _len3; _n++) {
                  fn_name = fn_left_name_list[_n];
                  if (0 === h_count(clone_fn_dep_map_map[fn_name])) {
                    change_count++;
                    use_list = [];
                    delete clone_fn_dep_map_map[fn_name];
                    for (k in clone_fn_dep_map_map) {
                      v = clone_fn_dep_map_map[k];
                      if (v[fn_name]) {
                        delete v[fn_name];
                        use_list.push(k);
                      }
                    }
                    if (use_list.length) {
                      fn_move_list.push({
                        fn_name: fn_name,
                        use_list: use_list
                      });
                    }
                  }
                }
                if (change_count === 0) {
                  break;
                }
              }
              if (0 !== h_count(clone_fn_dep_map_map)) {
                perr(clone_fn_dep_map_map);
                perr("WARNING (AST transform). Can't reorder methods. Loop detected. This will produce uncompilable target. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#self-recursion--function-calls");
                break;
              }
              if (fn_move_list.length === 0) {
                break;
              }
              fn_move_list.reverse();
              change_count = 0;
              for (_o = 0, _len4 = fn_move_list.length; _o < _len4; _o++) {
                move_entity = fn_move_list[_o];
                fn_name = move_entity.fn_name, use_list = move_entity.use_list;
                min_idx = Infinity;
                for (_p = 0, _len5 = use_list.length; _p < _len5; _p++) {
                  name = use_list[_p];
                  fn = fn_map[name];
                  idx = root.scope.list.idx(fn);
                  min_idx = Math.min(min_idx, idx);
                }
                fn_decl = fn_map[fn_name];
                old_idx = root.scope.list.idx(fn_decl);
                if (old_idx > min_idx) {
                  change_count++;
                  root.scope.list.remove_idx(old_idx);
                  root.scope.list.insert_after(min_idx - 1, fn_decl);
                }
              }
              if (change_count === 0) {
                break;
              }
            }
            return ctx.next_gen(root, ctx);
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.fix_modifier_order = function(root) {
        return walk(root, {
          walk: walk,
          next_gen: default_walk
        });
      };
    });
  })(this)();

}).call(window.require_register("./transforms/fix_modifier_order"));
/*/lib/transforms/for3_unpack.js*/(function() {
  var Type, ast, default_walk;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  Type = window.Type;

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        var ret, while_inside;
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "For3":
            ret = new ast.Scope;
            ret.need_nest = false;
            if (root.init) {
              ret.list.push(root.init);
            }
            while_inside = new ast.While;
            if (root.cond) {
              while_inside.cond = root.cond;
            } else {
              while_inside.cond = new ast.Const;
              while_inside.cond.val = "true";
              while_inside.cond.type = new Type("bool");
            }
            while_inside.scope.list.append(root.scope.list);
            if (root.iter) {
              while_inside.scope.list.push(root.iter);
            }
            ret.list.push(while_inside);
            return ret;
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.for3_unpack = function(root) {
        return walk(root, {
          walk: walk,
          next_gen: default_walk
        });
      };
    });
  })(this)();

}).call(window.require_register("./transforms/for3_unpack"));
/*/lib/transforms/math_funcs_convert.js*/(function() {
  var ast, default_walk;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        var add, addmod, mul, mulmod;
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "Fn_call":
            if (root.fn.constructor.name === "Var") {
              switch (root.fn.name) {
                case "addmod":
                  add = new ast.Bin_op;
                  add.op = "ADD";
                  add.a = root.arg_list[0];
                  add.b = root.arg_list[1];
                  addmod = new ast.Bin_op;
                  addmod.op = "MOD";
                  addmod.b = root.arg_list[2];
                  addmod.a = add;
                  perr("WARNING (AST transform). `addmod` translation may compute incorrectly due to possible overflow. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#number-types");
                  return addmod;
                case "mulmod":
                  mul = new ast.Bin_op;
                  mul.op = "MUL";
                  mul.a = root.arg_list[0];
                  mul.b = root.arg_list[1];
                  mulmod = new ast.Bin_op;
                  mulmod.op = "MOD";
                  mulmod.b = root.arg_list[2];
                  mulmod.a = mul;
                  perr("WARNING (AST transform). `mulmod` translation may compute incorrectly due to possible overflow. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#number-types");
                  return mulmod;
              }
            }
            return root;
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.math_funcs_convert = function(root, ctx) {
        return walk(root, obj_merge({
          walk: walk,
          next_gen: default_walk
        }, ctx));
      };
    });
  })(this)();

}).call(window.require_register("./transforms/math_funcs_convert"));
/*/lib/transforms/ass_op_unpack.js*/(function() {
  var ast, default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  walk = function(root, ctx) {
    var ext, reg_ret;
    walk = ctx.walk;
    switch (root.constructor.name) {
      case "Bin_op":
        if (reg_ret = /^ASS_(.*)/.exec(root.op)) {
          ext = new ast.Bin_op;
          ext.op = "ASSIGN";
          ext.a = root.a.clone();
          ext.b = root;
          root.op = reg_ret[1];
          return ext;
        } else {
          root.a = walk(root.a, ctx);
          root.b = walk(root.b, ctx);
          return root;
        }
        break;
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.ass_op_unpack = function(root) {
    return walk(root, {
      walk: walk,
      next_gen: default_walk
    });
  };

}).call(window.require_register("./transforms/ass_op_unpack"));
/*/lib/transforms/modifier_unpack.js*/(function() {
  var ast, default_walk, placeholder_replace;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  placeholder_replace = require("./placeholder_replace").placeholder_replace;

  (function(_this) {
    return (function() {
      var fn_apply_modifier, walk;
      fn_apply_modifier = function(fn, mod, ctx) {

        /*
        Possible intersections
          1. Var_decl
          2. Var_decl in arg_list
          3. Multiple placeholders = multiple cloned Var_decl
         */
        var arg, idx, mod_decl, prepend_list, ret, var_decl, _i, _len, _ref;
        if (mod.fn.constructor.name !== "Var") {
          throw new Error("unimplemented");
        }
        if (!ctx.modifier_map.hasOwnProperty(mod.fn.name)) {
          throw new Error("unknown modifier " + mod.fn.name);
        }
        mod_decl = ctx.modifier_map[mod.fn.name];
        ret = mod_decl.scope.clone();
        prepend_list = [];
        _ref = mod.arg_list;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          arg = _ref[idx];
          if (arg.name === mod_decl.arg_name_list[idx]) {
            continue;
          }
          prepend_list.push(var_decl = new ast.Var_decl);
          var_decl.name = mod_decl.arg_name_list[idx];
          var_decl.assign_value = arg.clone();
          var_decl.type = mod_decl.type_i.nest_list[idx];
        }
        ret = placeholder_replace(ret, fn);
        ret.list = arr_merge(prepend_list, ret.list);
        return ret;
      };
      walk = function(root, ctx) {
        var idx, inner, mod, ret, _i, _len, _ref;
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "Fn_decl_multiret":
            if (root.is_modifier) {
              ctx.modifier_map[root.name] = root;
              ret = new ast.Comment;
              ret.text = "modifier " + root.name + " inlined";
              return ret;
            } else {
              if (root.is_constructor) {
                ctx.modifier_map[root.contract_name] = root;
              }
              if (root.modifier_list.length === 0) {
                return root;
              }
              inner = root.scope.clone();
              _ref = root.modifier_list;
              for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
                mod = _ref[idx];
                inner.need_nest = false;
                inner = fn_apply_modifier(inner, mod, ctx);
              }
              inner.need_nest = true;
              ret = root.clone();
              ret.modifier_list.clear();
              ret.scope = inner;
              return ret;
            }
            break;
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.modifier_unpack = function(root) {
        return walk(root, {
          walk: walk,
          next_gen: default_walk,
          modifier_map: {}
        });
      };
    });
  })(this)();

}).call(window.require_register("./transforms/modifier_unpack"));
/*/lib/transforms/inheritance_unpack.js*/(function() {
  var Type, ast, default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  Type = window.Type;

  ast = require("../ast");

  walk = function(root, ctx) {
    var add_fn_decl, class_decl, class_set, fn_call, fn_decl_set, found_constructor, i, inheritance_apply_list, inheritance_list, is_constructor_name, look_list, need_constuctor, need_lookup_list, new_name, old, parent, pick_name, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref, _ref1, _ref2, _ref3;
    switch (root.constructor.name) {
      case "Fn_call":
        if (root.fn.constructor.name === "Field_access") {
          if (root.fn.t.constructor.name === "Var") {
            if (root.fn.t.name === "super") {
              if (new_name = ctx.fn_dedupe_translate_map.get(root.fn.name)) {
                root.fn.name = new_name;
              }
            }
          }
        }
        return root;
      case "Class_decl":
        ctx.fn_dedupe_translate_map = new Map();
        is_constructor_name = function(name) {
          return name === "constructor" || name === root.name;
        };
        root = ctx.next_gen(root, ctx);
        ctx.class_map[root.name] = root;
        if (!root.inheritance_list.length) {
          return root;
        }
        inheritance_apply_list = [];
        inheritance_list = root.inheritance_list;
        while (inheritance_list.length) {
          need_lookup_list = [];
          for (i = _i = _ref = inheritance_list.length - 1; _i >= 0; i = _i += -1) {
            v = inheritance_list[i];
            if (!ctx.class_map.hasOwnProperty(v.name)) {
              throw new Error("can't find parent class " + v.name);
            }
            class_decl = ctx.class_map[v.name];
            class_decl.need_skip = true;
            inheritance_apply_list.push(v);
            need_lookup_list.append(class_decl.inheritance_list);
          }
          inheritance_list = need_lookup_list;
        }
        root = root.clone();
        fn_decl_set = new Set();
        pick_name = function(start_name) {
          var try_name, _j;
          for (i = _j = 1; 1 <= Infinity ? _j < Infinity : _j > Infinity; i = 1 <= Infinity ? ++_j : --_j) {
            try_name = "" + start_name + "_" + i;
            if (!fn_decl_set.has(try_name)) {
              return try_name;
            }
          }
          throw new Error("unreachable");
        };
        add_fn_decl = function(v) {
          if (fn_decl_set.has(v.name)) {
            if (ctx.fn_dedupe_translate_map.has(v.name)) {
              perr("WARNING (AST transform). Only 1 level of shadowing is allowed. Translated code will be not functional");
            } else {
              new_name = pick_name(v.name);
              ctx.fn_dedupe_translate_map.set(v.name, new_name);
              v.visibility = "internal";
              v.name = new_name;
            }
          } else {
            fn_decl_set.add(v.name);
          }
        };
        _ref1 = root.scope.list;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          v = _ref1[_j];
          if (v.constructor.name !== "Fn_decl_multiret") {
            continue;
          }
          add_fn_decl(v);
        }
        class_set = new Set;
        for (_k = 0, _len1 = inheritance_apply_list.length; _k < _len1; _k++) {
          parent = inheritance_apply_list[_k];
          if (!ctx.class_map.hasOwnProperty(parent.name)) {
            throw new Error("can't find parent class " + parent.name);
          }
          class_decl = ctx.class_map[parent.name];
          if (class_set.has(parent.name)) {
            continue;
          }
          class_set.add(parent.name);
          if (class_decl.is_interface) {
            continue;
          }
          look_list = class_decl.scope.list;
          need_constuctor = null;
          for (_l = 0, _len2 = look_list.length; _l < _len2; _l++) {
            v = look_list[_l];
            if (v.constructor.name !== "Fn_decl_multiret") {
              continue;
            }
            v = v.clone();
            if (is_constructor_name(v.name)) {
              v.name = "" + parent.name + "_constructor";
              v.visibility = "internal";
              need_constuctor = v;
            }
            add_fn_decl(v);
            root.scope.list.unshift(v);
            _ref2 = root.scope.list;
            for (_m = 0, _len3 = _ref2.length; _m < _len3; _m++) {
              old = _ref2[_m];
              walk(old, ctx);
            }
          }
          for (_n = 0, _len4 = look_list.length; _n < _len4; _n++) {
            v = look_list[_n];
            if (v.constructor.name !== "Var_decl") {
              continue;
            }
            root.scope.list.unshift(v.clone());
          }
          if (!need_constuctor) {
            continue;
          }
          found_constructor = null;
          _ref3 = root.scope.list;
          for (_o = 0, _len5 = _ref3.length; _o < _len5; _o++) {
            v = _ref3[_o];
            if (v.constructor.name !== "Fn_decl_multiret") {
              continue;
            }
            if (!is_constructor_name(v.name)) {
              continue;
            }
            found_constructor = v;
            break;
          }
          if (!found_constructor) {
            root.scope.list.push(found_constructor = new ast.Fn_decl_multiret);
            found_constructor.name = "constructor";
            found_constructor.type_i = new Type("function");
            found_constructor.type_o = new Type("function");
          }
          found_constructor.scope.list.unshift(fn_call = new ast.Fn_call);
          fn_call.fn = new ast.Var;
          fn_call.fn.name = need_constuctor.name;
        }
        return root;
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.inheritance_unpack = function(root) {
    return walk(root, {
      walk: walk,
      next_gen: default_walk,
      class_map: {}
    });
  };

}).call(window.require_register("./transforms/inheritance_unpack"));
/*/lib/transforms/deep_check_storage_and_oplist_use.js*/(function() {
  var Type, ast, config, default_walk, translate_type, translate_var_name, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  translate_type = require("../translate_ligo").translate_type;

  translate_var_name = require("../translate_var_name").translate_var_name;

  walk = function(root, ctx) {
    var ctx_lvalue, found, idx, nest_fn, prev_class, synthetic_name, using, using_list, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _type;
    switch (root.constructor.name) {
      case "Un_op":
        switch (root.op) {
          case "RET_INC":
          case "RET_DEC":
          case "INC_RET":
          case "DEC_RET":
            ctx_lvalue = clone(ctx);
            ctx_lvalue.lvalue = true;
            root.a = walk(root.a, ctx_lvalue);
            break;
          case "DELETE":
            if (root.a.constructor.name === "Bin_op" && root.a.op === "INDEX_ACCESS") {
              ctx_lvalue = clone(ctx);
              ctx_lvalue.lvalue = true;
              root.a.a = walk(root.a.a, ctx_lvalue);
            } else {
              perr("WARNING (AST transform). DELETE without INDEX_ACCESS can be handled improperly (extra state pass + return)");
              root.a = walk(root.a, ctx_lvalue);
            }
            break;
          default:
            root.a = walk(root.a, ctx);
        }
        return root;
      case "Bin_op":
        if (/^ASS/.test(root.op)) {
          ctx_lvalue = clone(ctx);
          ctx_lvalue.lvalue = true;
          root.a = walk(root.a, ctx_lvalue);
        } else {
          root.a = walk(root.a, ctx);
        }
        root.b = walk(root.b, ctx);
        return root;
      case "Var_decl":
        if (!ctx.loc_var_decl && !root.is_enum_decl && !root.is_const) {
          ctx.global_var_decl_map.set(root.name, true);
        }
        if (root.assign_value != null) {
          walk(root.assign_value, ctx);
        }
        return root;
      case "Var_decl_multi":
        if (!ctx.loc_var_decl && !root.is_enum_decl) {
          _ref = root.list;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            ctx.global_var_decl_map.set(v.name, true);
          }
        }
        if (root.assign_value != null) {
          walk(root.assign_value, ctx);
        }
        return root;
      case "Var":
        if (ctx.global_var_decl_map.has(root.name)) {
          if (ctx.lvalue) {
            if (!ctx.modifies_storage.val) {
              ctx.modifies_storage.val = true;
              ctx.change_count.val++;
            }
          }
          if (!ctx.uses_storage.val) {
            ctx.uses_storage.val = true;
            ctx.change_count.val++;
          }
        }
        return root;
      case "Class_decl":
        prev_class = ctx.current_class;
        ctx.current_class = root;
        _ref1 = root.scope.list;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          v = _ref1[_j];
          walk(v, ctx);
        }
        ctx.current_class = prev_class;
        return root;
      case "Fn_call":
        if ((_ref2 = root.fn.name) === "transfer" || _ref2 === "send" || _ref2 === "call" || _ref2 === "built_in_pure_callback" || _ref2 === "delegatecall" || _ref2 === "transaction") {
          if (!ctx.returns_op_list.val) {
            ctx.returns_op_list.val = true;
            ctx.change_count.val++;
          }
        } else {
          switch (root.fn.constructor.name) {
            case "Var":
              if (nest_fn = ctx.fn_decl_map.get(root.fn.name)) {
                if (nest_fn.returns_op_list && !ctx.returns_op_list.val) {
                  ctx.returns_op_list.val = true;
                  ctx.change_count.val++;
                }
                if (nest_fn.uses_storage && !ctx.uses_storage.val) {
                  ctx.uses_storage.val = true;
                  ctx.change_count.val++;
                }
                if (nest_fn.modifies_storage && !ctx.modifies_storage.val) {
                  ctx.modifies_storage.val = true;
                  ctx.change_count.val++;
                }
                root.fn_decl = nest_fn;
              }
              break;
            case "Field_access":
              if (root.fn.t.constructor.name === "Var" && root.fn.t.name === "this") {
                if (nest_fn = ctx.fn_decl_map.get(root.fn.name)) {
                  if (nest_fn.returns_op_list && !ctx.returns_op_list.val) {
                    ctx.returns_op_list.val = true;
                    ctx.change_count.val++;
                  }
                  if (nest_fn.uses_storage && !ctx.uses_storage.val) {
                    ctx.uses_storage.val = true;
                    ctx.change_count.val++;
                  }
                  if (nest_fn.modifies_storage && !ctx.modifies_storage.val) {
                    ctx.modifies_storage.val = true;
                    ctx.change_count.val++;
                  }
                  root.fn_decl = nest_fn;
                } else if (ctx.global_var_decl_map.has(root.fn.name)) {
                  if (ctx.lvalue) {
                    if (!ctx.modifies_storage.val) {
                      ctx.modifies_storage.val = true;
                      ctx.change_count.val++;
                    }
                  }
                  if (!ctx.uses_storage.val) {
                    ctx.uses_storage.val = true;
                    ctx.change_count.val++;
                  }
                }
              } else if (root.fn.name === "push") {
                ctx_lvalue = clone(ctx);
                ctx_lvalue.lvalue = true;
                root.fn = walk(root.fn, ctx_lvalue);
              } else {
                found = false;
                _ref3 = ctx.current_class.using_map;
                for (_type in _ref3) {
                  using_list = _ref3[_type];
                  for (_k = 0, _len2 = using_list.length; _k < _len2; _k++) {
                    using = using_list[_k];
                    synthetic_name = translate_var_name("" + using + "_" + root.fn.name, null);
                    if (nest_fn = ctx.fn_decl_map.get(synthetic_name)) {
                      if (nest_fn.returns_op_list && !ctx.returns_op_list.val) {
                        ctx.returns_op_list.val = true;
                        ctx.change_count.val++;
                      }
                      if (nest_fn.uses_storage && !ctx.uses_storage.val) {
                        ctx.uses_storage.val = true;
                        ctx.change_count.val++;
                      }
                      if (nest_fn.modifies_storage && !ctx.modifies_storage.val) {
                        ctx.modifies_storage.val = true;
                        ctx.change_count.val++;
                      }
                      root.fn_decl = nest_fn;
                      root.is_fn_decl_from_using = true;
                      root.fn_name_using = synthetic_name;
                      found = true;
                      break;
                    }
                  }
                  if (found) {
                    break;
                  }
                }
              }
          }
        }
        _ref4 = root.arg_list;
        for (idx = _l = 0, _len3 = _ref4.length; _l < _len3; idx = ++_l) {
          v = _ref4[idx];
          root.arg_list[idx] = walk(v, ctx);
        }
        root.fn = walk(root.fn, ctx);
        return root;
      case "Fn_decl_multiret":
        ctx.fn_decl_map.set(root.name, root);
        ctx.returns_op_list = {
          val: root.returns_op_list
        };
        ctx.uses_storage = {
          val: root.uses_storage
        };
        ctx.modifies_storage = {
          val: root.modifies_storage
        };
        ctx.loc_var_decl = true;
        root.scope = walk(root.scope, ctx);
        root.returns_op_list = ctx.returns_op_list.val;
        root.uses_storage = ctx.uses_storage.val;
        root.modifies_storage = ctx.modifies_storage.val;
        root.returns_value = root.type_o.nest_list.length > 0;
        ctx.loc_var_decl = false;
        return root;
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.deep_check_storage_and_oplist_use = function(root, ctx) {
    var prevent_loop, _i;
    ctx = {
      walk: walk,
      next_gen: default_walk,
      change_count: {
        val: 1
      },
      global_var_decl_map: new Map,
      fn_decl_map: new Map,
      current_class: null
    };
    for (prevent_loop = _i = 0; _i < 100; prevent_loop = ++_i) {
      if (ctx.change_count.val === 0) {
        break;
      }
      ctx.change_count.val = 0;
      root = walk(root, ctx);
    }
    if (ctx.change_count.val) {
      perr("WARNING (AST transform). prevent infinite loop trigger catched. Please notify developer about it with code example. Generated code can be invalid");
    }
    return root;
  };

}).call(window.require_register("./transforms/deep_check_storage_and_oplist_use"));
/*/lib/transforms/decl_storage_and_oplist_inject.js*/(function() {
  var Type, ast, config, default_walk, translate_type, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  translate_type = require("../translate_ligo").translate_type;

  walk = function(root, ctx) {
    var idx, inject, last, state_name, v, _i, _len, _ref;
    switch (root.constructor.name) {
      case "Ret_multi":
        _ref = root.t_list;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          v = _ref[idx];
          root.t_list[idx] = walk(v, ctx);
        }
        if (ctx.modifies_storage) {
          root.t_list.unshift(inject = new ast.Var);
          inject.name = config.contract_storage;
          inject.name_translate = false;
        }
        if (ctx.returns_op_list) {
          root.t_list.unshift(inject = new ast.Const);
          inject.type = new Type("built_in_op_list");
          inject.val = config.op_list;
        }
        return root;
      case "Fn_decl_multiret":
        ctx.returns_op_list = root.returns_op_list;
        ctx.uses_storage = root.uses_storage;
        ctx.modifies_storage = root.modifies_storage;
        root.scope = walk(root.scope, ctx);
        state_name = config.storage;
        if (root.uses_storage) {
          root.arg_name_list.unshift(config.contract_storage);
          root.type_i.nest_list.unshift(new Type(state_name));
        }
        if (root.modifies_storage) {
          root.type_o.nest_list.unshift(new Type(state_name));
        }
        if (root.returns_op_list) {
          root.arg_name_list.unshift(config.op_list);
          root.type_i.nest_list.unshift(new Type("built_in_op_list"));
          root.type_o.nest_list.unshift(new Type("built_in_op_list"));
        }
        last = root.scope.list.last();
        if (!last || last.constructor.name !== "Ret_multi") {
          last = new ast.Ret_multi;
          last = walk(last, ctx);
          root.scope.list.push(last);
        }
        last = root.scope.list.last();
        return root;
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.decl_storage_and_oplist_inject = function(root, ctx) {
    return walk(root, obj_merge({
      walk: walk,
      next_gen: default_walk
    }));
  };

}).call(window.require_register("./transforms/decl_storage_and_oplist_inject"));
/*/lib/transforms/mark_last.js*/(function() {
  this.mark_last = function(root, opt) {
    var last_contract, seek_contract, v, _i, _len, _ref;
    last_contract = null;
    seek_contract = null;
    _ref = root.list;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      if (v.constructor.name !== "Class_decl") {
        continue;
      }
      if (!v.is_contract) {
        continue;
      }
      last_contract = v;
      if (opt.contract != null) {
        if (v.name === opt.contract) {
          seek_contract = v;
        }
      }
    }
    if (last_contract) {
      last_contract.is_last = true;
    }
    if (opt.contract != null) {
      if (!seek_contract) {
        if (opt.contract) {
          perr("WARNING (AST transform). Can't find contract '" + opt.contract + "' . Using last contract named '" + (last_contract != null ? last_contract.name : void 0) + "' instead");
        }
      } else {
        if (last_contract) {
          last_contract.is_last = false;
        }
        seek_contract.is_last = true;
      }
    }
    return root;
  };

}).call(window.require_register("./transforms/mark_last"));
/*/lib/transforms/router_collector.js*/(function() {
  var default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  walk = function(root, ctx) {
    var _ref;
    walk = ctx.walk;
    switch (root.constructor.name) {
      case "Class_decl":
        if (root.need_skip) {
          return root;
        }
        if (root.is_library) {
          return root;
        }
        if (root.is_contract && !root.is_last) {
          return root;
        }
        ctx.inheritance_list = root.inheritance_list;
        return ctx.next_gen(root, ctx);
      case "Fn_decl_multiret":
        if ((_ref = root.visibility) !== "private" && _ref !== "internal") {
          ctx.router_func_list.push(root);
        }
        return root;
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.router_collector = function(root, opt) {
    var ctx;
    walk(root, ctx = obj_merge({
      walk: walk,
      next_gen: default_walk,
      router_func_list: []
    }, opt));
    return ctx.router_func_list;
  };

}).call(window.require_register("./transforms/router_collector"));
/*/lib/transforms/add_router.js*/(function() {
  var Type, ast, config, default_walk, func2args_struct, func2struct, translate_var_name, walk;

  default_walk = require("./default_walk").default_walk;

  translate_var_name = require("../translate_var_name").translate_var_name;

  ast = require("../ast");

  Type = window.Type;

  config = require("../config");

  func2args_struct = function(name) {
    name = name + "_args";
    name = translate_var_name(name, null);
    return name;
  };

  func2struct = function(name) {
    var new_name;
    name = translate_var_name(name, null);
    name = name.capitalize();
    if (name.length > 31) {
      new_name = name.substr(0, 31);
      perr("WARNING (AST transform). Entrypoint names longer than 31 character are not supported in LIGO. We trimmed " + name + " to " + new_name + ". Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#name-length-for-types");
      name = new_name;
    }
    return name;
  };

  walk = function(root, ctx) {
    var access_gen, arg, arg_name, arg_num, call, comment, decl, func, idx, match_shoulder, ops_extract, proxy_call, record, ret, ret_tuple, ret_val, start, tmp, value, var_tmp, _case, _enum, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _main, _ref, _ref1, _ref2, _ref3, _ref4, _switch, _var;
    walk = ctx.walk;
    switch (root.constructor.name) {
      case "Class_decl":
        if (root.is_contract && root.is_last) {
          if (ctx.contract && root.name !== ctx.contract) {
            return ctx.next_gen(root, ctx);
          }
          _ref = ctx.router_func_list;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            func = _ref[_i];
            root.scope.list.push(record = new ast.Class_decl);
            record.name = func2args_struct(func.name);
            record.namespace_name = false;
            start = 0;
            if (func.uses_storage) {
              start++;
            }
            if (func.returns_op_list) {
              start++;
            }
            _ref1 = func.arg_name_list.slice(start);
            for (idx = _j = 0, _len1 = _ref1.length; _j < _len1; idx = ++_j) {
              value = _ref1[idx];
              record.scope.list.push(arg = new ast.Var_decl);
              arg.name = value;
              arg.type = func.type_i.nest_list[start + idx];
            }
            if (func.returns_value) {
              record.scope.list.push(arg = new ast.Var_decl);
              arg.name = config.callback_address;
              arg.type = new Type("address");
            }
          }
          root.scope.list.push(_enum = new ast.Enum_decl);
          _enum.name = config.router_enum;
          _ref2 = ctx.router_func_list;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            func = _ref2[_k];
            _enum.value_list.push(decl = new ast.Var_decl);
            decl.name = func2struct(func.name);
            decl.type = new Type(func2args_struct(func.name));
          }
          root.scope.list.push(_main = new ast.Fn_decl_multiret);
          _main.name = "main";
          _main.type_i = new Type("function");
          _main.type_o = new Type("function");
          _main.arg_name_list.push("action");
          _main.type_i.nest_list.push(new Type(config.router_enum));
          _main.arg_name_list.push(config.contract_storage);
          _main.type_i.nest_list.push(new Type(config.storage));
          _main.type_o.nest_list.push(new Type("built_in_op_list"));
          _main.type_o.nest_list.push(new Type(config.storage));
          _main.scope.need_nest = false;
          _main.scope.list.push(ret = new ast.Tuple);
          ret.list.push(_switch = new ast.PM_switch);
          _switch.cond = new ast.Var;
          _switch.cond.name = "action";
          _switch.cond.type = new Type("string");
          _ref3 = ctx.router_func_list;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            func = _ref3[_l];
            _switch.scope.list.push(_case = new ast.PM_case);
            _case.struct_name = func2struct(func.name);
            _case.var_decl.name = "match_action";
            _case.var_decl.type = new Type(_case.struct_name);
            call = new ast.Fn_call;
            call.left_unpack = false;
            call.fn = new ast.Var;
            call.fn.name = func.name;
            call.fn.type = new Type("function2");
            call.fn.type.nest_list[0] = func.type_i;
            call.fn.type.nest_list[1] = func.type_o;
            _ref4 = func.arg_name_list;
            for (idx = _m = 0, _len4 = _ref4.length; _m < _len4; idx = ++_m) {
              arg_name = _ref4[idx];
              switch (arg_name) {
                case config.contract_storage:
                  arg = new ast.Var;
                  arg.name = arg_name;
                  arg.type = new Type(config.storage);
                  arg.name_translate = false;
                  call.arg_list.push(arg);
                  break;
                case config.op_list:
                  arg = new ast.Const;
                  arg.type = new Type("built_in_op_list");
                  call.arg_list.push(arg);
                  break;
                default:
                  arg = new ast.Var;
                  arg.name = _case.var_decl.name;
                  arg.type = _case.var_decl.type;
                  call.arg_list.push(match_shoulder = new ast.Field_access);
                  match_shoulder.name = arg_name;
                  match_shoulder.t = arg;
              }
            }
            if (!func.returns_value && (func.returns_op_list || func.modifies_storage)) {
              _case.scope.need_nest = false;
              if (func.returns_op_list && func.modifies_storage) {
                _case.scope.list.push(call);
              } else {
                _case.scope.list.push(ret_tuple = new ast.Tuple);
                if (!func.returns_op_list) {
                  ret_tuple.list.push(_var = new ast.Const);
                  _var.type = new Type("built_in_op_list");
                }
                ret_tuple.list.push(call);
                if (!func.modifies_storage) {
                  ret_tuple.list.push(_var = new ast.Var);
                  _var.type = new Type(config.storage);
                  _var.name = config.contract_storage;
                  _var.name_translate = false;
                }
              }
            } else {
              _case.scope.need_nest = true;
              if (!func.returns_value) {
                _case.scope.list.push(comment = new ast.Comment);
                comment.text = "This function does nothing, but it's present in router";
                perr("WARNING (AST transform). Function named " + func.name + " does nothing, but we put it in the router nonetheless");
              }
              _case.scope.list.push(tmp = new ast.Var_decl);
              tmp.name = "tmp";
              tmp.assign_value = call;
              tmp.type = func.type_o.clone();
              tmp.type.main = "tuple";
              ret_tuple = new ast.Tuple;
              arg_num = 0;
              access_gen = function() {
                var tmp_access, var_tmp;
                tmp_access = new ast.Field_access;
                tmp_access.type = tmp.type.nest_list[arg_num];
                tmp_access.name = arg_num.toString();
                arg_num++;
                tmp_access.t = var_tmp = new ast.Var;
                var_tmp.name = "tmp";
                return tmp_access;
              };
              if (+func.returns_op_list + +func.modifies_storage + +func.returns_value === 1) {
                access_gen = function() {
                  var var_tmp;
                  var_tmp = new ast.Var;
                  var_tmp.name = "tmp";
                  var_tmp.type = tmp.type.nest_list[0];
                  return var_tmp;
                };
              }
              if (func.returns_op_list) {
                ret_tuple.list.push(access_gen());
              } else {
                if (func.returns_value) {
                  ret_tuple.list.push(_var = new ast.Var);
                  _var.name = config.op_list;
                } else {
                  ret_tuple.list.push(_var = new ast.Const);
                  _var.type = new Type("built_in_op_list");
                }
              }
              if (func.modifies_storage) {
                ret_tuple.list.push(access_gen());
              } else {
                ret_tuple.list.push(_var = new ast.Var);
                _var.type = new Type(config.storage);
                _var.name = config.contract_storage;
                _var.name_translate = false;
              }
              arg_num = 0;
              ret_val = access_gen();
              if (func.returns_value) {
                _case.scope.list.push(proxy_call = new ast.Fn_call);
                proxy_call.fn = new ast.Var;
                if (func.returns_op_list) {
                  ops_extract = new ast.Field_access;
                  ops_extract.name = "0";
                  ops_extract.t = var_tmp = new ast.Var;
                  var_tmp.name = "tmp";
                  var_tmp.type = tmp.type.clone();
                  ops_extract.type = tmp.type.nest_list[0].clone();
                  proxy_call.fn.name = "@respond_append";
                  proxy_call.arg_list = [ops_extract, ret_val];
                } else {
                  proxy_call.fn.name = "@respond";
                  proxy_call.arg_list = [ret_val];
                }
              }
              _case.scope.list.push(ret = new ast.Ret_multi);
              ret.t_list.push(ret_tuple);
            }
          }
          return root;
        } else {
          return ctx.next_gen(root, ctx);
        }
        break;
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.add_router = function(root, ctx) {
    return walk(root, obj_merge({
      walk: walk,
      next_gen: default_walk
    }, ctx));
  };

}).call(window.require_register("./transforms/add_router"));
/*/lib/transforms/collect_fn_decl.js*/(function() {
  var default_walk;

  default_walk = require("./default_walk").default_walk;

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "Fn_decl_multiret":
            ctx.fn_map[root.name] = root;
            return ctx.next_gen(root, ctx);
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.collect_fn_decl = function(root) {
        var fn_map;
        fn_map = {};
        walk(root, {
          walk: walk,
          next_gen: default_walk,
          fn_map: fn_map
        });
        return fn_map;
      };
    });
  })(this)();

}).call(window.require_register("./transforms/collect_fn_decl"));
/*/lib/transforms/call_storage_and_oplist_inject.js*/(function() {
  var Type, ast, config, default_var_map_gen, default_walk, ti_map, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  default_var_map_gen = require("../type_inference/common").default_var_map_gen;

  ti_map = default_var_map_gen();

  walk = function(root, ctx) {
    var storage;
    walk = ctx.walk;
    switch (root.constructor.name) {
      case "Fn_call":
        if (ti_map.hasOwnProperty(root.fn.name)) {
          return ctx.next_gen(root, ctx);
        }
        if (!root.fn_decl) {
          perr("WARNING (AST transform). no Fn_decl for Fn call named " + root.fn.name);
          return ctx.next_gen(root, ctx);
        }
        if (root.fn_decl.uses_storage) {
          root.arg_list.unshift(storage = new ast.Var);
          storage.name = config.contract_storage;
          storage.type = new Type(config.storage);
          storage.name_translate = false;
        }
        return ctx.next_gen(root, ctx);
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.call_storage_and_oplist_inject = function(root, ctx) {
    return walk(root, ctx = obj_merge({
      walk: walk,
      next_gen: default_walk
    }, ctx));
  };

}).call(window.require_register("./transforms/call_storage_and_oplist_inject"));
/*/lib/transforms/replace_enums_by_nat.js*/(function() {
  var Type, ast, default_walk;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  Type = window.Type;

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        var decl, idx, ret, type, v, value, _i, _j, _len, _len1, _ref, _ref1, _ref2;
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "Scope":
            if (root.original_node_type === "SourceUnit") {
              ctx.enums_map = new Map;
              ctx.new_declarations = [];
              root = ctx.next_gen(root, ctx);
              root.list = ctx.new_declarations.concat(root.list);
              return root;
            } else {
              return ctx.next_gen(root, ctx);
            }
            break;
          case "Enum_decl":
            ctx.enums_map.set(root.name, true);
            _ref = root.value_list;
            for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
              value = _ref[idx];
              decl = new ast.Var_decl;
              decl.name = "" + root.name + "_" + value.name;
              decl.type = new Type("uint");
              decl.assign_value = new ast.Const;
              decl.assign_value.type = new Type("uint");
              decl.assign_value.val = idx;
              decl.is_enum_decl = true;
              ctx.new_declarations.push(decl);
            }
            ret = new ast.Comment;
            ret.text = "enum " + root.name + " converted into list of nats";
            return ret;
          case "Var_decl":
            if (root.type) {
              if (root.type.main === "map") {
                _ref2 = (_ref1 = root.type) != null ? _ref1.nest_list : void 0;
                for (idx = _j = 0, _len1 = _ref2.length; _j < _len1; idx = ++_j) {
                  type = _ref2[idx];
                  if (ctx.enums_map.has(type.main)) {
                    root.type.nest_list[idx] = new Type("uint");
                  }
                }
              } else {
                if (ctx.enums_map.has(root.type.main)) {
                  root.type = new Type("uint");
                }
              }
            }
            return ctx.next_gen(root, ctx);
          case "Field_access":
            if (root.t.constructor.name === "Var") {
              if (ctx.enums_map.has(root.t.name)) {
                v = new ast.Var;
                v.name = "" + root.t.name + "_" + root.name;
                v.type = new Type("nat");
                return v;
              }
            }
            return ctx.next_gen(root, ctx);
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.replace_enums_by_nat = function(root, ctx) {
        return walk(root, {
          walk: walk,
          next_gen: default_walk
        });
      };
    });
  })(this)();

}).call(window.require_register("./transforms/replace_enums_by_nat"));
/*/lib/transforms/intrinsics_converter.js*/(function() {
  var Type, ast, default_walk, module, timestamp_node;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  Type = window.Type;

  module = this;

  timestamp_node = function() {
    var timestamp;
    timestamp = new ast.Bin_op;
    timestamp.op = "SUB";
    timestamp.a = new ast.Var;
    timestamp.a.name = "@now";
    timestamp.a.name_translate = false;
    timestamp.b = new ast.Type_cast;
    timestamp.b.target_type = new Type("timestamp");
    timestamp.b.t = new ast.Const;
    timestamp.b.t.type = new Type("string");
    timestamp.b.t.val = "1970-01-01T00:00:00Z";
    timestamp.a.type = new Type("uint");
    timestamp.b.type = new Type("uint");
    return timestamp;
  };

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        var ret;
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "Var":
            if (root.name === "now") {
              return timestamp_node();
            }
            return ctx.next_gen(root, ctx);
          case "Field_access":
            switch (root.t.name) {
              case "block":
                if (root.name === "timestamp") {
                  return timestamp_node();
                }
                break;
              case "msg":
                switch (root.name) {
                  case "sender":
                    root.t.name = "@Tezos";
                    root.name = "@sender";
                    break;
                  case "value":
                    ret = new ast.Bin_op;
                    ret.op = "DIV";
                    ret.a = new ast.Var;
                    ret.a.name = "@amount";
                    ret.a.type = new Type("uint");
                    ret.b = new ast.Const;
                    ret.b.val = 1;
                    ret.b.type = new Type("mutez");
                    return ctx.next_gen(ret, ctx);
                }
                break;
              case "tx":
                if (root.name === "origin") {
                  root.t.name = "@Tezos";
                  root.name = "@source";
                }
            }
            return ctx.next_gen(root, ctx);
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.intrinsics_converter = function(root) {
        return walk(root, {
          walk: walk,
          next_gen: default_walk
        });
      };
    });
  })(this)();

}).call(window.require_register("./transforms/intrinsics_converter"));
/*/lib/transforms/erc20_converter.js*/(function() {
  var Type, ast, astBuilder, callback_tx_node, config, default_walk, tx_node, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  astBuilder = require("../ast_builder");

  tx_node = function(address_expr, arg_list, name, ctx) {
    var entrypoint, enum_val, tx;
    address_expr = astBuilder.contract_addr_transform(address_expr);
    entrypoint = astBuilder.foreign_entrypoint(address_expr, "fa12_action");
    enum_val = astBuilder.enum_val("@" + name, arg_list);
    tx = astBuilder.transaction([enum_val], entrypoint);
    return tx;
  };

  callback_tx_node = function(name, root, ctx) {
    var arg_list, cb_decl, cb_name, contract_type, return_callback, return_type;
    cb_name = name.substr(0, 1).toLowerCase() + name.substr(1) + "Callback";
    contract_type = new Type("contract");
    contract_type.val = "nat";
    return_callback = astBuilder.self_entrypoint("%" + cb_name, contract_type);
    if (!ctx.callbacks_to_declare_map.has(cb_name)) {
      return_type = root.fn.type.nest_list[ast.RETURN_VALUES].nest_list[ast.INPUT_ARGS];
      cb_decl = astBuilder.callback_declaration(name, return_type);
      ctx.callbacks_to_declare_map.set(cb_name, cb_decl);
    }
    arg_list = root.arg_list;
    arg_list.push(return_callback);
    return tx_node(root.fn.t, arg_list, name, ctx);
  };

  walk = function(root, ctx) {
    var arg_list, ret, sender, _ref, _ref1;
    switch (root.constructor.name) {
      case "Class_decl":
        ctx.callbacks_to_declare_map = new Map;
        root = ctx.next_gen(root, ctx);
        ctx.callbacks_to_declare_map.forEach(function(decl) {
          return root.scope.list.unshift(decl);
        });
        return root;
      case "Var_decl":
        if (((_ref = root.type) != null ? _ref.main : void 0) === ctx.interface_name) {
          root.type = new Type("address");
        }
        return ctx.next_gen(root, ctx);
      case "Fn_decl_multiret":
        ctx.current_scope_ops_count = 0;
        return ctx.next_gen(root, ctx);
      case "Fn_call":
        if (root.fn.name === ctx.interface_name) {
          return astBuilder.cast_to_address(root.arg_list[0]);
        }
        if ((_ref1 = root.fn.t) != null ? _ref1.type : void 0) {
          switch (root.fn.t.type.main) {
            case "struct":
            case ctx.interface_name:
              switch (root.fn.name) {
                case "transfer":
                  sender = astBuilder.tezos_var("sender");
                  arg_list = root.arg_list;
                  arg_list.unshift(sender);
                  return tx_node(root.fn.t, arg_list, "Transfer", ctx);
                case "approve":
                  arg_list = root.arg_list;
                  arg_list[0] = astBuilder.cast_to_address(arg_list[0]);
                  return tx_node(root.fn.t, arg_list, "Approve", ctx);
                case "transferFrom":
                  arg_list = root.arg_list;
                  arg_list[1] = astBuilder.cast_to_address(arg_list[1]);
                  return tx_node(root.fn.t, arg_list, "Transfer", ctx);
                case "allowance":
                  ret = root;
                  ret.arg_list[0] = astBuilder.cast_to_address(ret.arg_list[0]);
                  ret.arg_list[1] = astBuilder.cast_to_address(ret.arg_list[1]);
                  return callback_tx_node("GetAllowance", ret, ctx);
                case "balanceOf":
                  ret = root;
                  ret.arg_list[0] = astBuilder.cast_to_address(ret.arg_list[0]);
                  return callback_tx_node("GetBalance", ret, ctx);
                case "totalSupply":
                  ret = root;
                  ret.arg_list.unshift(astBuilder.unit());
                  return callback_tx_node("GetTotalSupply", ret, ctx);
              }
          }
        }
        return ctx.next_gen(root, ctx);
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.erc20_converter = function(root, ctx) {
    var init_ctx;
    init_ctx = {
      walk: walk,
      next_gen: default_walk
    };
    return walk(root, obj_merge(init_ctx, ctx));
  };

}).call(window.require_register("./transforms/erc20_converter"));
/*/lib/transforms/erc721_converter.js*/(function() {
  var Type, ast, astBuilder, config, declare_callback, default_walk, tx_node, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  astBuilder = require("../ast_builder");

  declare_callback = function(name, arg_type, ctx) {
    var cb_decl;
    if (!ctx.callbacks_to_declare_map.has(name)) {
      cb_decl = astBuilder.callback_declaration(name, arg_type);
      return ctx.callbacks_to_declare_map.set(name, cb_decl);
    }
  };

  tx_node = function(address_expr, arg_list, ctx) {
    var entrypoint, tx;
    address_expr = astBuilder.contract_addr_transform(address_expr);
    entrypoint = astBuilder.foreign_entrypoint(address_expr, "fa2_entry_points");
    tx = astBuilder.transaction(arg_list, entrypoint);
    return tx;
  };

  walk = function(root, ctx) {
    var action, action_enum, action_list, add, add_list, arg_type, args, block, call, comment, contract_type, dst, name, param, request, right_comb_action, right_comb_add, token_and_dst, transfer, transfers, tx, update, _ref, _ref1;
    switch (root.constructor.name) {
      case "Class_decl":
        ctx.callbacks_to_declare_map = new Map;
        root = ctx.next_gen(root, ctx);
        ctx.callbacks_to_declare_map.forEach(function(decl) {
          return root.scope.list.unshift(decl);
        });
        return root;
      case "Var_decl":
        if (((_ref = root.type) != null ? _ref.main : void 0) === ctx.interface_name) {
          root.type = new Type("address");
        }
        return ctx.next_gen(root, ctx);
      case "Fn_decl_multiret":
        ctx.current_scope_ops_count = 0;
        return ctx.next_gen(root, ctx);
      case "Fn_call":
        if (root.fn.name === ctx.interface_name) {
          return astBuilder.cast_to_address(root.arg_list[0]);
        }
        if ((_ref1 = root.fn.t) != null ? _ref1.type : void 0) {
          switch (root.fn.t.type.main) {
            case "struct":
            case ctx.interface_name:
              switch (root.fn.name) {
                case "transferFrom":
                case "safeTransferFrom":
                  args = root.arg_list;
                  dst = new ast.Tuple;
                  dst.list.push(astBuilder.cast_to_address(args[1]));
                  dst.list.push(astBuilder.nat_literal(1));
                  token_and_dst = new ast.Tuple;
                  token_and_dst.list.push(args[2]);
                  token_and_dst.list.push(dst);
                  transfer = new ast.Tuple;
                  transfer.list.push(astBuilder.list_init([token_and_dst]));
                  transfer.list.push(astBuilder.cast_to_address(args[0]));
                  transfers = astBuilder.list_init([transfer]);
                  call = astBuilder.enum_val("@Transfer", [transfers]);
                  tx = tx_node(root.fn.t, [call], ctx);
                  if (root.fn.name === "safeTransferFrom") {
                    block = new ast.Scope;
                    block.need_nest = false;
                    block.list.push(root);
                    block.list.push(comment = new ast.Comment);
                    comment.text = "^ " + root.fn.name + " is not supported in LIGO. Read more https://git.io/JJFij ^";
                    return block;
                  } else {
                    return tx;
                  }
                  break;
                case "balanceOf":
                  name = "Balance_of";
                  args = root.arg_list;
                  param = new ast.Tuple;
                  param.list.push(astBuilder.nat_literal(0));
                  param.list.push(astBuilder.cast_to_address(args[0]));
                  arg_type = new Type("list<>");
                  arg_type.nest_list[0] = new Type("@balance_of_response_michelson");
                  contract_type = new Type("contract");
                  contract_type.nest_list.push(arg_type);
                  request = new ast.Tuple;
                  request.list.push(astBuilder.list_init([param]));
                  request.list.push(astBuilder.self_entrypoint("%" + name + "Callback", contract_type));
                  declare_callback(name, arg_type, ctx);
                  call = astBuilder.enum_val("@Balance_of", [request]);
                  return tx_node(root.fn.t, [call], ctx);
                case "approve":
                  param = new ast.Tuple;
                  param.list.push(astBuilder.tezos_var("sender"));
                  param.list.push(astBuilder.cast_to_address(root.arg_list[0]));
                  add = astBuilder.enum_val("@Add_operator", [param]);
                  right_comb_add = astBuilder.to_right_comb([add]);
                  add_list = astBuilder.list_init([right_comb_add]);
                  update = astBuilder.enum_val("@Update_operators", [add_list]);
                  return tx_node(root.fn.t, [update], ctx);
                case "setApprovalForAll":
                  args = root.arg_list;
                  param = new ast.Tuple;
                  param.list.push(astBuilder.tezos_var("sender"));
                  param.list.push(astBuilder.cast_to_address(root.arg_list[0]));
                  if (args[1].val === 'true') {
                    action = "@Add_operator";
                  } else {
                    action = "@Remove_operator";
                  }
                  action_enum = astBuilder.enum_val(action, [param]);
                  right_comb_action = astBuilder.to_right_comb([action_enum]);
                  action_list = astBuilder.list_init([right_comb_action]);
                  update = astBuilder.enum_val("@Update_operators", [action_list]);
                  return tx_node(root.fn.t, [update], ctx);
                case "isApprovedForAll":
                case "getApproved":
                case "ownerOf":
                  block = new ast.Scope;
                  block.need_nest = false;
                  block.list.push(root);
                  block.list.push(comment = new ast.Comment);
                  comment.text = "^ " + root.fn.name + " is not supported in LIGO. Read more https://git.io/JJFij ^";
                  return block;
              }
          }
        }
        return ctx.next_gen(root, ctx);
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.erc721_converter = function(root, ctx) {
    var init_ctx;
    init_ctx = {
      walk: walk,
      next_gen: default_walk
    };
    return walk(root, obj_merge(init_ctx, ctx));
  };

}).call(window.require_register("./transforms/erc721_converter"));
/*/lib/transforms/return_op_list_count.js*/(function() {
  var Type, ast, astBuilder, default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  astBuilder = require("../ast_builder");

  Type = window.Type;

  walk = function(root, ctx) {
    var declaration, i, list_init, op_index, v, _i, _ref;
    switch (root.constructor.name) {
      case "Fn_decl_multiret":
        ctx.current_fn_opcount = 0;
        return ctx.next_gen(root, ctx);
      case "Fn_call":
        if (root.fn.name === "transaction") {
          op_index = ctx.current_fn_opcount;
          declaration = astBuilder.declaration("op" + op_index, root, new Type("operation"));
          ctx.current_fn_opcount += 1;
          return declaration;
        }
        return ctx.next_gen(root, ctx);
      case "Ret_multi":
        if (ctx.current_fn_opcount > 0) {
          list_init = new ast.Array_init;
          list_init.type = new Type("built_in_op_list");
          for (i = _i = 0, _ref = ctx.current_fn_opcount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            list_init.list.push(v = new ast.Var);
            v.name = "op" + i;
          }
          root.t_list[0] = list_init;
          return root;
        } else {
          return ctx.next_gen(root, ctx);
        }
        break;
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.return_op_list_count = function(root) {
    return walk(root, {
      walk: walk,
      next_gen: default_walk
    });
  };

}).call(window.require_register("./transforms/return_op_list_count"));
/*/lib/transforms/address_calls_converter.js*/(function() {
  var Type, ast, astBuilder, config, default_walk, tx_node, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  astBuilder = require("../ast_builder");

  tx_node = function(arg_list, cost, address_expr, name, ctx) {
    var entrypoint, tez_cost, tx;
    entrypoint = astBuilder.foreign_entrypoint(address_expr, name);
    tez_cost = astBuilder.cast_to_tez(cost);
    tx = astBuilder.transaction(arg_list, entrypoint, tez_cost);
    return tx;
  };

  walk = function(root, ctx) {
    var _ref;
    switch (root.constructor.name) {
      case "Fn_decl_multiret":
        ctx.current_scope_ops_count = 0;
        return ctx.next_gen(root, ctx);
      case "Fn_call":
        if ((_ref = root.fn.t) != null ? _ref.type : void 0) {
          switch (root.fn.t.type.main) {
            case "address":
              switch (root.fn.name) {
                case "transfer":
                  return tx_node([astBuilder.unit()], root.arg_list[0], root.fn.t, "unit", ctx);
                case "delegatecall":
                  return tx_node([astBuilder.unit()], root.arg_list[0], root.fn.t, "unit", ctx);
                case "call":
                  return tx_node([astBuilder.unit()], root.arg_list[0], root.fn.t, "unit", ctx);
                case "send":
                  return tx_node([astBuilder.unit()], root.arg_list[0], root.fn.t, "unit", ctx);
              }
          }
        }
        return ctx.next_gen(root, ctx);
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.address_calls_converter = function(root, ctx) {
    return walk(root, ctx = obj_merge({
      walk: walk,
      next_gen: default_walk
    }, ctx));
  };

}).call(window.require_register("./transforms/address_calls_converter"));
/*/lib/transforms/split_nested_index_access.js*/(function() {
  var Type, ast, default_walk;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  Type = window.Type;

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        var current_scope_sink, idx, is_nested_index_access, res, statements, tmp, v, _i, _len, _ref;
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "Scope":
            statements = [];
            _ref = root.list;
            for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
              v = _ref[idx];
              ctx.scope_sink.unshift({
                statements_to_prepend: [],
                temp_index: 0
              });
              res = walk(v, ctx);
              statements.append(ctx.scope_sink[0].statements_to_prepend);
              ctx.scope_sink.shift();
              statements.push(res);
            }
            root.list = statements;
            return root;
          case "Bin_op":
            root.a = walk(root.a, ctx);
            is_nested_index_access = root.op === "INDEX_ACCESS" && root.a.constructor.name === "Bin_op" && root.a.op === "INDEX_ACCESS";
            if (is_nested_index_access) {
              current_scope_sink = ctx.scope_sink[0];
              tmp = new ast.Var_decl;
              tmp.name = "temp_idx_access" + current_scope_sink.temp_index;
              tmp.type = root.a.type;
              tmp.assign_value = root.a;
              current_scope_sink.statements_to_prepend.push(tmp);
              root.a = new ast.Var;
              root.a.name = tmp.name;
              current_scope_sink.temp_index += 1;
            }
            root.b = walk(root.b, ctx);
            return root;
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.split_nested_index_access = function(root, ctx) {
        return walk(root, {
          walk: walk,
          next_gen: default_walk,
          scope_sink: []
        });
      };
    });
  })(this)();

}).call(window.require_register("./transforms/split_nested_index_access"));
/*/lib/transforms/erc_detector.js*/(function() {
  var ERC20_METHODS_TOTAL, ERC721_METHODS_TOTAL, Type, ast, astBuilder, config, default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  astBuilder = require("../ast_builder");

  ERC20_METHODS_TOTAL = 6;

  ERC721_METHODS_TOTAL = 9;

  walk = function(root, ctx) {
    var entry, erc20_methods_count, erc721_methods_count, ret, _i, _len, _ref;
    switch (root.constructor.name) {
      case "Class_decl":
        erc20_methods_count = 0;
        erc721_methods_count = 0;
        _ref = root.scope.list;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          entry = _ref[_i];
          if (entry.constructor.name === "Fn_decl_multiret") {
            if (entry.scope.list.length === 0) {
              switch (entry.name) {
                case "approve":
                case "totalSupply":
                case "balanceOf":
                case "allowance":
                case "transfer":
                case "transferFrom":
                  erc20_methods_count += 1;
              }
              switch (entry.name) {
                case "balanceOf":
                case "ownerOf":
                case "safeTransferFrom":
                case "transferFrom":
                case "approve":
                case "setApprovalForAll":
                case "getApproved":
                case "isApprovedForAll":
                  erc721_methods_count += 1;
              }
            }
          }
        }
        if (erc20_methods_count === ERC20_METHODS_TOTAL) {
          ctx.erc20_name = root.name;
          ret = new ast.Include;
          ret.path = "interfaces/fa1.2.ligo";
          return ret;
        } else if (erc721_methods_count === ERC721_METHODS_TOTAL) {
          ctx.erc721_name = root.name;
          ret = new ast.Include;
          ret.path = "interfaces/fa2.ligo";
          return ret;
        } else {
          return ctx.next_gen(root, ctx);
        }
        break;
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.erc_detector = function(root, ctx) {
    ctx = obj_merge(ctx, {
      walk: walk,
      next_gen: default_walk,
      erc20_name: null,
      erc721_name: null
    });
    root = walk(root, ctx);
    return {
      root: root,
      ctx: ctx
    };
  };

}).call(window.require_register("./transforms/erc_detector"));
/*/lib/transforms/make_calls_external.js*/(function() {
  var Type, ast, astBuilder, collect_local_decls, config, default_walk, foreign_calls_to_external, tx_node;

  default_walk = require("./default_walk").default_walk;

  Type = window.Type;

  ast = require("../ast");

  astBuilder = require("../ast_builder");

  config = require("../config");

  tx_node = function(arg_list, cost, address_expr, name, ctx) {
    var entrypoint, tez_cost, tx;
    entrypoint = astBuilder.foreign_entrypoint(address_expr, name);
    tez_cost = astBuilder.cast_to_tez(cost);
    tx = astBuilder.transaction(arg_list, entrypoint, tez_cost);
    return tx;
  };

  collect_local_decls = function(root, ctx) {
    switch (root.constructor.name) {
      case "Class_decl":
        ctx.is_cur_contract_main = root.is_last;
        ctx.foreign_contracts.add(root.name);
        return ctx.next_gen(root, ctx);
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  foreign_calls_to_external = function(root, ctx) {
    var arg, contract_type, entrypoint, is_foreign_call, name, tx, _i, _len, _ref, _ref1, _ref2;
    switch (root.constructor.name) {
      case "Fn_call":
        is_foreign_call = false;
        if ((_ref = root.fn.t) != null ? (_ref1 = _ref.type) != null ? _ref1.main : void 0 : void 0) {
          is_foreign_call = ctx.foreign_contracts.has(root.fn.t.type.main);
        }
        if (is_foreign_call) {
          name = root.fn.name;
          contract_type = new Type("contract");
          _ref2 = root.arg_list;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            arg = _ref2[_i];
            contract_type.nest_list.push(arg.type);
          }
          name = astBuilder.string_val("%" + name);
          entrypoint = astBuilder.get_entrypoint(name, root.fn.t, contract_type);
          tx = astBuilder.transaction(root.arg_list, entrypoint);
          return tx;
        } else {
          return ctx.next_gen(root, ctx);
        }
        break;
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.make_calls_external = function(root, ctx) {
    var full_ctx;
    full_ctx = {
      walk: collect_local_decls,
      next_gen: default_walk,
      is_cur_contract_main: false,
      foreign_contracts: new Set
    };
    collect_local_decls(root, obj_merge(ctx, full_ctx));
    return foreign_calls_to_external(root, obj_merge(full_ctx, {
      walk: foreign_calls_to_external,
      next_gen: default_walk
    }));
  };

}).call(window.require_register("./transforms/make_calls_external"));
/*/lib/transforms/add_burn_address.js*/(function() {
  var Type, ast, default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  Type = window.Type;

  walk = function(root, ctx) {
    var old_scope, v, _i, _len, _ref, _ref1, _ref2;
    switch (root.constructor.name) {
      case "Type_cast":
        if (root.target_type.main === "address" && root.t) {
          if (+root.t.val === 0) {
            ctx.need_burn_address = true;
          } else {
            root.t.val = "PLEASE_REPLACE_ETH_ADDRESS_" + root.t.val + "_WITH_A_TEZOS_ADDRESS";
            ctx.need_prevent_deploy = true;
          }
        }
        break;
      case "Class_decl":
        ctx.scope = "class";
        if (root.is_struct) {
          _ref = root.scope.list;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            if (v.constructor.name === "Var_decl") {
              if (((_ref1 = v.type) != null ? _ref1.main : void 0) === "address") {
                ctx.need_burn_address = true;
              }
            }
          }
        }
        break;
      case "Fn_decl_multiret":
        old_scope = ctx.scope;
        ctx.scope = "fn";
        root = ctx.next_gen(root, ctx);
        ctx.scope = old_scope;
        return root;
      case "Var_decl":
        if (((_ref2 = root.type) != null ? _ref2.main : void 0) === "address" && !root.assign_value && ctx.scope === "fn") {
          ctx.need_burn_address = true;
        }
    }
    return ctx.next_gen(root, ctx);
  };

  this.add_burn_address = function(root) {
    var ctx, decl;
    ctx = {
      walk: walk,
      next_gen: default_walk,
      need_burn_address: false,
      need_prevent_deploy: false,
      scope: ""
    };
    walk(root, ctx);
    if (ctx.need_burn_address) {
      decl = new ast.Var_decl;
      decl.type = new Type("address");
      decl.name = "burn_address";
      root.list.unshift(decl);
    }
    if (ctx.need_prevent_deploy) {
      root.need_prevent_deploy = true;
    }
    return root;
  };

}).call(window.require_register("./transforms/add_burn_address"));
/*/lib/transforms/cast_to_address.js*/(function() {
  var Type, ast, astBuilder, config, default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  astBuilder = require("../ast_builder");

  walk = function(root, ctx) {
    var arg, idx, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    switch (root.constructor.name) {
      case "Var_decl":
        if (((_ref = root.type) != null ? _ref.main : void 0) === "address") {
          if ((_ref1 = root.assign_value) != null ? _ref1.type : void 0) {
            if (root.assign_value.type.main !== "address") {
              root.assign_value = astBuilder.cast_to_address(root.assign_value);
            }
          }
        }
        return ctx.next_gen(root, ctx);
      case "Bin_op":
        if (root.op !== "INDEX_ACCESS") {
          if (((_ref2 = root.a.type) != null ? _ref2.main : void 0) === "address" && ((_ref3 = root.b.type) != null ? _ref3.main : void 0) !== "address") {
            root.b = astBuilder.cast_to_address(root.b);
          } else if (((_ref4 = root.a.type) != null ? _ref4.main : void 0) !== "address" && ((_ref5 = root.b.type) != null ? _ref5.main : void 0) === "address") {
            root.a = astBuilder.cast_to_address(root.a);
          }
        }
        return ctx.next_gen(root, ctx);
      case "Fn_call":
        _ref6 = root.arg_list;
        for (idx = _i = 0, _len = _ref6.length; _i < _len; idx = ++_i) {
          arg = _ref6[idx];
          if (((_ref7 = root.fn.type) != null ? (_ref8 = _ref7.nest_list[0]) != null ? (_ref9 = _ref8.nest_list[idx]) != null ? _ref9.main : void 0 : void 0 : void 0) === "address") {
            root.arg_list[idx] = astBuilder.cast_to_address(root.arg_list[idx]);
          }
        }
        return ctx.next_gen(root, ctx);
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.cast_to_address = function(root, ctx) {
    var init_ctx;
    init_ctx = {
      walk: walk,
      next_gen: default_walk
    };
    return walk(root, obj_merge(init_ctx, ctx));
  };

}).call(window.require_register("./transforms/cast_to_address"));
/*/lib/transforms/contract_object_to_address.js*/(function() {
  var Type, ast, astBuilder, config, default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  astBuilder = require("../ast_builder");

  walk = function(root, ctx) {
    switch (root.constructor.name) {
      case "Class_decl":
        if (root.is_contract || root.is_interface) {
          ctx.known_contracts.add(root.name);
        }
        return ctx.next_gen(root, ctx);
      case "Var_decl":
        if (ctx.known_contracts.has(root.type.main)) {
          root.type = new Type("address");
        }
        return ctx.next_gen(root, ctx);
      case "Fn_call":
        if (ctx.known_contracts.has(root.fn.name)) {
          return astBuilder.cast_to_address(root.arg_list[0]);
        } else {
          return ctx.next_gen(root, ctx);
        }
        break;
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.contract_object_to_address = function(root, ctx) {
    var init_ctx;
    init_ctx = {
      walk: walk,
      next_gen: default_walk,
      known_contracts: new Set
    };
    return walk(root, obj_merge(init_ctx, ctx));
  };

}).call(window.require_register("./transforms/contract_object_to_address"));
/*/lib/transforms/add_pow.js*/(function() {
  var Type, ast, default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  Type = window.Type;

  walk = function(root, ctx) {
    if (root.constructor.name === "Bin_op" && root.op === "POW") {
      ctx.need_pow = true;
    }
    return ctx.next_gen(root, ctx);
  };

  this.add_pow = function(root) {
    var ctx, decl;
    ctx = {
      walk: walk,
      next_gen: default_walk,
      need_pow: false
    };
    walk(root, ctx);
    if (ctx.need_pow) {
      decl = new ast.Fn_decl_multiret;
      decl.name = "pow";
      root.list.unshift(decl);
    }
    return root;
  };

}).call(window.require_register("./transforms/add_pow"));
/*/lib/transforms/erc20_interface_converter.js*/(function() {
  var ERC20_METHODS_TOTAL, Type, ast, astBuilder, callback_tx_node, config, default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  astBuilder = require("../ast_builder");

  ERC20_METHODS_TOTAL = 6;

  callback_tx_node = function(name, root, ctx) {
    var arg_list, cb_decl, cb_name, contract_type, return_callback, return_type;
    cb_name = name.substr(0, 1).toLowerCase() + name.substr(1) + "Callback";
    contract_type = new Type("contract");
    contract_type.val = "nat";
    return_callback = astBuilder.self_entrypoint("%" + cb_name, contract_type);
    if (!ctx.callbacks_to_declare_map.has(cb_name)) {
      return_type = root.fn.type.nest_list[ast.RETURN_VALUES].nest_list[ast.INPUT_ARGS];
      cb_decl = astBuilder.callback_declaration(name, return_type);
      ctx.callbacks_to_declare_map.set(cb_name, cb_decl);
    }
    arg_list = root.arg_list;
    arg_list.push(return_callback);
    return tx_node(root.fn.t, arg_list, name, ctx);
  };

  walk = function(root, ctx) {
    var comment, contract_type, entry, erc20_methods_count, idx, is_erc20, new_scope, _i, _j, _len, _len1, _ref, _ref1;
    switch (root.constructor.name) {
      case "Class_decl":
        erc20_methods_count = 0;
        _ref = root.scope.list;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          entry = _ref[_i];
          if (entry.constructor.name === "Fn_decl_multiret") {
            if (entry.scope.list.length !== 0) {
              switch (entry.name) {
                case "approve":
                case "totalSupply":
                case "balanceOf":
                case "allowance":
                case "transfer":
                case "transferFrom":
                  erc20_methods_count += 1;
              }
            }
          }
        }
        is_erc20 = erc20_methods_count === ERC20_METHODS_TOTAL;
        new_scope = [];
        if (is_erc20) {
          _ref1 = root.scope.list;
          for (idx = _j = 0, _len1 = _ref1.length; _j < _len1; idx = ++_j) {
            entry = _ref1[idx];
            if (entry.constructor.name === "Fn_decl_multiret") {
              switch (entry.name) {
                case "approve":
                  null;
                  break;
                case "totalSupply":
                  contract_type = new Type("contract");
                  contract_type.val = "nat";
                  entry.type_i.nest_list.push(contract_type);
                  entry.arg_name_list.push("callback");
                  entry.name = "getTotalSupply";
                  comment = new ast.Comment;
                  comment.text = "in Tezos `totalSupply` method should not return a value, but perform a transaction to the passed contract callback with a needed value";
                  new_scope.push(comment);
                  break;
                case "transferFrom":
                  comment = new ast.Comment;
                  comment.text = "`transferFrom` and `transfer` methods should merged into one in Tezos' FA1.2";
                  new_scope.push(comment);
                  break;
                case "transfer":
                  entry.type_i.nest_list.unshift(new Type("address"));
                  entry.arg_name_list.unshift("from");
                  break;
                case "balanceOf":
                  contract_type = new Type("contract");
                  contract_type.val = "nat";
                  entry.type_i.nest_list.push(contract_type);
                  entry.arg_name_list.push("callback");
                  entry.name = "getBalance";
                  comment = new ast.Comment;
                  comment.text = "in Tezos `balanceOf` method should not return a value, but perform a transaction to the passed contract callback with a needed value";
                  new_scope.push(comment);
                  break;
                case "allowance":
                  contract_type = new Type("contract");
                  contract_type.val = "nat";
                  entry.type_i.nest_list.push(contract_type);
                  entry.arg_name_list.push("callback");
                  entry.name = "getAllowance";
                  comment = new ast.Comment;
                  comment.text = "in Tezos `allowance` method should not return a value, but perform a transaction to the passed contract callback with a needed value";
                  new_scope.push(comment);
              }
            }
            new_scope.push(entry);
          }
        }
        if (new_scope.length) {
          root.scope.list = new_scope;
        }
        return ctx.next_gen(root, ctx);
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.erc20_interface_converter = function(root, ctx) {
    var init_ctx;
    init_ctx = {
      walk: walk,
      next_gen: default_walk
    };
    return walk(root, obj_merge(init_ctx, ctx));
  };

}).call(window.require_register("./transforms/erc20_interface_converter"));
/*/lib/transforms/erc721_interface_converter.js*/(function() {
  var ERC721_METHODS_TOTAL, Type, ast, astBuilder, callback_tx_node, config, default_walk, walk;

  default_walk = require("./default_walk").default_walk;

  config = require("../config");

  Type = window.Type;

  ast = require("../ast");

  astBuilder = require("../ast_builder");

  ERC721_METHODS_TOTAL = 9;

  callback_tx_node = function(name, root, ctx) {
    var arg_list, cb_decl, cb_name, contract_type, return_callback, return_type;
    cb_name = name.substr(0, 1).toLowerCase() + name.substr(1) + "Callback";
    contract_type = new Type("contract");
    contract_type.val = "nat";
    return_callback = astBuilder.self_entrypoint("%" + cb_name, contract_type);
    if (!ctx.callbacks_to_declare_map.has(cb_name)) {
      return_type = root.fn.type.nest_list[ast.RETURN_VALUES].nest_list[ast.INPUT_ARGS];
      cb_decl = astBuilder.callback_declaration(name, return_type);
      ctx.callbacks_to_declare_map.set(cb_name, cb_decl);
    }
    arg_list = root.arg_list;
    arg_list.push(return_callback);
    return tx_node(root.fn.t, arg_list, name, ctx);
  };

  walk = function(root, ctx) {
    var comment, entry, erc721_methods_count, idx, is_erc721, new_scope, type, _i, _j, _len, _len1, _ref, _ref1;
    switch (root.constructor.name) {
      case "Class_decl":
        erc721_methods_count = 0;
        _ref = root.scope.list;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          entry = _ref[_i];
          if (entry.constructor.name === "Fn_decl_multiret") {
            if (entry.scope.list.length !== 0) {
              switch (entry.name) {
                case "balanceOf":
                case "ownerOf":
                case "safeTransferFrom":
                case "transferFrom":
                case "approve":
                case "setApprovalForAll":
                case "getApproved":
                case "isApprovedForAll":
                  erc721_methods_count += 1;
              }
            }
          }
        }
        is_erc721 = erc721_methods_count === ERC721_METHODS_TOTAL;
        new_scope = [];
        if (is_erc721) {
          _ref1 = root.scope.list;
          for (idx = _j = 0, _len1 = _ref1.length; _j < _len1; idx = ++_j) {
            entry = _ref1[idx];
            if (entry.constructor.name === "Fn_decl_multiret") {
              switch (entry.name) {
                case "isApprovedForAll":
                case "getApproved":
                case "ownerOf":
                  comment = new ast.Comment;
                  comment.text = "" + entry.name + " is not present in FA2. Read more https://git.io/JJFij";
                  new_scope.push(comment);
                  break;
                case "transferFrom":
                case "safeTransferFrom":
                  comment = new ast.Comment;
                  comment.text = "`safeTransferFrom` and `transferFrom` methods should be merged into one in Tezos' FA2. Read more https://git.io/JJFij";
                  new_scope.push(comment);
                  entry.type_i.nest_list = [new Type("list<@transfer_michelson>")];
                  entry.arg_name_list = ["param"];
                  entry.name = entry.name.replace("From", "");
                  break;
                case "balanceOf":
                  type = new Type("@balance_of_param_michelson");
                  entry.type_i.nest_list = [type];
                  entry.arg_name_list = ["param"];
                  entry.name = "balance_of";
                  comment = new ast.Comment;
                  comment.text = "in Tezos `balanceOf` method should not return a value, but perform a transaction to the passed contract callback with a needed value";
                  new_scope.push(comment);
                  break;
                case "setApprovalForAll":
                case "approve":
                  entry.type_i.nest_list = [new Type("list<@update_operator_michelson>")];
                  entry.arg_name_list = ["param"];
                  entry.name = "update_operators__" + entry.name;
                  comment = new ast.Comment;
                  comment.text = "in Tezos approval methods are merged into one `Update_operators` method. You ought to handle Add_operator and Remove_operator params inside of it";
                  new_scope.push(comment);
              }
            }
            new_scope.push(entry);
          }
        }
        if (new_scope.length) {
          root.scope.list = new_scope;
        }
        return ctx.next_gen(root, ctx);
      default:
        return ctx.next_gen(root, ctx);
    }
  };

  this.erc721_interface_converter = function(root, ctx) {
    var init_ctx;
    init_ctx = {
      walk: walk,
      next_gen: default_walk
    };
    return walk(root, obj_merge(init_ctx, ctx));
  };

}).call(window.require_register("./transforms/erc721_interface_converter"));
/*/lib/transforms/split_chain_assignment.js*/(function() {
  var Type, array_side_unpack, ast, default_walk, flatten, ret_select;

  default_walk = require("./default_walk").default_walk;

  ast = require("../ast");

  Type = window.Type;

  flatten = function(list) {
    var res_list, v, _i, _len;
    res_list = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      v = list[_i];
      if (v instanceof Array) {
        res_list.append(flatten(v));
      } else {
        res_list.push(v);
      }
    }
    return res_list;
  };

  array_side_unpack = function(res_list, t) {
    var ret;
    if (t instanceof Array) {
      ret = t.pop();
      res_list.append(t);
      return ret;
    }
    return t;
  };

  ret_select = function(root, res_list) {
    if (res_list.length === 0) {
      return root;
    }
    res_list.push(root);
    return res_list;
  };

  (function(_this) {
    return (function() {
      var walk;
      walk = function(root, ctx) {
        var ctx_b, idx, is_left_to_right, res, res_list, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        walk = ctx.walk;
        switch (root.constructor.name) {
          case "Scope":
            _ref = root.list;
            for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
              v = _ref[idx];
              root.list[idx] = walk(v, ctx);
            }
            root.list = flatten(root.list);
            return root;
          case "Un_op":
            res_list = [];
            root.a = array_side_unpack(res_list, walk(root.a, ctx));
            return ret_select(root, res_list);
          case "Bin_op":
            res_list = [];
            is_left_to_right = !((_ref1 = root.op) === "ASSIGN");
            if (root.op === "ASSIGN") {
              ctx_b = clone(ctx);
              ctx_b.rvalue = true;
            } else {
              ctx_b = ctx;
            }
            if (is_left_to_right) {
              root.a = array_side_unpack(res_list, walk(root.a, ctx));
              root.b = array_side_unpack(res_list, walk(root.b, ctx_b));
            } else {
              root.b = array_side_unpack(res_list, walk(root.b, ctx_b));
              root.a = array_side_unpack(res_list, walk(root.a, ctx));
            }
            if (root.op === "ASSIGN" && ctx.rvalue) {
              res_list.push(root);
              root = root.a;
            }
            return ret_select(root, res_list);
          case "Var_decl":
          case "Var_decl_multi":
            res_list = [];
            if (root.assign_value) {
              ctx = clone(ctx);
              ctx.rvalue = true;
              root.assign_value = array_side_unpack(res_list, walk(root.assign_value, ctx));
            }
            return ret_select(root, res_list);
          case "Field_access":
          case "Throw":
          case "Type_cast":
            res_list = [];
            if (root.t) {
              root.t = array_side_unpack(res_list, walk(root.t, ctx));
            }
            return ret_select(root, res_list);
          case "Fn_call":
            res_list = [];
            root.fn = array_side_unpack(res_list, walk(root.fn, ctx));
            _ref2 = root.arg_list;
            for (idx = _j = 0, _len1 = _ref2.length; _j < _len1; idx = ++_j) {
              v = _ref2[idx];
              root.arg_list[idx] = array_side_unpack(res_list, walk(v, ctx));
            }
            return ret_select(root, res_list);
          case "Struct_init":
            res_list = [];
            _ref3 = root.val_list;
            for (idx = _k = 0, _len2 = _ref3.length; _k < _len2; idx = ++_k) {
              v = _ref3[idx];
              root.val_list[idx] = array_side_unpack(res_list, walk(v, ctx));
            }
            return ret_select(root, res_list);
          case "New":
            res_list = [];
            _ref4 = root.arg_list;
            for (idx = _l = 0, _len3 = _ref4.length; _l < _len3; idx = ++_l) {
              v = _ref4[idx];
              root.arg_list[idx] = array_side_unpack(res_list, walk(v, ctx));
            }
            return ret_select(root, res_list);
          case "Ret_multi":
            res_list = [];
            _ref5 = root.t_list;
            for (idx = _m = 0, _len4 = _ref5.length; _m < _len4; idx = ++_m) {
              v = _ref5[idx];
              root.t_list[idx] = array_side_unpack(res_list, walk(v, ctx));
            }
            return ret_select(root, res_list);
          case "If":
          case "Ternary":
            res_list = [];
            root.cond = array_side_unpack(res_list, walk(root.cond, ctx));
            root.t = array_side_unpack(res_list, walk(root.t, ctx));
            root.f = array_side_unpack(res_list, walk(root.f, ctx));
            return ret_select(root, res_list);
          case "While":
            res_list = [];
            root.cond = array_side_unpack(res_list, walk(root.cond, ctx));
            root.scope = array_side_unpack(res_list, walk(root.scope, ctx));
            return ret_select(root, res_list);
          case "For3":
            res_list = [];
            if (root.init) {
              root.init = array_side_unpack(res_list, walk(root.init, ctx));
            }
            if (root.cond) {
              res = walk(root.cond, ctx);
              if (res instanceof Array) {
                perr("WARNING (AST transform). Chained assignment in a for condition is not supported; prevent_deploy flag raised.");
                ctx.need_prevent_deploy_obj.value = true;
              } else {
                root.cond = res;
              }
            }
            if (root.iter) {
              res = walk(root.iter, ctx);
              if (res instanceof Array) {
                perr("WARNING (AST transform). Chained assignment in a for iterator is not supported; prevent_deploy flag raised.");
                ctx.need_prevent_deploy_obj.value = true;
              } else {
                root.iter = res;
              }
            }
            root.scope = walk(root.scope, ctx);
            return ret_select(root, res_list);
          case "Tuple":
          case "Array_init":
            res_list = [];
            _ref6 = root.list;
            for (idx = _n = 0, _len5 = _ref6.length; _n < _len5; idx = ++_n) {
              v = _ref6[idx];
              root.list[idx] = array_side_unpack(res_list, walk(v, ctx));
            }
            return ret_select(root, res_list);
          default:
            return ctx.next_gen(root, ctx);
        }
      };
      return _this.split_chain_assignment = function(root) {
        var ctx;
        ctx = {
          walk: walk,
          next_gen: default_walk,
          need_prevent_deploy_obj: {
            value: false
          }
        };
        walk(root, ctx);
        if (ctx.need_prevent_deploy_obj.value) {
          root.need_prevent_deploy = true;
        }
        return root;
      };
    });
  })(this)();

}).call(window.require_register("./transforms/split_chain_assignment"));
/*/lib/ast_transform.js*/(function() {
  var add_burn_address, add_pow, add_router, address_calls_converter, ass_op_unpack, call_storage_and_oplist_inject, cast_to_address, contract_object_to_address, decl_storage_and_oplist_inject, deep_check_storage_and_oplist_use, erc20_converter, erc20_interface_converter, erc721_converter, erc721_interface_converter, erc_detector, ercs_translate, fix_missing_emit, fix_modifier_order, for3_unpack, inheritance_unpack, intrinsics_converter, make_calls_external, mark_last, math_funcs_convert, modifier_unpack, module, replace_enums_by_nat, require_distinguish, return_op_list_count, router_collector, split_chain_assignment, split_nested_index_access, translate_type, translate_var_name, var_translate;

  module = this;

  var_translate = require("./transforms/var_translate").var_translate;

  require_distinguish = require("./transforms/require_distinguish").require_distinguish;

  fix_missing_emit = require("./transforms/fix_missing_emit").fix_missing_emit;

  fix_modifier_order = require("./transforms/fix_modifier_order").fix_modifier_order;

  for3_unpack = require("./transforms/for3_unpack").for3_unpack;

  math_funcs_convert = require("./transforms/math_funcs_convert").math_funcs_convert;

  ass_op_unpack = require("./transforms/ass_op_unpack").ass_op_unpack;

  modifier_unpack = require("./transforms/modifier_unpack").modifier_unpack;

  inheritance_unpack = require("./transforms/inheritance_unpack").inheritance_unpack;

  deep_check_storage_and_oplist_use = require("./transforms/deep_check_storage_and_oplist_use").deep_check_storage_and_oplist_use;

  decl_storage_and_oplist_inject = require("./transforms/decl_storage_and_oplist_inject").decl_storage_and_oplist_inject;

  mark_last = require("./transforms/mark_last").mark_last;

  router_collector = require("./transforms/router_collector").router_collector;

  add_router = require("./transforms/add_router").add_router;

  call_storage_and_oplist_inject = require("./transforms/call_storage_and_oplist_inject").call_storage_and_oplist_inject;

  replace_enums_by_nat = require("./transforms/replace_enums_by_nat").replace_enums_by_nat;

  intrinsics_converter = require("./transforms/intrinsics_converter").intrinsics_converter;

  erc20_converter = require("./transforms/erc20_converter").erc20_converter;

  erc721_converter = require("./transforms/erc721_converter").erc721_converter;

  return_op_list_count = require("./transforms/return_op_list_count").return_op_list_count;

  address_calls_converter = require("./transforms/address_calls_converter").address_calls_converter;

  split_nested_index_access = require("./transforms/split_nested_index_access").split_nested_index_access;

  make_calls_external = require("./transforms/make_calls_external").make_calls_external;

  add_burn_address = require("./transforms/add_burn_address").add_burn_address;

  add_pow = require("./transforms/add_pow").add_pow;

  cast_to_address = require("./transforms/cast_to_address").cast_to_address;

  contract_object_to_address = require("./transforms/contract_object_to_address").contract_object_to_address;

  erc20_interface_converter = require("./transforms/erc20_interface_converter").erc20_interface_converter;

  erc721_interface_converter = require("./transforms/erc721_interface_converter").erc721_interface_converter;

  split_chain_assignment = require("./transforms/split_chain_assignment").split_chain_assignment;

  erc_detector = require("./transforms/erc_detector").erc_detector;

  translate_var_name = require("./translate_var_name").translate_var_name;

  translate_type = require("./translate_ligo").translate_type;

  this.pre_ti = function(root, opt) {
    if (opt == null) {
      opt = {};
    }
    if (opt.replace_enums_by_nats == null) {
      opt.replace_enums_by_nats = true;
    }
    root = require_distinguish(root);
    root = fix_missing_emit(root);
    root = fix_modifier_order(root);
    root = for3_unpack(root);
    root = math_funcs_convert(root);
    root = ass_op_unpack(root);
    root = modifier_unpack(root);
    root = inheritance_unpack(root);
    if (opt.replace_enums_by_nats) {
      root = replace_enums_by_nat(root);
    }
    return root;
  };

  this.post_ti = function(root, opt) {
    var router_func_list;
    if (opt == null) {
      opt = {};
    }
    if (opt.router == null) {
      opt.router = true;
    }
    root = split_nested_index_access(root);
    root = split_chain_assignment(root);
    root = address_calls_converter(root);
    root = ercs_translate(root, opt);
    root = contract_object_to_address(root, opt);
    root = intrinsics_converter(root);
    root = mark_last(root, opt);
    root = make_calls_external(root, opt);
    root = var_translate(root);
    root = deep_check_storage_and_oplist_use(root);
    root = decl_storage_and_oplist_inject(root, opt);
    root = call_storage_and_oplist_inject(root);
    root = cast_to_address(root, opt);
    if (opt.router) {
      router_func_list = router_collector(root, opt);
      root = add_router(root, obj_merge({
        router_func_list: router_func_list
      }, opt));
    }
    root = return_op_list_count(root, opt);
    root = add_burn_address(root, opt);
    root = add_pow(root, opt);
    return root;
  };

  ercs_translate = function(root, opt) {
    var ctx, _ref;
    _ref = erc_detector(root), root = _ref.root, ctx = _ref.ctx;
    if (!!ctx.erc721_name) {
      root = erc721_converter(root, {
        interface_name: ctx.erc721_name
      });
    } else if (!!ctx.erc20_name) {
      root = erc20_converter(root, {
        interface_name: ctx.erc20_name
      });
    }
    root = erc20_interface_converter(root, opt);
    root = erc721_interface_converter(root, opt);
    return root;
  };

}).call(window.require_register("./ast_transform"));
